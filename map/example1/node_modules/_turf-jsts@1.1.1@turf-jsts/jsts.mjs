/* Polyfill service v3.13.0
 * For detailed credits and licence information see http://github.com/financial-times/polyfill-service
 *
 * - Array.prototype.fill, License: CC0 */

if (!('fill' in Array.prototype)) {
  Object.defineProperty(Array.prototype, 'fill', {
    configurable: true,
    value: function fill (value) {
      if (this === undefined || this === null) {
        throw new TypeError(this + ' is not an object')
      }

      var arrayLike = Object(this);

      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;

      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;

      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);

      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;

      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);

      while (relativeStart < relativeEnd) {
        arrayLike[relativeStart] = value;

        ++relativeStart;
      }

      return arrayLike
    },
    writable: true
  });
}

/**
 * Polyfill for IE support
 */
Number.isFinite = Number.isFinite || function (value) {
  return typeof value === 'number' && isFinite(value)
};

Number.isInteger = Number.isInteger || function (val) {
  return typeof val === 'number' &&
  isFinite(val) &&
  Math.floor(val) === val
};

Number.parseFloat = Number.parseFloat || parseFloat;

Number.isNaN = Number.isNaN || function (value) {
  return value !== value // eslint-disable-line
};

/**
 * Polyfill for IE support
 */
Math.trunc = Math.trunc || function (x) {
  return x < 0 ? Math.ceil(x) : Math.floor(x)
};

class NumberUtil {
  interfaces_ () {
    return []
  }
  getClass () {
    return NumberUtil
  }
  equalsWithTolerance (x1, x2, tolerance) {
    return Math.abs(x1 - x2) <= tolerance
  }
}

class IllegalArgumentException {}

class Double {
  static isNaN (n) { return Number.isNaN(n) }
  static doubleToLongBits (n) { return n }
  static longBitsToDouble (n) { return n }
  static isInfinite (n) { return !Number.isFinite(n) }
  static get MAX_VALUE () { return Number.MAX_VALUE }
}

class Comparable {}

class Clonable {}

class Comparator {}

function Serializable () {}

// import Assert from '../util/Assert'

class Coordinate {
  constructor () {
    this.x = null;
    this.y = null;
    this.z = null;
    if (arguments.length === 0) {
      this.x = 0.0;
      this.y = 0.0;
      this.z = Coordinate.NULL_ORDINATE;
    } else if (arguments.length === 1) {
      const c = arguments[0];
      this.x = c.x;
      this.y = c.y;
      this.z = c.z;
    } else if (arguments.length === 2) {
      this.x = arguments[0];
      this.y = arguments[1];
      this.z = Coordinate.NULL_ORDINATE;
    } else if (arguments.length === 3) {
      this.x = arguments[0];
      this.y = arguments[1];
      this.z = arguments[2];
    }
  }
  setOrdinate (ordinateIndex, value) {
    switch (ordinateIndex) {
      case Coordinate.X:
        this.x = value;
        break
      case Coordinate.Y:
        this.y = value;
        break
      case Coordinate.Z:
        this.z = value;
        break
      default:
        throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)
    }
  }
  equals2D () {
    if (arguments.length === 1) {
      let other = arguments[0];
      if (this.x !== other.x) {
        return false
      }
      if (this.y !== other.y) {
        return false
      }
      return true
    } else if (arguments.length === 2) {
      const c = arguments[0];
      const tolerance = arguments[1];
      if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
        return false
      }
      if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
        return false
      }
      return true
    }
  }
  getOrdinate (ordinateIndex) {
    switch (ordinateIndex) {
      case Coordinate.X:
        return this.x
      case Coordinate.Y:
        return this.y
      case Coordinate.Z:
        return this.z
      default:
    }
    throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)
  }
  equals3D (other) {
    return this.x === other.x &&
           this.y === other.y &&
           ((this.z === other.z || Double.isNaN(this.z)) &&
           Double.isNaN(other.z))
  }
  equals (other) {
    if (!(other instanceof Coordinate)) {
      return false
    }
    return this.equals2D(other)
  }
  equalInZ (c, tolerance) {
    return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance)
  }
  compareTo (o) {
    var other = o;
    if (this.x < other.x) return -1
    if (this.x > other.x) return 1
    if (this.y < other.y) return -1
    if (this.y > other.y) return 1
    return 0
  }
  clone () {
    // try {
    //   var coord = null
    //   return coord
    // } catch (e) {
    //   if (e instanceof CloneNotSupportedException) {
    //     Assert.shouldNeverReachHere("this shouldn't happen because this class is Cloneable")
    //     return null
    //   } else throw e
    // } finally {}
  }
  copy () {
    return new Coordinate(this)
  }
  toString () {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ')'
  }
  distance3D (c) {
    var dx = this.x - c.x;
    var dy = this.y - c.y;
    var dz = this.z - c.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz)
  }
  distance (c) {
    var dx = this.x - c.x;
    var dy = this.y - c.y;
    return Math.sqrt(dx * dx + dy * dy)
  }
  hashCode () {
    var result = 17;
    result = 37 * result + Coordinate.hashCode(this.x);
    result = 37 * result + Coordinate.hashCode(this.y);
    return result
  }
  setCoordinate (other) {
    this.x = other.x;
    this.y = other.y;
    this.z = other.z;
  }
  interfaces_ () {
    return [Comparable, Clonable, Serializable]
  }
  getClass () {
    return Coordinate
  }
  static hashCode () {
    if (arguments.length === 1) {
      const x = arguments[0];
      const f = Double.doubleToLongBits(x);
      return Math.trunc((f ^ f) >>> 32)
    }
  }
  static get DimensionalComparator () { return DimensionalComparator }
  static get serialVersionUID () { return 6683108902428366910 }
  static get NULL_ORDINATE () { return Double.NaN }
  static get X () { return 0 }
  static get Y () { return 1 }
  static get Z () { return 2 }
}

class DimensionalComparator {
  constructor (dimensionsToTest) {
    this._dimensionsToTest = 2;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      let dimensionsToTest = arguments[0];
      if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException('only 2 or 3 dimensions may be specified')
      this._dimensionsToTest = dimensionsToTest;
    }
  }
  compare (o1, o2) {
    var c1 = o1;
    var c2 = o2;
    var compX = DimensionalComparator.compare(c1.x, c2.x);
    if (compX !== 0) return compX
    var compY = DimensionalComparator.compare(c1.y, c2.y);
    if (compY !== 0) return compY
    if (this._dimensionsToTest <= 2) return 0
    var compZ = DimensionalComparator.compare(c1.z, c2.z);
    return compZ
  }
  interfaces_ () {
    return [Comparator]
  }
  getClass () {
    return DimensionalComparator
  }
  static compare (a, b) {
    if (a < b) return -1
    if (a > b) return 1
    if (Double.isNaN(a)) {
      if (Double.isNaN(b)) return 0
      return -1
    }
    if (Double.isNaN(b)) return 1
    return 0
  }
}

// import hasInterface from '../../../../hasInterface'
// import CoordinateSequence from './CoordinateSequence'

class CoordinateSequenceFactory {
  create () {
    // if (arguments.length === 1) {
    //   if (arguments[0] instanceof Array) {
    //     let coordinates = arguments[0]
    //   } else if (hasInterface(arguments[0], CoordinateSequence)) {
    //     let coordSeq = arguments[0]
    //   }
    // } else if (arguments.length === 2) {
    //   let size = arguments[0]
    //   let dimension = arguments[1]
    // }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return CoordinateSequenceFactory
  }
}

class Location {
  interfaces_ () {
    return []
  }
  getClass () {
    return Location
  }
  static toLocationSymbol (locationValue) {
    switch (locationValue) {
      case Location.EXTERIOR:
        return 'e'
      case Location.BOUNDARY:
        return 'b'
      case Location.INTERIOR:
        return 'i'
      case Location.NONE:
        return '-'
      default:
    }
    throw new IllegalArgumentException('Unknown location value: ' + locationValue)
  }
  static get INTERIOR () { return 0 }
  static get BOUNDARY () { return 1 }
  static get EXTERIOR () { return 2 }
  static get NONE () { return -1 }
}

var hasInterface = function (o, i) {
  return o.interfaces_ && o.interfaces_().indexOf(i) > -1
};

class MathUtil {
  interfaces_ () {
    return []
  }
  getClass () {
    return MathUtil
  }
  static log10 (x) {
    var ln = Math.log(x);
    if (Double.isInfinite(ln)) return ln
    if (Double.isNaN(ln)) return ln
    return ln / MathUtil.LOG_10
  }
  static min (v1, v2, v3, v4) {
    var min = v1;
    if (v2 < min) min = v2;
    if (v3 < min) min = v3;
    if (v4 < min) min = v4;
    return min
  }
  static clamp () {
    if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {
      const x = arguments[0];
      const min = arguments[1];
      const max = arguments[2];
      if (x < min) return min
      if (x > max) return max
      return x
    } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {
      const x = arguments[0];
      const min = arguments[1];
      const max = arguments[2];
      if (x < min) return min
      if (x > max) return max
      return x
    }
  }
  static wrap (index, max) {
    if (index < 0) {
      return max - -index % max
    }
    return index % max
  }
  static max () {
    if (arguments.length === 3) {
      const v1 = arguments[0];
      const v2 = arguments[1];
      const v3 = arguments[2];
      let max = v1;
      if (v2 > max) max = v2;
      if (v3 > max) max = v3;
      return max
    } else if (arguments.length === 4) {
      const v1 = arguments[0];
      const v2 = arguments[1];
      const v3 = arguments[2];
      const v4 = arguments[3];
      let max = v1;
      if (v2 > max) max = v2;
      if (v3 > max) max = v3;
      if (v4 > max) max = v4;
      return max
    }
  }
  static average (x1, x2) {
    return (x1 + x2) / 2.0
  }
  static get LOG_10 () { return Math.log(10) }
}

class StringBuffer {
  constructor (str) {
    this.str = str;
  }
  append (e) {
    this.str += e;
  }

  setCharAt (i, c) {
    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
  }

  toString (e) {
    return this.str
  }
}

class Integer {
  constructor (value) {
    this.value = value;
  }
  intValue () {
    return this.value
  }
  compareTo (o) {
    if (this.value < o) return -1
    if (this.value > o) return 1
    return 0
  }
  static isNaN (n) { return Number.isNaN(n) }
}

class Character {
  static isWhitespace (c) { return ((c <= 32 && c >= 0) || c === 127) }
  static toUpperCase (c) { return c.toUpperCase() }
}

class DD {
  constructor () {
    this._hi = 0.0;
    this._lo = 0.0;
    if (arguments.length === 0) {
      this.init(0.0);
    } else if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        let x = arguments[0];
        this.init(x);
      } else if (arguments[0] instanceof DD) {
        let dd = arguments[0];
        this.init(dd);
      } else if (typeof arguments[0] === 'string') {
        let str = arguments[0];
        DD.call(this, DD.parse(str));
      }
    } else if (arguments.length === 2) {
      const hi = arguments[0];
      const lo = arguments[1];
      this.init(hi, lo);
    }
  }
  le (y) {
    return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo
  }
  extractSignificantDigits (insertDecimalPoint, magnitude) {
    var y = this.abs();
    var mag = DD.magnitude(y._hi);
    var scale = DD.TEN.pow(mag);
    y = y.divide(scale);
    if (y.gt(DD.TEN)) {
      y = y.divide(DD.TEN);
      mag += 1;
    } else if (y.lt(DD.ONE)) {
      y = y.multiply(DD.TEN);
      mag -= 1;
    }
    var decimalPointPos = mag + 1;
    var buf = new StringBuffer();
    var numDigits = DD.MAX_PRINT_DIGITS - 1;
    for (var i = 0; i <= numDigits; i++) {
      if (insertDecimalPoint && i === decimalPointPos) {
        buf.append('.');
      }
      var digit = Math.trunc(y._hi);
      if (digit < 0) {
        break
      }
      var rebiasBy10 = false;
      var digitChar = 0;
      if (digit > 9) {
        rebiasBy10 = true;
        digitChar = '9';
      } else {
        digitChar = '0' + digit;
      }
      buf.append(digitChar);
      y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
      if (rebiasBy10) y.selfAdd(DD.TEN);
      var continueExtractingDigits = true;
      var remMag = DD.magnitude(y._hi);
      if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;
      if (!continueExtractingDigits) break
    }
    magnitude[0] = mag;
    return buf.toString()
  }
  sqr () {
    return this.multiply(this)
  }
  doubleValue () {
    return this._hi + this._lo
  }
  subtract () {
    if (arguments[0] instanceof DD) {
      let y = arguments[0];
      return this.add(y.negate())
    } else if (typeof arguments[0] === 'number') {
      let y = arguments[0];
      return this.add(-y)
    }
  }
  equals () {
    if (arguments.length === 1) {
      let y = arguments[0];
      return this._hi === y._hi && this._lo === y._lo
    }
  }
  isZero () {
    return this._hi === 0.0 && this._lo === 0.0
  }
  selfSubtract () {
    if (arguments[0] instanceof DD) {
      let y = arguments[0];
      if (this.isNaN()) return this
      return this.selfAdd(-y._hi, -y._lo)
    } else if (typeof arguments[0] === 'number') {
      let y = arguments[0];
      if (this.isNaN()) return this
      return this.selfAdd(-y, 0.0)
    }
  }
  getSpecialNumberString () {
    if (this.isZero()) return '0.0'
    if (this.isNaN()) return 'NaN '
    return null
  }
  min (x) {
    if (this.le(x)) {
      return this
    } else {
      return x
    }
  }
  selfDivide () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DD) {
        let y = arguments[0];
        return this.selfDivide(y._hi, y._lo)
      } else if (typeof arguments[0] === 'number') {
        let y = arguments[0];
        return this.selfDivide(y, 0.0)
      }
    } else if (arguments.length === 2) {
      const yhi = arguments[0];
      const ylo = arguments[1];
      let hc = null;
      let tc = null;
      let hy = null;
      let ty = null;
      let C = null;
      let c = null;
      let U = null;
      let u = null;
      C = this._hi / yhi;
      c = DD.SPLIT * C;
      hc = c - C;
      u = DD.SPLIT * yhi;
      hc = c - hc;
      tc = C - hc;
      hy = u - yhi;
      U = C * yhi;
      hy = u - hy;
      ty = yhi - hy;
      u = hc * hy - U + hc * ty + tc * hy + tc * ty;
      c = (this._hi - U - u + this._lo - C * ylo) / yhi;
      u = C + c;
      this._hi = u;
      this._lo = C - u + c;
      return this
    }
  }
  dump () {
    return 'DD<' + this._hi + ', ' + this._lo + '>'
  }
  divide () {
    if (arguments[0] instanceof DD) {
      let y = arguments[0];
      let hc = null;
      let tc = null;
      let hy = null;
      let ty = null;
      let C = null;
      let c = null;
      let U = null;
      let u = null;
      C = this._hi / y._hi;
      c = DD.SPLIT * C;
      hc = c - C;
      u = DD.SPLIT * y._hi;
      hc = c - hc;
      tc = C - hc;
      hy = u - y._hi;
      U = C * y._hi;
      hy = u - hy;
      ty = y._hi - hy;
      u = hc * hy - U + hc * ty + tc * hy + tc * ty;
      c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
      u = C + c;
      var zhi = u;
      var zlo = C - u + c;
      return new DD(zhi, zlo)
    } else if (typeof arguments[0] === 'number') {
      let y = arguments[0];
      if (Double.isNaN(y)) return DD.createNaN()
      return DD.copy(this).selfDivide(y, 0.0)
    }
  }
  ge (y) {
    return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo
  }
  pow (exp) {
    if (exp === 0.0) return DD.valueOf(1.0)
    var r = new DD(this);
    var s = DD.valueOf(1.0);
    var n = Math.abs(exp);
    if (n > 1) {
      while (n > 0) {
        if (n % 2 === 1) {
          s.selfMultiply(r);
        }
        n /= 2;
        if (n > 0) r = r.sqr();
      }
    } else {
      s = r;
    }
    if (exp < 0) return s.reciprocal()
    return s
  }
  ceil () {
    if (this.isNaN()) return DD.NaN
    var fhi = Math.ceil(this._hi);
    var flo = 0.0;
    if (fhi === this._hi) {
      flo = Math.ceil(this._lo);
    }
    return new DD(fhi, flo)
  }
  compareTo (o) {
    var other = o;
    if (this._hi < other._hi) return -1
    if (this._hi > other._hi) return 1
    if (this._lo < other._lo) return -1
    if (this._lo > other._lo) return 1
    return 0
  }
  rint () {
    if (this.isNaN()) return this
    var plus5 = this.add(0.5);
    return plus5.floor()
  }
  setValue () {
    if (arguments[0] instanceof DD) {
      let value = arguments[0];
      this.init(value);
      return this
    } else if (typeof arguments[0] === 'number') {
      let value = arguments[0];
      this.init(value);
      return this
    }
  }
  max (x) {
    if (this.ge(x)) {
      return this
    } else {
      return x
    }
  }
  sqrt () {
    if (this.isZero()) return DD.valueOf(0.0)
    if (this.isNegative()) {
      return DD.NaN
    }
    var x = 1.0 / Math.sqrt(this._hi);
    var ax = this._hi * x;
    var axdd = DD.valueOf(ax);
    var diffSq = this.subtract(axdd.sqr());
    var d2 = diffSq._hi * (x * 0.5);
    return axdd.add(d2)
  }
  selfAdd () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DD) {
        let y = arguments[0];
        return this.selfAdd(y._hi, y._lo)
      } else if (typeof arguments[0] === 'number') {
        let y = arguments[0];
        let H = null;
        let h = null;
        let S = null;
        let s = null;
        let e = null;
        let f = null;
        S = this._hi + y;
        e = S - this._hi;
        s = S - e;
        s = y - e + (this._hi - s);
        f = s + this._lo;
        H = S + f;
        h = f + (S - H);
        this._hi = H + h;
        this._lo = h + (H - this._hi);
        return this
      }
    } else if (arguments.length === 2) {
      const yhi = arguments[0];
      const ylo = arguments[1];
      let H = null;
      let h = null;
      let T = null;
      let t = null;
      let S = null;
      let s = null;
      let e = null;
      let f = null;
      S = this._hi + yhi;
      T = this._lo + ylo;
      e = S - this._hi;
      f = T - this._lo;
      s = S - e;
      t = T - f;
      s = yhi - e + (this._hi - s);
      t = ylo - f + (this._lo - t);
      e = s + T;
      H = S + e;
      h = e + (S - H);
      e = t + h;
      var zhi = H + e;
      var zlo = e + (H - zhi);
      this._hi = zhi;
      this._lo = zlo;
      return this
    }
  }
  selfMultiply () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DD) {
        let y = arguments[0];
        return this.selfMultiply(y._hi, y._lo)
      } else if (typeof arguments[0] === 'number') {
        let y = arguments[0];
        return this.selfMultiply(y, 0.0)
      }
    } else if (arguments.length === 2) {
      const yhi = arguments[0];
      const ylo = arguments[1];
      let hx = null;
      let tx = null;
      let hy = null;
      let ty = null;
      let C = null;
      let c = null;
      C = DD.SPLIT * this._hi;
      hx = C - this._hi;
      c = DD.SPLIT * yhi;
      hx = C - hx;
      tx = this._hi - hx;
      hy = c - yhi;
      C = this._hi * yhi;
      hy = c - hy;
      ty = yhi - hy;
      c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
      var zhi = C + c;
      hx = C - zhi;
      var zlo = c + hx;
      this._hi = zhi;
      this._lo = zlo;
      return this
    }
  }
  selfSqr () {
    return this.selfMultiply(this)
  }
  floor () {
    if (this.isNaN()) return DD.NaN
    var fhi = Math.floor(this._hi);
    var flo = 0.0;
    if (fhi === this._hi) {
      flo = Math.floor(this._lo);
    }
    return new DD(fhi, flo)
  }
  negate () {
    if (this.isNaN()) return this
    return new DD(-this._hi, -this._lo)
  }
  clone () {
    // try {
    //   return null
    // } catch (ex) {
    //   if (ex instanceof CloneNotSupportedException) {
    //     return null
    //   } else throw ex
    // } finally {}
  }
  multiply () {
    if (arguments[0] instanceof DD) {
      let y = arguments[0];
      if (y.isNaN()) return DD.createNaN()
      return DD.copy(this).selfMultiply(y)
    } else if (typeof arguments[0] === 'number') {
      let y = arguments[0];
      if (Double.isNaN(y)) return DD.createNaN()
      return DD.copy(this).selfMultiply(y, 0.0)
    }
  }
  isNaN () {
    return Double.isNaN(this._hi)
  }
  intValue () {
    return Math.trunc(this._hi)
  }
  toString () {
    var mag = DD.magnitude(this._hi);
    if (mag >= -3 && mag <= 20) return this.toStandardNotation()
    return this.toSciNotation()
  }
  toStandardNotation () {
    var specialStr = this.getSpecialNumberString();
    if (specialStr !== null) return specialStr
    var magnitude = new Array(1).fill(null);
    var sigDigits = this.extractSignificantDigits(true, magnitude);
    var decimalPointPos = magnitude[0] + 1;
    var num = sigDigits;
    if (sigDigits.charAt(0) === '.') {
      num = '0' + sigDigits;
    } else if (decimalPointPos < 0) {
      num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
    } else if (sigDigits.indexOf('.') === -1) {
      var numZeroes = decimalPointPos - sigDigits.length;
      var zeroes = DD.stringOfChar('0', numZeroes);
      num = sigDigits + zeroes + '.0';
    }
    if (this.isNegative()) return '-' + num
    return num
  }
  reciprocal () {
    let hc = null;
    let tc = null;
    let hy = null;
    let ty = null;
    let C = null;
    let c = null;
    let U = null;
    let u = null;
    C = 1.0 / this._hi;
    c = DD.SPLIT * C;
    hc = c - C;
    u = DD.SPLIT * this._hi;
    hc = c - hc;
    tc = C - hc;
    hy = u - this._hi;
    U = C * this._hi;
    hy = u - hy;
    ty = this._hi - hy;
    u = hc * hy - U + hc * ty + tc * hy + tc * ty;
    c = (1.0 - U - u - C * this._lo) / this._hi;
    var zhi = C + c;
    var zlo = C - zhi + c;
    return new DD(zhi, zlo)
  }
  toSciNotation () {
    if (this.isZero()) return DD.SCI_NOT_ZERO
    var specialStr = this.getSpecialNumberString();
    if (specialStr !== null) return specialStr
    var magnitude = new Array(1).fill(null);
    var digits = this.extractSignificantDigits(false, magnitude);
    var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
    if (digits.charAt(0) === '0') {
      throw new Error('Found leading zero: ' + digits)
    }
    var trailingDigits = '';
    if (digits.length > 1) trailingDigits = digits.substring(1);
    var digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;
    if (this.isNegative()) return '-' + digitsWithDecimal + expStr
    return digitsWithDecimal + expStr
  }
  abs () {
    if (this.isNaN()) return DD.NaN
    if (this.isNegative()) return this.negate()
    return new DD(this)
  }
  isPositive () {
    return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0
  }
  lt (y) {
    return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo
  }
  add () {
    if (arguments[0] instanceof DD) {
      let y = arguments[0];
      return DD.copy(this).selfAdd(y)
    } else if (typeof arguments[0] === 'number') {
      let y = arguments[0];
      return DD.copy(this).selfAdd(y)
    }
  }
  init () {
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        let x = arguments[0];
        this._hi = x;
        this._lo = 0.0;
      } else if (arguments[0] instanceof DD) {
        let dd = arguments[0];
        this._hi = dd._hi;
        this._lo = dd._lo;
      }
    } else if (arguments.length === 2) {
      const hi = arguments[0];
      const lo = arguments[1];
      this._hi = hi;
      this._lo = lo;
    }
  }
  gt (y) {
    return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo
  }
  isNegative () {
    return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0
  }
  trunc () {
    if (this.isNaN()) return DD.NaN
    if (this.isPositive()) return this.floor(); else return this.ceil()
  }
  signum () {
    if (this._hi > 0) return 1
    if (this._hi < 0) return -1
    if (this._lo > 0) return 1
    if (this._lo < 0) return -1
    return 0
  }
  interfaces_ () {
    return [Serializable, Comparable, Clonable]
  }
  getClass () {
    return DD
  }
  static sqr (x) {
    return DD.valueOf(x).selfMultiply(x)
  }
  static valueOf () {
    if (typeof arguments[0] === 'string') {
      let str = arguments[0];
      return DD.parse(str)
    } else if (typeof arguments[0] === 'number') {
      let x = arguments[0];
      return new DD(x)
    }
  }
  static sqrt (x) {
    return DD.valueOf(x).sqrt()
  }
  static parse (str) {
    var i = 0;
    var strlen = str.length;
    while (Character.isWhitespace(str.charAt(i))) i++;
    var isNegative = false;
    if (i < strlen) {
      var signCh = str.charAt(i);
      if (signCh === '-' || signCh === '+') {
        i++;
        if (signCh === '-') isNegative = true;
      }
    }
    var val = new DD();
    var numDigits = 0;
    var numBeforeDec = 0;
    var exp = 0;
    while (true) {
      if (i >= strlen) break
      var ch = str.charAt(i);
      i++;
      if (Character.isDigit(ch)) {
        var d = ch - '0';
        val.selfMultiply(DD.TEN);
        val.selfAdd(d);
        numDigits++;
        continue
      }
      if (ch === '.') {
        numBeforeDec = numDigits;
        continue
      }
      if (ch === 'e' || ch === 'E') {
        var expStr = str.substring(i);
        try {
          exp = Integer.parseInt(expStr);
        } catch (ex) {
          if (ex instanceof Error) {
            throw new Error('Invalid exponent ' + expStr + ' in string ' + str)
          } else throw ex
        } finally {}
        break
      }
      throw new Error("Unexpected character '" + ch + "' at position " + i + ' in string ' + str)
    }
    let val2 = val;
    const numDecPlaces = numDigits - numBeforeDec - exp;
    if (numDecPlaces === 0) {
      val2 = val;
    } else if (numDecPlaces > 0) {
      const scale = DD.TEN.pow(numDecPlaces);
      val2 = val.divide(scale);
    } else if (numDecPlaces < 0) {
      const scale = DD.TEN.pow(-numDecPlaces);
      val2 = val.multiply(scale);
    }
    if (isNegative) {
      return val2.negate()
    }
    return val2
  }
  static createNaN () {
    return new DD(Double.NaN, Double.NaN)
  }
  static copy (dd) {
    return new DD(dd)
  }
  static magnitude (x) {
    var xAbs = Math.abs(x);
    var xLog10 = Math.log(xAbs) / Math.log(10);
    var xMag = Math.trunc(Math.floor(xLog10));
    var xApprox = Math.pow(10, xMag);
    if (xApprox * 10 <= xAbs) xMag += 1;
    return xMag
  }
  static stringOfChar (ch, len) {
    var buf = new StringBuffer();
    for (var i = 0; i < len; i++) {
      buf.append(ch);
    }
    return buf.toString()
  }
  static get PI () { return new DD(3.141592653589793116e+00, 1.224646799147353207e-16) }
  static get TWO_PI () { return new DD(6.283185307179586232e+00, 2.449293598294706414e-16) }
  static get PI_2 () { return new DD(1.570796326794896558e+00, 6.123233995736766036e-17) }
  static get E () { return new DD(2.718281828459045091e+00, 1.445646891729250158e-16) }
  static get NaN () { return new DD(Double.NaN, Double.NaN) }
  static get EPS () { return 1.23259516440783e-32 }
  static get SPLIT () { return 134217729.0 }
  static get MAX_PRINT_DIGITS () { return 32 }
  static get TEN () { return DD.valueOf(10.0) }
  static get ONE () { return DD.valueOf(1.0) }
  static get SCI_NOT_EXPONENT_CHAR () { return 'E' }
  static get SCI_NOT_ZERO () { return '0.0E0' }
}

class CGAlgorithmsDD {
  interfaces_ () {
    return []
  }
  getClass () {
    return CGAlgorithmsDD
  }
  static orientationIndex (p1, p2, q) {
    const index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
    if (index <= 1) return index
    const dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
    const dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
    const dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
    const dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
    return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()
  }
  static signOfDet2x2 (x1, y1, x2, y2) {
    const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
    return det.signum()
  }
  static intersection (p1, p2, q1, q2) {
    const denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
    const denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
    const denom = denom1.subtract(denom2);
    const numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
    const numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
    const numx = numx1.subtract(numx2);
    const fracP = numx.selfDivide(denom).doubleValue();
    const x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
    const numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
    const numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
    const numy = numy1.subtract(numy2);
    const fracQ = numy.selfDivide(denom).doubleValue();
    const y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
    return new Coordinate(x, y)
  }
  static orientationIndexFilter (pa, pb, pc) {
    let detsum = null;
    const detleft = (pa.x - pc.x) * (pb.y - pc.y);
    const detright = (pa.y - pc.y) * (pb.x - pc.x);
    const det = detleft - detright;
    if (detleft > 0.0) {
      if (detright <= 0.0) {
        return CGAlgorithmsDD.signum(det)
      } else {
        detsum = detleft + detright;
      }
    } else if (detleft < 0.0) {
      if (detright >= 0.0) {
        return CGAlgorithmsDD.signum(det)
      } else {
        detsum = -detleft - detright;
      }
    } else {
      return CGAlgorithmsDD.signum(det)
    }
    const errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
    if (det >= errbound || -det >= errbound) {
      return CGAlgorithmsDD.signum(det)
    }
    return 2
  }
  static signum (x) {
    if (x > 0) return 1
    if (x < 0) return -1
    return 0
  }
  static get DP_SAFE_EPSILON () { return 1e-15 };
}

class CoordinateSequence {
  static get X () { return 0 }
  static get Y () { return 1 }
  static get Z () { return 2 }
  static get M () { return 3 }
  setOrdinate (index, ordinateIndex, value) {}
  size () {}
  getOrdinate (index, ordinateIndex) {}
  getCoordinate () {}
  getCoordinateCopy (i) {}
  getDimension () {}
  getX (index) {}
  clone () {}
  expandEnvelope (env) {}
  copy () {}
  getY (index) {}
  toCoordinateArray () {}
  interfaces_ () {
    return [Clonable]
  }
  getClass () {
    return CoordinateSequence
  }
}

class Exception {}

class NotRepresentableException extends Exception {
  constructor () {
    super('Projective point not representable on the Cartesian plane.');
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return NotRepresentableException
  }
}

class System {
  static arraycopy (src, srcPos, dest, destPos, len) {
    let c = 0;
    for (let i = srcPos; i < srcPos + len; i++) {
      dest[destPos + c] = src[i];
      c++;
    }
  }

  static getProperty (name) {
    return {
      'line.separator': '\n'
    }[name]
  }
}

class HCoordinate {
  constructor () {
    this.x = null;
    this.y = null;
    this.w = null;
    if (arguments.length === 0) {
      this.x = 0.0;
      this.y = 0.0;
      this.w = 1.0;
    } else if (arguments.length === 1) {
      const p = arguments[0];
      this.x = p.x;
      this.y = p.y;
      this.w = 1.0;
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
        const _x = arguments[0];
        const _y = arguments[1];
        this.x = _x;
        this.y = _y;
        this.w = 1.0;
      } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
        const p1 = arguments[0];
        const p2 = arguments[1];
        this.x = p1.y * p2.w - p2.y * p1.w;
        this.y = p2.x * p1.w - p1.x * p2.w;
        this.w = p1.x * p2.y - p2.x * p1.y;
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
        const p1 = arguments[0];
        const p2 = arguments[1];
        this.x = p1.y - p2.y;
        this.y = p2.x - p1.x;
        this.w = p1.x * p2.y - p2.x * p1.y;
      }
    } else if (arguments.length === 3) {
      const _x = arguments[0];
      const _y = arguments[1];
      const _w = arguments[2];
      this.x = _x;
      this.y = _y;
      this.w = _w;
    } else if (arguments.length === 4) {
      const p1 = arguments[0];
      const p2 = arguments[1];
      const q1 = arguments[2];
      const q2 = arguments[3];
      const px = p1.y - p2.y;
      const py = p2.x - p1.x;
      const pw = p1.x * p2.y - p2.x * p1.y;
      const qx = q1.y - q2.y;
      const qy = q2.x - q1.x;
      const qw = q1.x * q2.y - q2.x * q1.y;
      this.x = py * qw - qy * pw;
      this.y = qx * pw - px * qw;
      this.w = px * qy - qx * py;
    }
  }
  getY () {
    const a = this.y / this.w;
    if (Double.isNaN(a) || Double.isInfinite(a)) {
      throw new NotRepresentableException()
    }
    return a
  }
  getX () {
    const a = this.x / this.w;
    if (Double.isNaN(a) || Double.isInfinite(a)) {
      throw new NotRepresentableException()
    }
    return a
  }
  getCoordinate () {
    const p = new Coordinate();
    p.x = this.getX();
    p.y = this.getY();
    return p
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return HCoordinate
  }
  static intersection (p1, p2, q1, q2) {
    const px = p1.y - p2.y;
    const py = p2.x - p1.x;
    const pw = p1.x * p2.y - p2.x * p1.y;
    const qx = q1.y - q2.y;
    const qy = q2.x - q1.x;
    const qw = q1.x * q2.y - q2.x * q1.y;
    const x = py * qw - qy * pw;
    const y = qx * pw - px * qw;
    const w = px * qy - qx * py;
    const xInt = x / w;
    const yInt = y / w;
    if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {
      throw new NotRepresentableException()
    }
    return new Coordinate(xInt, yInt)
  }
}

class Envelope {
  constructor () {
    this._minx = null;
    this._maxx = null;
    this._miny = null;
    this._maxy = null;
    if (arguments.length === 0) {
      this.init();
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        let p = arguments[0];
        this.init(p.x, p.x, p.y, p.y);
      } else if (arguments[0] instanceof Envelope) {
        let env = arguments[0];
        this.init(env);
      }
    } else if (arguments.length === 2) {
      const p1 = arguments[0];
      const p2 = arguments[1];
      this.init(p1.x, p2.x, p1.y, p2.y);
    } else if (arguments.length === 4) {
      const x1 = arguments[0];
      const x2 = arguments[1];
      const y1 = arguments[2];
      const y2 = arguments[3];
      this.init(x1, x2, y1, y2);
    }
  }
  getArea () {
    return this.getWidth() * this.getHeight()
  }
  equals (other) {
    if (!(other instanceof Envelope)) {
      return false
    }
    var otherEnvelope = other;
    if (this.isNull()) {
      return otherEnvelope.isNull()
    }
    return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()
  }
  intersection (env) {
    if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope()
    var intMinX = this._minx > env._minx ? this._minx : env._minx;
    var intMinY = this._miny > env._miny ? this._miny : env._miny;
    var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
    var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
    return new Envelope(intMinX, intMaxX, intMinY, intMaxY)
  }
  isNull () {
    return this._maxx < this._minx
  }
  getMaxX () {
    return this._maxx
  }
  covers () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        let p = arguments[0];
        return this.covers(p.x, p.y)
      } else if (arguments[0] instanceof Envelope) {
        let other = arguments[0];
        if (this.isNull() || other.isNull()) {
          return false
        }
        return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy
      }
    } else if (arguments.length === 2) {
      const x = arguments[0];
      const y = arguments[1];
      if (this.isNull()) return false
      return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy
    }
  }
  intersects () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Envelope) {
        const other = arguments[0];
        if (this.isNull() || other.isNull()) {
          return false
        }
        return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)
      } else if (arguments[0] instanceof Coordinate) {
        const p = arguments[0];
        return this.intersects(p.x, p.y)
      }
    } else if (arguments.length === 2) {
      const x = arguments[0];
      const y = arguments[1];
      if (this.isNull()) return false
      return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)
    }
  }
  getMinY () {
    return this._miny
  }
  getMinX () {
    return this._minx
  }
  expandToInclude () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        let p = arguments[0];
        this.expandToInclude(p.x, p.y);
      } else if (arguments[0] instanceof Envelope) {
        let other = arguments[0];
        if (other.isNull()) {
          return null
        }
        if (this.isNull()) {
          this._minx = other.getMinX();
          this._maxx = other.getMaxX();
          this._miny = other.getMinY();
          this._maxy = other.getMaxY();
        } else {
          if (other._minx < this._minx) {
            this._minx = other._minx;
          }
          if (other._maxx > this._maxx) {
            this._maxx = other._maxx;
          }
          if (other._miny < this._miny) {
            this._miny = other._miny;
          }
          if (other._maxy > this._maxy) {
            this._maxy = other._maxy;
          }
        }
      }
    } else if (arguments.length === 2) {
      const x = arguments[0];
      const y = arguments[1];
      if (this.isNull()) {
        this._minx = x;
        this._maxx = x;
        this._miny = y;
        this._maxy = y;
      } else {
        if (x < this._minx) {
          this._minx = x;
        }
        if (x > this._maxx) {
          this._maxx = x;
        }
        if (y < this._miny) {
          this._miny = y;
        }
        if (y > this._maxy) {
          this._maxy = y;
        }
      }
    }
  }
  minExtent () {
    if (this.isNull()) return 0.0
    var w = this.getWidth();
    var h = this.getHeight();
    if (w < h) return w
    return h
  }
  getWidth () {
    if (this.isNull()) {
      return 0
    }
    return this._maxx - this._minx
  }
  compareTo (o) {
    var env = o;
    if (this.isNull()) {
      if (env.isNull()) return 0
      return -1
    } else {
      if (env.isNull()) return 1
    }
    if (this._minx < env._minx) return -1
    if (this._minx > env._minx) return 1
    if (this._miny < env._miny) return -1
    if (this._miny > env._miny) return 1
    if (this._maxx < env._maxx) return -1
    if (this._maxx > env._maxx) return 1
    if (this._maxy < env._maxy) return -1
    if (this._maxy > env._maxy) return 1
    return 0
  }
  translate (transX, transY) {
    if (this.isNull()) {
      return null
    }
    this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
  }
  toString () {
    return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'
  }
  setToNull () {
    this._minx = 0;
    this._maxx = -1;
    this._miny = 0;
    this._maxy = -1;
  }
  getHeight () {
    if (this.isNull()) {
      return 0
    }
    return this._maxy - this._miny
  }
  maxExtent () {
    if (this.isNull()) return 0.0
    const w = this.getWidth();
    const h = this.getHeight();
    if (w > h) return w
    return h
  }
  expandBy () {
    if (arguments.length === 1) {
      const distance = arguments[0];
      this.expandBy(distance, distance);
    } else if (arguments.length === 2) {
      const deltaX = arguments[0];
      const deltaY = arguments[1];
      if (this.isNull()) return null
      this._minx -= deltaX;
      this._maxx += deltaX;
      this._miny -= deltaY;
      this._maxy += deltaY;
      if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();
    }
  }
  contains () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Envelope) {
        const other = arguments[0];
        return this.covers(other)
      } else if (arguments[0] instanceof Coordinate) {
        const p = arguments[0];
        return this.covers(p)
      }
    } else if (arguments.length === 2) {
      const x = arguments[0];
      const y = arguments[1];
      return this.covers(x, y)
    }
  }
  centre () {
    if (this.isNull()) return null
    return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)
  }
  init () {
    if (arguments.length === 0) {
      this.setToNull();
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        let p = arguments[0];
        this.init(p.x, p.x, p.y, p.y);
      } else if (arguments[0] instanceof Envelope) {
        let env = arguments[0];
        this._minx = env._minx;
        this._maxx = env._maxx;
        this._miny = env._miny;
        this._maxy = env._maxy;
      }
    } else if (arguments.length === 2) {
      const p1 = arguments[0];
      const p2 = arguments[1];
      this.init(p1.x, p2.x, p1.y, p2.y);
    } else if (arguments.length === 4) {
      const x1 = arguments[0];
      const x2 = arguments[1];
      const y1 = arguments[2];
      const y2 = arguments[3];
      if (x1 < x2) {
        this._minx = x1;
        this._maxx = x2;
      } else {
        this._minx = x2;
        this._maxx = x1;
      }
      if (y1 < y2) {
        this._miny = y1;
        this._maxy = y2;
      } else {
        this._miny = y2;
        this._maxy = y1;
      }
    }
  }
  getMaxY () {
    return this._maxy
  }
  distance (env) {
    if (this.intersects(env)) return 0
    var dx = 0.0;
    if (this._maxx < env._minx) dx = env._minx - this._maxx; else if (this._minx > env._maxx) dx = this._minx - env._maxx;
    var dy = 0.0;
    if (this._maxy < env._miny) dy = env._miny - this._maxy; else if (this._miny > env._maxy) dy = this._miny - env._maxy;
    if (dx === 0.0) return dy
    if (dy === 0.0) return dx
    return Math.sqrt(dx * dx + dy * dy)
  }
  hashCode () {
    var result = 17;
    result = 37 * result + Coordinate.hashCode(this._minx);
    result = 37 * result + Coordinate.hashCode(this._maxx);
    result = 37 * result + Coordinate.hashCode(this._miny);
    result = 37 * result + Coordinate.hashCode(this._maxy);
    return result
  }
  interfaces_ () {
    return [Comparable, Serializable]
  }
  getClass () {
    return Envelope
  }
  static intersects () {
    if (arguments.length === 3) {
      const p1 = arguments[0];
      const p2 = arguments[1];
      const q = arguments[2];
      if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {
        return true
      }
      return false
    } else if (arguments.length === 4) {
      const p1 = arguments[0];
      const p2 = arguments[1];
      const q1 = arguments[2];
      const q2 = arguments[3];
      let minq = Math.min(q1.x, q2.x);
      let maxq = Math.max(q1.x, q2.x);
      let minp = Math.min(p1.x, p2.x);
      let maxp = Math.max(p1.x, p2.x);
      if (minp > maxq) return false
      if (maxp < minq) return false
      minq = Math.min(q1.y, q2.y);
      maxq = Math.max(q1.y, q2.y);
      minp = Math.min(p1.y, p2.y);
      maxp = Math.max(p1.y, p2.y);
      if (minp > maxq) return false
      if (maxp < minq) return false
      return true
    }
  }
  static get serialVersionUID () { return 5873921885273102420 }
}

const regExes = {
  'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  'emptyTypeStr': /^\s*(\w+)\s*EMPTY\s*$/,
  'spaces': /\s+/,
  'parenComma': /\)\s*,\s*\(/,
  'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
  'trimParens': /^\s*\(?(.*?)\)?\s*$/
};

/**
 * Class for reading and writing Well-Known Text.
 *
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/** Create a new parser for WKT
 *
 * @param {GeometryFactory} geometryFactory
 * @return An instance of WKTParser.
 * @constructor
 * @private
 */
class WKTParser {
  constructor (geometryFactory) {
    this.geometryFactory = geometryFactory || new GeometryFactory();
  }
  /**
   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
   * and GEOMETRYCOLLECTION.
   *
   * @param {String} wkt A WKT string.
   * @return {Geometry} A geometry instance.
   * @private
   */
  read (wkt) {
    var geometry, type, str;
    wkt = wkt.replace(/[\n\r]/g, ' ');
    var matches = regExes.typeStr.exec(wkt);
    if (wkt.search('EMPTY') !== -1) {
      matches = regExes.emptyTypeStr.exec(wkt);
      matches[2] = undefined;
    }
    if (matches) {
      type = matches[1].toLowerCase();
      str = matches[2];
      if (parse$1[type]) {
        geometry = parse$1[type].apply(this, [str]);
      }
    }

    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)

    return geometry
  }

  /**
   * Serialize a geometry into a WKT string.
   *
   * @param {Geometry} geometry A feature or array of features.
   * @return {String} The WKT string representation of the input geometries.
   * @private
   */
  write (geometry) {
    return this.extractGeometry(geometry)
  }

  /**
   * Entry point to construct the WKT for a single Geometry object.
   *
   * @param {Geometry} geometry
   * @return {String} A WKT string of representing the geometry.
   * @private
   */
  extractGeometry (geometry) {
    var type = geometry.getGeometryType().toLowerCase();
    if (!extract$1[type]) {
      return null
    }
    var wktType = type.toUpperCase();
    var data;
    if (geometry.isEmpty()) {
      data = wktType + ' EMPTY';
    } else {
      data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';
    }
    return data
  }
}

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual data extraction.
 * @private
 */
const extract$1 = {
  coordinate (coordinate) {
    return coordinate.x + ' ' + coordinate.y
  },

  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point (point) {
    return extract$1.coordinate.call(this, point._coordinates._coordinates[0])
  },

  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint (multipoint) {
    var array = [];
    for (let i = 0, len = multipoint._geometries.length; i < len; ++i) {
      array.push('(' + extract$1.point.apply(this, [multipoint._geometries[i]]) + ')');
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring (linestring) {
    var array = [];
    for (let i = 0, len = linestring._points._coordinates.length; i < len; ++i) {
      array.push(extract$1.coordinate.apply(this, [linestring._points._coordinates[i]]));
    }
    return array.join(',')
  },

  linearring (linearring) {
    var array = [];
    for (let i = 0, len = linearring._points._coordinates.length; i < len; ++i) {
      array.push(extract$1.coordinate.apply(this, [linearring._points._coordinates[i]]));
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring (multilinestring) {
    var array = [];
    for (let i = 0, len = multilinestring._geometries.length; i < len; ++i) {
      array.push('(' +
        extract$1.linestring.apply(this, [multilinestring._geometries[i]]) +
        ')');
    }
    return array.join(',')
  },

  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon (polygon) {
    var array = [];
    array.push('(' + extract$1.linestring.apply(this, [polygon._shell]) + ')');
    for (let i = 0, len = polygon._holes.length; i < len; ++i) {
      array.push('(' + extract$1.linestring.apply(this, [polygon._holes[i]]) + ')');
    }
    return array.join(',')
  },

  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon (multipolygon) {
    var array = [];
    for (let i = 0, len = multipolygon._geometries.length; i < len; ++i) {
      array.push('(' + extract$1.polygon.apply(this, [multipolygon._geometries[i]]) + ')');
    }
    return array.join(',')
  },

  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection (collection) {
    var array = [];
    for (let i = 0, len = collection._geometries.length; i < len; ++i) {
      array.push(this.extractGeometry(collection._geometries[i]));
    }
    return array.join(',')
  }
};

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual parsing.
 * @private
 */
const parse$1 = {
  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point (str) {
    if (str === undefined) {
      return this.geometryFactory.createPoint()
    }

    var coords = str.trim().split(regExes.spaces);
    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]),
      Number.parseFloat(coords[1])))
  },

  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPoint()
    }

    var point;
    var points = str.trim().split(',');
    var components = [];
    for (let i = 0, len = points.length; i < len; ++i) {
      point = points[i].replace(regExes.trimParens, '$1');
      components.push(parse$1.point.apply(this, [point]));
    }
    return this.geometryFactory.createMultiPoint(components)
  },

  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring (str) {
    if (str === undefined) {
      return this.geometryFactory.createLineString()
    }

    var points = str.trim().split(',');
    var components = [];
    var coords;
    for (let i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLineString(components)
  },

  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring (str) {
    if (str === undefined) {
      return this.geometryFactory.createLinearRing()
    }

    var points = str.trim().split(',');
    var components = [];
    var coords;
    for (let i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLinearRing(components)
  },

  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiLineString()
    }

    var line;
    var lines = str.trim().split(regExes.parenComma);
    var components = [];
    for (let i = 0, len = lines.length; i < len; ++i) {
      line = lines[i].replace(regExes.trimParens, '$1');
      components.push(parse$1.linestring.apply(this, [line]));
    }
    return this.geometryFactory.createMultiLineString(components)
  },

  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon (str) {
    if (str === undefined) {
      return this.geometryFactory.createPolygon()
    }

    var ring, linestring, linearring;
    var rings = str.trim().split(regExes.parenComma);
    var shell;
    var holes = [];
    for (let i = 0, len = rings.length; i < len; ++i) {
      ring = rings[i].replace(regExes.trimParens, '$1');
      linestring = parse$1.linestring.apply(this, [ring]);
      linearring = this.geometryFactory.createLinearRing(linestring._points);
      if (i === 0) {
        shell = linearring;
      } else {
        holes.push(linearring);
      }
    }
    return this.geometryFactory.createPolygon(shell, holes)
  },

  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon (str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPolygon()
    }

    var polygon;
    var polygons = str.trim().split(regExes.doubleParenComma);
    var components = [];
    for (let i = 0, len = polygons.length; i < len; ++i) {
      polygon = polygons[i].replace(regExes.trimParens, '$1');
      components.push(parse$1.polygon.apply(this, [polygon]));
    }
    return this.geometryFactory.createMultiPolygon(components)
  },

  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection (str) {
    if (str === undefined) {
      return this.geometryFactory.createGeometryCollection()
    }

    // separate components of the collection with |
    str = str.replace(/,\s*([A-Za-z])/g, '|$1');
    var wktArray = str.trim().split('|');
    var components = [];
    for (let i = 0, len = wktArray.length; i < len; ++i) {
      components.push(this.read(wktArray[i]));
    }
    return this.geometryFactory.createGeometryCollection(components)
  }
};

/**
 * Writes the Well-Known Text representation of a {@link Geometry}. The
 * Well-Known Text format is defined in the <A
 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
 * Specification for SQL</A>.
 * <p>
 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 * <p>
 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
 * Under the spec, rings are output as <code>LINESTRING</code>s.
 */

/**
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
class WKTWriter {
  constructor (geometryFactory) {
    this.parser = new WKTParser(geometryFactory);
  }

  /**
   * Converts a <code>Geometry</code> to its Well-known Text representation.
   *
   * @param {Geometry} geometry a <code>Geometry</code> to process.
   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
   *         Features Specification).
   * @memberof WKTWriter
   */
  write (geometry) {
    return this.parser.write(geometry)
  }
  /**
   * Generates the WKT for a <tt>LINESTRING</tt> specified by two
   * {@link Coordinate}s.
   *
   * @param p0 the first coordinate.
   * @param p1 the second coordinate.
   *
   * @return the WKT.
   * @private
   */
  static toLineString (p0, p1) {
    if (arguments.length !== 2) {
      throw new Error('Not implemented')
    }
    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'
  }
}

class RuntimeException extends Error {
  constructor (message) {
    super(message);
    this.name = 'RuntimeException';
    this.message = message;
    this.stack = (new Error()).stack;
  }
}

class AssertionFailedException extends RuntimeException {
  constructor () {
    super();
    if (arguments.length === 0) {
      RuntimeException.call(this);
    } else if (arguments.length === 1) {
      let message = arguments[0];
      RuntimeException.call(this, message);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return AssertionFailedException
  }
}

class Assert {
  interfaces_ () {
    return []
  }
  getClass () {
    return Assert
  }
  static shouldNeverReachHere () {
    if (arguments.length === 0) {
      Assert.shouldNeverReachHere(null);
    } else if (arguments.length === 1) {
      let message = arguments[0];
      throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))
    }
  }
  static isTrue () {
    let assertion;
    let message;
    if (arguments.length === 1) {
      assertion = arguments[0];
      Assert.isTrue(assertion, null);
    } else if (arguments.length === 2) {
      assertion = arguments[0];
      message = arguments[1];
      if (!assertion) {
        if (message === null) {
          throw new AssertionFailedException()
        } else {
          throw new AssertionFailedException(message)
        }
      }
    }
  }
  static equals () {
    let expectedValue;
    let actualValue;
    let message;
    if (arguments.length === 2) {
      expectedValue = arguments[0];
      actualValue = arguments[1];
      Assert.equals(expectedValue, actualValue, null);
    } else if (arguments.length === 3) {
      expectedValue = arguments[0];
      actualValue = arguments[1];
      message = arguments[2];
      if (!actualValue.equals(expectedValue)) {
        throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))
      }
    }
  }
}

class LineIntersector {
  constructor () {
    this._result = null;
    this._inputLines = Array(2).fill().map(() => Array(2));
    this._intPt = new Array(2).fill(null);
    this._intLineIndex = null;
    this._isProper = null;
    this._pa = null;
    this._pb = null;
    this._precisionModel = null;
    this._intPt[0] = new Coordinate();
    this._intPt[1] = new Coordinate();
    this._pa = this._intPt[0];
    this._pb = this._intPt[1];
    this._result = 0;
  }
  getIndexAlongSegment (segmentIndex, intIndex) {
    this.computeIntLineIndex();
    return this._intLineIndex[segmentIndex][intIndex]
  }
  getTopologySummary () {
    var catBuf = new StringBuffer();
    if (this.isEndPoint()) catBuf.append(' endpoint');
    if (this._isProper) catBuf.append(' proper');
    if (this.isCollinear()) catBuf.append(' collinear');
    return catBuf.toString()
  }
  computeIntersection (p1, p2, p3, p4) {
    this._inputLines[0][0] = p1;
    this._inputLines[0][1] = p2;
    this._inputLines[1][0] = p3;
    this._inputLines[1][1] = p4;
    this._result = this.computeIntersect(p1, p2, p3, p4);
  }
  getIntersectionNum () {
    return this._result
  }
  computeIntLineIndex () {
    if (arguments.length === 0) {
      if (this._intLineIndex === null) {
        this._intLineIndex = Array(2).fill().map(() => Array(2));
        this.computeIntLineIndex(0);
        this.computeIntLineIndex(1);
      }
    } else if (arguments.length === 1) {
      let segmentIndex = arguments[0];
      var dist0 = this.getEdgeDistance(segmentIndex, 0);
      var dist1 = this.getEdgeDistance(segmentIndex, 1);
      if (dist0 > dist1) {
        this._intLineIndex[segmentIndex][0] = 0;
        this._intLineIndex[segmentIndex][1] = 1;
      } else {
        this._intLineIndex[segmentIndex][0] = 1;
        this._intLineIndex[segmentIndex][1] = 0;
      }
    }
  }
  isProper () {
    return this.hasIntersection() && this._isProper
  }
  setPrecisionModel (precisionModel) {
    this._precisionModel = precisionModel;
  }
  isInteriorIntersection () {
    if (arguments.length === 0) {
      if (this.isInteriorIntersection(0)) return true
      if (this.isInteriorIntersection(1)) return true
      return false
    } else if (arguments.length === 1) {
      let inputLineIndex = arguments[0];
      for (var i = 0; i < this._result; i++) {
        if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {
          return true
        }
      }
      return false
    }
  }
  getIntersection (intIndex) {
    return this._intPt[intIndex]
  }
  isEndPoint () {
    return this.hasIntersection() && !this._isProper
  }
  hasIntersection () {
    return this._result !== LineIntersector.NO_INTERSECTION
  }
  getEdgeDistance (segmentIndex, intIndex) {
    var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
    return dist
  }
  isCollinear () {
    return this._result === LineIntersector.COLLINEAR_INTERSECTION
  }
  toString () {
    return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
  }
  getEndpoint (segmentIndex, ptIndex) {
    return this._inputLines[segmentIndex][ptIndex]
  }
  isIntersection (pt) {
    for (var i = 0; i < this._result; i++) {
      if (this._intPt[i].equals2D(pt)) {
        return true
      }
    }
    return false
  }
  getIntersectionAlongSegment (segmentIndex, intIndex) {
    this.computeIntLineIndex();
    return this._intPt[this._intLineIndex[segmentIndex][intIndex]]
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return LineIntersector
  }
  static computeEdgeDistance (p, p0, p1) {
    var dx = Math.abs(p1.x - p0.x);
    var dy = Math.abs(p1.y - p0.y);
    var dist = -1.0;
    if (p.equals(p0)) {
      dist = 0.0;
    } else if (p.equals(p1)) {
      if (dx > dy) dist = dx; else dist = dy;
    } else {
      var pdx = Math.abs(p.x - p0.x);
      var pdy = Math.abs(p.y - p0.y);
      if (dx > dy) dist = pdx; else dist = pdy;
      if (dist === 0.0 && !p.equals(p0)) {
        dist = Math.max(pdx, pdy);
      }
    }
    Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');
    return dist
  }
  static nonRobustComputeEdgeDistance (p, p1, p2) {
    var dx = p.x - p1.x;
    var dy = p.y - p1.y;
    var dist = Math.sqrt(dx * dx + dy * dy);
    Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');
    return dist
  }
  static get DONT_INTERSECT () { return 0 }
  static get DO_INTERSECT () { return 1 }
  static get COLLINEAR () { return 2 }
  static get NO_INTERSECTION () { return 0 }
  static get POINT_INTERSECTION () { return 1 }
  static get COLLINEAR_INTERSECTION () { return 2 }
}

class RobustLineIntersector extends LineIntersector {
  isInSegmentEnvelopes (intPt) {
    const env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
    const env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
    return env0.contains(intPt) && env1.contains(intPt)
  }
  computeIntersection () {
    if (arguments.length === 3) {
      const p = arguments[0];
      const p1 = arguments[1];
      const p2 = arguments[2];
      this._isProper = false;
      if (Envelope.intersects(p1, p2, p)) {
        if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {
          this._isProper = true;
          if (p.equals(p1) || p.equals(p2)) {
            this._isProper = false;
          }
          this._result = LineIntersector.POINT_INTERSECTION;
          return null
        }
      }
      this._result = LineIntersector.NO_INTERSECTION;
    } else return LineIntersector.prototype.computeIntersection.apply(this, arguments)
  }
  normalizeToMinimum (n1, n2, n3, n4, normPt) {
    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
    n1.x -= normPt.x;
    n1.y -= normPt.y;
    n2.x -= normPt.x;
    n2.y -= normPt.y;
    n3.x -= normPt.x;
    n3.y -= normPt.y;
    n4.x -= normPt.x;
    n4.y -= normPt.y;
  }
  safeHCoordinateIntersection (p1, p2, q1, q2) {
    let intPt = null;
    try {
      intPt = HCoordinate.intersection(p1, p2, q1, q2);
    } catch (e) {
      if (e instanceof NotRepresentableException) {
        intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
      } else throw e
    } finally {}
    return intPt
  }
  intersection (p1, p2, q1, q2) {
    let intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
    if (!this.isInSegmentEnvelopes(intPt)) {
      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
    }
    if (this._precisionModel !== null) {
      this._precisionModel.makePrecise(intPt);
    }
    return intPt
  }
  smallestInAbsValue (x1, x2, x3, x4) {
    let x = x1;
    let xabs = Math.abs(x);
    if (Math.abs(x2) < xabs) {
      x = x2;
      xabs = Math.abs(x2);
    }
    if (Math.abs(x3) < xabs) {
      x = x3;
      xabs = Math.abs(x3);
    }
    if (Math.abs(x4) < xabs) {
      x = x4;
    }
    return x
  }
  checkDD (p1, p2, q1, q2, intPt) {
    const intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
    const isIn = this.isInSegmentEnvelopes(intPtDD);
    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);
    if (intPt.distance(intPtDD) > 0.0001) {
      System.out.println('Distance = ' + intPt.distance(intPtDD));
    }
  }
  intersectionWithNormalization (p1, p2, q1, q2) {
    const n1 = new Coordinate(p1);
    const n2 = new Coordinate(p2);
    const n3 = new Coordinate(q1);
    const n4 = new Coordinate(q2);
    const normPt = new Coordinate();
    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
    const intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
    intPt.x += normPt.x;
    intPt.y += normPt.y;
    return intPt
  }
  computeCollinearIntersection (p1, p2, q1, q2) {
    const p1q1p2 = Envelope.intersects(p1, p2, q1);
    const p1q2p2 = Envelope.intersects(p1, p2, q2);
    const q1p1q2 = Envelope.intersects(q1, q2, p1);
    const q1p2q2 = Envelope.intersects(q1, q2, p2);
    if (p1q1p2 && p1q2p2) {
      this._intPt[0] = q1;
      this._intPt[1] = q2;
      return LineIntersector.COLLINEAR_INTERSECTION
    }
    if (q1p1q2 && q1p2q2) {
      this._intPt[0] = p1;
      this._intPt[1] = p2;
      return LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q1p2 && q1p1q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p1;
      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q1p2 && q1p2q2) {
      this._intPt[0] = q1;
      this._intPt[1] = p2;
      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q2p2 && q1p1q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p1;
      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    if (p1q2p2 && q1p2q2) {
      this._intPt[0] = q2;
      this._intPt[1] = p2;
      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION
    }
    return LineIntersector.NO_INTERSECTION
  }
  normalizeToEnvCentre (n00, n01, n10, n11, normPt) {
    const minX0 = n00.x < n01.x ? n00.x : n01.x;
    const minY0 = n00.y < n01.y ? n00.y : n01.y;
    const maxX0 = n00.x > n01.x ? n00.x : n01.x;
    const maxY0 = n00.y > n01.y ? n00.y : n01.y;
    const minX1 = n10.x < n11.x ? n10.x : n11.x;
    const minY1 = n10.y < n11.y ? n10.y : n11.y;
    const maxX1 = n10.x > n11.x ? n10.x : n11.x;
    const maxY1 = n10.y > n11.y ? n10.y : n11.y;
    const intMinX = minX0 > minX1 ? minX0 : minX1;
    const intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
    const intMinY = minY0 > minY1 ? minY0 : minY1;
    const intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
    const intMidX = (intMinX + intMaxX) / 2.0;
    const intMidY = (intMinY + intMaxY) / 2.0;
    normPt.x = intMidX;
    normPt.y = intMidY;
    n00.x -= normPt.x;
    n00.y -= normPt.y;
    n01.x -= normPt.x;
    n01.y -= normPt.y;
    n10.x -= normPt.x;
    n10.y -= normPt.y;
    n11.x -= normPt.x;
    n11.y -= normPt.y;
  }
  computeIntersect (p1, p2, q1, q2) {
    this._isProper = false;
    if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION
    const Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
    const Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);
    if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {
      return LineIntersector.NO_INTERSECTION
    }
    const Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
    const Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);
    if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {
      return LineIntersector.NO_INTERSECTION
    }
    const collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
    if (collinear) {
      return this.computeCollinearIntersection(p1, p2, q1, q2)
    }
    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
      this._isProper = false;
      if (p1.equals2D(q1) || p1.equals2D(q2)) {
        this._intPt[0] = p1;
      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
        this._intPt[0] = p2;
      } else if (Pq1 === 0) {
        this._intPt[0] = new Coordinate(q1);
      } else if (Pq2 === 0) {
        this._intPt[0] = new Coordinate(q2);
      } else if (Qp1 === 0) {
        this._intPt[0] = new Coordinate(p1);
      } else if (Qp2 === 0) {
        this._intPt[0] = new Coordinate(p2);
      }
    } else {
      this._isProper = true;
      this._intPt[0] = this.intersection(p1, p2, q1, q2);
    }
    return LineIntersector.POINT_INTERSECTION
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return RobustLineIntersector
  }
  static nearestEndpoint (p1, p2, q1, q2) {
    let nearestPt = p1;
    let minDist = CGAlgorithms.distancePointLine(p1, q1, q2);
    let dist = CGAlgorithms.distancePointLine(p2, q1, q2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = p2;
    }
    dist = CGAlgorithms.distancePointLine(q1, p1, p2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = q1;
    }
    dist = CGAlgorithms.distancePointLine(q2, p1, p2);
    if (dist < minDist) {
      minDist = dist;
      nearestPt = q2;
    }
    return nearestPt
  }
}

class RobustDeterminant {
  interfaces_ () {
    return []
  }
  getClass () {
    return RobustDeterminant
  }
  static orientationIndex (p1, p2, q) {
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dx2 = q.x - p2.x;
    const dy2 = q.y - p2.y;
    return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2)
  }
  static signOfDet2x2 (x1, y1, x2, y2) {
    let sign = null;
    let swap = null;
    let k = null;
    sign = 1;
    if (x1 === 0.0 || y2 === 0.0) {
      if (y1 === 0.0 || x2 === 0.0) {
        return 0
      } else if (y1 > 0) {
        if (x2 > 0) {
          return -sign
        } else {
          return sign
        }
      } else {
        if (x2 > 0) {
          return sign
        } else {
          return -sign
        }
      }
    }
    if (y1 === 0.0 || x2 === 0.0) {
      if (y2 > 0) {
        if (x1 > 0) {
          return sign
        } else {
          return -sign
        }
      } else {
        if (x1 > 0) {
          return -sign
        } else {
          return sign
        }
      }
    }
    if (y1 > 0.0) {
      if (y2 > 0.0) {
        if (y1 <= y2) {
          
        } else {
          sign = -sign;
          swap = x1;
          x1 = x2;
          x2 = swap;
          swap = y1;
          y1 = y2;
          y2 = swap;
        }
      } else {
        if (y1 <= -y2) {
          sign = -sign;
          x2 = -x2;
          y2 = -y2;
        } else {
          swap = x1;
          x1 = -x2;
          x2 = swap;
          swap = y1;
          y1 = -y2;
          y2 = swap;
        }
      }
    } else {
      if (y2 > 0.0) {
        if (-y1 <= y2) {
          sign = -sign;
          x1 = -x1;
          y1 = -y1;
        } else {
          swap = -x1;
          x1 = x2;
          x2 = swap;
          swap = -y1;
          y1 = y2;
          y2 = swap;
        }
      } else {
        if (y1 >= y2) {
          x1 = -x1;
          y1 = -y1;
          x2 = -x2;
          y2 = -y2;
        } else {
          sign = -sign;
          swap = -x1;
          x1 = -x2;
          x2 = swap;
          swap = -y1;
          y1 = -y2;
          y2 = swap;
        }
      }
    }
    if (x1 > 0.0) {
      if (x2 > 0.0) {
        if (x1 <= x2) {
          
        } else {
          return sign
        }
      } else {
        return sign
      }
    } else {
      if (x2 > 0.0) {
        return -sign
      } else {
        if (x1 >= x2) {
          sign = -sign;
          x1 = -x1;
          x2 = -x2;
        } else {
          return -sign
        }
      }
    }
    while (true) {
      k = Math.floor(x2 / x1);
      x2 = x2 - k * x1;
      y2 = y2 - k * y1;
      if (y2 < 0.0) {
        return -sign
      }
      if (y2 > y1) {
        return sign
      }
      if (x1 > x2 + x2) {
        if (y1 < y2 + y2) {
          return sign
        }
      } else {
        if (y1 > y2 + y2) {
          return -sign
        } else {
          x2 = x1 - x2;
          y2 = y1 - y2;
          sign = -sign;
        }
      }
      if (y2 === 0.0) {
        if (x2 === 0.0) {
          return 0
        } else {
          return -sign
        }
      }
      if (x2 === 0.0) {
        return sign
      }
      k = Math.floor(x1 / x2);
      x1 = x1 - k * x2;
      y1 = y1 - k * y2;
      if (y1 < 0.0) {
        return sign
      }
      if (y1 > y2) {
        return -sign
      }
      if (x2 > x1 + x1) {
        if (y2 < y1 + y1) {
          return -sign
        }
      } else {
        if (y2 > y1 + y1) {
          return sign
        } else {
          x1 = x2 - x1;
          y1 = y2 - y1;
          sign = -sign;
        }
      }
      if (y1 === 0.0) {
        if (x1 === 0.0) {
          return 0
        } else {
          return sign
        }
      }
      if (x1 === 0.0) {
        return -sign
      }
    }
  }
}

class RayCrossingCounter {
  constructor () {
    this._p = null;
    this._crossingCount = 0;
    this._isPointOnSegment = false;
    const p = arguments[0];
    this._p = p;
  }
  countSegment (p1, p2) {
    if (p1.x < this._p.x && p2.x < this._p.x) return null
    if (this._p.x === p2.x && this._p.y === p2.y) {
      this._isPointOnSegment = true;
      return null
    }
    if (p1.y === this._p.y && p2.y === this._p.y) {
      let minx = p1.x;
      let maxx = p2.x;
      if (minx > maxx) {
        minx = p2.x;
        maxx = p1.x;
      }
      if (this._p.x >= minx && this._p.x <= maxx) {
        this._isPointOnSegment = true;
      }
      return null
    }
    if ((p1.y > this._p.y && p2.y <= this._p.y) || (p2.y > this._p.y && p1.y <= this._p.y)) {
      const x1 = p1.x - this._p.x;
      const y1 = p1.y - this._p.y;
      const x2 = p2.x - this._p.x;
      const y2 = p2.y - this._p.y;
      let xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);
      if (xIntSign === 0.0) {
        this._isPointOnSegment = true;
        return null
      }
      if (y2 < y1) xIntSign = -xIntSign;
      if (xIntSign > 0.0) {
        this._crossingCount++;
      }
    }
  }
  isPointInPolygon () {
    return this.getLocation() !== Location.EXTERIOR
  }
  getLocation () {
    if (this._isPointOnSegment) return Location.BOUNDARY
    if (this._crossingCount % 2 === 1) {
      return Location.INTERIOR
    }
    return Location.EXTERIOR
  }
  isOnSegment () {
    return this._isPointOnSegment
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return RayCrossingCounter
  }
  static locatePointInRing () {
    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
      const p = arguments[0];
      const ring = arguments[1];
      const counter = new RayCrossingCounter(p);
      const p1 = new Coordinate();
      const p2 = new Coordinate();
      for (let i = 1; i < ring.size(); i++) {
        ring.getCoordinate(i, p1);
        ring.getCoordinate(i - 1, p2);
        counter.countSegment(p1, p2);
        if (counter.isOnSegment()) return counter.getLocation()
      }
      return counter.getLocation()
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
      const p = arguments[0];
      const ring = arguments[1];
      const counter = new RayCrossingCounter(p);
      for (let i = 1; i < ring.length; i++) {
        const p1 = ring[i];
        const p2 = ring[i - 1];
        counter.countSegment(p1, p2);
        if (counter.isOnSegment()) return counter.getLocation()
      }
      return counter.getLocation()
    }
  }
}

class CGAlgorithms {
  interfaces_ () {
    return []
  }
  getClass () {
    return CGAlgorithms
  }
  static orientationIndex (p1, p2, q) {
    return CGAlgorithmsDD.orientationIndex(p1, p2, q)
  }
  static signedArea () {
    if (arguments[0] instanceof Array) {
      let ring = arguments[0];
      if (ring.length < 3) return 0.0
      let sum = 0.0;
      const x0 = ring[0].x;
      for (let i = 1; i < ring.length - 1; i++) {
        const x = ring[i].x - x0;
        const y1 = ring[i + 1].y;
        const y2 = ring[i - 1].y;
        sum += x * (y2 - y1);
      }
      return sum / 2.0
    } else if (hasInterface(arguments[0], CoordinateSequence)) {
      let ring = arguments[0];
      const n = ring.size();
      if (n < 3) return 0.0
      const p0 = new Coordinate();
      const p1 = new Coordinate();
      const p2 = new Coordinate();
      ring.getCoordinate(0, p1);
      ring.getCoordinate(1, p2);
      const x0 = p1.x;
      p2.x -= x0;
      let sum = 0.0;
      for (let i = 1; i < n - 1; i++) {
        p0.y = p1.y;
        p1.x = p2.x;
        p1.y = p2.y;
        ring.getCoordinate(i + 1, p2);
        p2.x -= x0;
        sum += p1.x * (p0.y - p2.y);
      }
      return sum / 2.0
    }
  }
  static distanceLineLine (A, B, C, D) {
    if (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D)
    if (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B)
    let noIntersection = false;
    if (!Envelope.intersects(A, B, C, D)) {
      noIntersection = true;
    } else {
      const denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
      if (denom === 0) {
        noIntersection = true;
      } else {
        const rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
        const sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
        const s = sNum / denom;
        const r = rNumb / denom;
        if (r < 0 || r > 1 || s < 0 || s > 1) {
          noIntersection = true;
        }
      }
    }
    if (noIntersection) {
      return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B))
    }
    return 0.0
  }
  static isPointInRing (p, ring) {
    return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR
  }
  static computeLength (pts) {
    const n = pts.size();
    if (n <= 1) return 0.0
    let len = 0.0;
    const p = new Coordinate();
    pts.getCoordinate(0, p);
    let x0 = p.x;
    let y0 = p.y;
    for (let i = 1; i < n; i++) {
      pts.getCoordinate(i, p);
      const x1 = p.x;
      const y1 = p.y;
      const dx = x1 - x0;
      const dy = y1 - y0;
      len += Math.sqrt(dx * dx + dy * dy);
      x0 = x1;
      y0 = y1;
    }
    return len
  }
  static isCCW (ring) {
    const nPts = ring.length - 1;
    if (nPts < 3) throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined')
    let hiPt = ring[0];
    let hiIndex = 0;
    for (let i = 1; i <= nPts; i++) {
      const p = ring[i];
      if (p.y > hiPt.y) {
        hiPt = p;
        hiIndex = i;
      }
    }
    let iPrev = hiIndex;
    do {
      iPrev = iPrev - 1;
      if (iPrev < 0) iPrev = nPts;
    } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)
    let iNext = hiIndex;
    do {
      iNext = (iNext + 1) % nPts;
    } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)
    const prev = ring[iPrev];
    const next = ring[iNext];
    if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false
    const disc = CGAlgorithms.computeOrientation(prev, hiPt, next);
    let isCCW = false;
    if (disc === 0) {
      isCCW = prev.x > next.x;
    } else {
      isCCW = disc > 0;
    }
    return isCCW
  }
  static locatePointInRing (p, ring) {
    return RayCrossingCounter.locatePointInRing(p, ring)
  }
  static distancePointLinePerpendicular (p, A, B) {
    const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
    const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
    return Math.abs(s) * Math.sqrt(len2)
  }
  static computeOrientation (p1, p2, q) {
    return CGAlgorithms.orientationIndex(p1, p2, q)
  }
  static distancePointLine () {
    if (arguments.length === 2) {
      const p = arguments[0];
      const line = arguments[1];
      if (line.length === 0) throw new IllegalArgumentException('Line array must contain at least one vertex')
      let minDistance = p.distance(line[0]);
      for (let i = 0; i < line.length - 1; i++) {
        const dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
        if (dist < minDistance) {
          minDistance = dist;
        }
      }
      return minDistance
    } else if (arguments.length === 3) {
      const p = arguments[0];
      const A = arguments[1];
      const B = arguments[2];
      if (A.x === B.x && A.y === B.y) return p.distance(A)
      const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
      const r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;
      if (r <= 0.0) return p.distance(A)
      if (r >= 1.0) return p.distance(B)
      const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
      return Math.abs(s) * Math.sqrt(len2)
    }
  }
  static isOnLine (p, pt) {
    const lineIntersector = new RobustLineIntersector();
    for (let i = 1; i < pt.length; i++) {
      const p0 = pt[i - 1];
      const p1 = pt[i];
      lineIntersector.computeIntersection(p, p0, p1);
      if (lineIntersector.hasIntersection()) {
        return true
      }
    }
    return false
  }
  static get CLOCKWISE () { return -1 }
  static get RIGHT () { return CGAlgorithms.CLOCKWISE }
  static get COUNTERCLOCKWISE () { return 1 }
  static get LEFT () { return CGAlgorithms.COUNTERCLOCKWISE }
  static get COLLINEAR () { return 0 }
  static get STRAIGHT () { return CGAlgorithms.COLLINEAR }
}

class GeometryComponentFilter {
  filter (geom) {}
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryComponentFilter
  }
}

class Geometry {
  constructor () {
    const factory = arguments[0];

    this._envelope = null;
    this._factory = null;
    this._SRID = null;
    this._userData = null;
    this._factory = factory;
    this._SRID = factory.getSRID();
  }
  isGeometryCollection () {
    return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION
  }
  getFactory () {
    return this._factory
  }
  getGeometryN (n) {
    return this
  }
  getArea () {
    return 0.0
  }
  isRectangle () {
    return false
  }
  equals () {
    if (arguments[0] instanceof Geometry) {
      let g = arguments[0];
      if (g === null) return false
      return this.equalsTopo(g)
    } else if (arguments[0] instanceof Object) {
      let o = arguments[0];
      if (!(o instanceof Geometry)) return false
      var g = o;
      return this.equalsExact(g)
    }
  }
  equalsExact (other) {
    return this === other || this.equalsExact(other, 0)
  }
  geometryChanged () {
    this.apply(Geometry.geometryChangedFilter);
  }
  geometryChangedAction () {
    this._envelope = null;
  }
  equalsNorm (g) {
    if (g === null) return false
    return this.norm().equalsExact(g.norm())
  }
  getLength () {
    return 0.0
  }
  getNumGeometries () {
    return 1
  }
  compareTo () {
    if (arguments.length === 1) {
      let o = arguments[0];
      var other = o;
      if (this.getSortIndex() !== other.getSortIndex()) {
        return this.getSortIndex() - other.getSortIndex()
      }
      if (this.isEmpty() && other.isEmpty()) {
        return 0
      }
      if (this.isEmpty()) {
        return -1
      }
      if (other.isEmpty()) {
        return 1
      }
      return this.compareToSameClass(o)
    } else if (arguments.length === 2) {
      const other = arguments[0];
      const comp = arguments[1];
      if (this.getSortIndex() !== other.getSortIndex()) {
        return this.getSortIndex() - other.getSortIndex()
      }
      if (this.isEmpty() && other.isEmpty()) {
        return 0
      }
      if (this.isEmpty()) {
        return -1
      }
      if (other.isEmpty()) {
        return 1
      }
      return this.compareToSameClass(other, comp)
    }
  }
  getUserData () {
    return this._userData
  }
  getSRID () {
    return this._SRID
  }
  getEnvelope () {
    return this.getFactory().toGeometry(this.getEnvelopeInternal())
  }
  checkNotGeometryCollection (g) {
    if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
      throw new IllegalArgumentException('This method does not support GeometryCollection arguments')
    }
  }
  equal (a, b, tolerance) {
    if (tolerance === 0) {
      return a.equals(b)
    }
    return a.distance(b) <= tolerance
  }
  norm () {
    var copy = this.copy();
    copy.normalize();
    return copy
  }
  getPrecisionModel () {
    return this._factory.getPrecisionModel()
  }
  getEnvelopeInternal () {
    if (this._envelope === null) {
      this._envelope = this.computeEnvelopeInternal();
    }
    return new Envelope(this._envelope)
  }
  setSRID (SRID) {
    this._SRID = SRID;
  }
  setUserData (userData) {
    this._userData = userData;
  }
  compare (a, b) {
    const i = a.iterator();
    const j = b.iterator();
    while (i.hasNext() && j.hasNext()) {
      const aElement = i.next();
      const bElement = j.next();
      const comparison = aElement.compareTo(bElement);
      if (comparison !== 0) {
        return comparison
      }
    }
    if (i.hasNext()) {
      return 1
    }
    if (j.hasNext()) {
      return -1
    }
    return 0
  }
  hashCode () {
    return this.getEnvelopeInternal().hashCode()
  }
  isGeometryCollectionOrDerived () {
    if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
      return true
    }
    return false
  }
  interfaces_ () {
    return [Clonable, Comparable, Serializable]
  }
  getClass () {
    return Geometry
  }
  static hasNonEmptyElements (geometries) {
    for (var i = 0; i < geometries.length; i++) {
      if (!geometries[i].isEmpty()) {
        return true
      }
    }
    return false
  }
  static hasNullElements (array) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === null) {
        return true
      }
    }
    return false
  }
  static get serialVersionUID () { return 8763622679187376702 }
  static get SORTINDEX_POINT () { return 0 }
  static get SORTINDEX_MULTIPOINT () { return 1 }
  static get SORTINDEX_LINESTRING () { return 2 }
  static get SORTINDEX_LINEARRING () { return 3 }
  static get SORTINDEX_MULTILINESTRING () { return 4 }
  static get SORTINDEX_POLYGON () { return 5 }
  static get SORTINDEX_MULTIPOLYGON () { return 6 }
  static get SORTINDEX_GEOMETRYCOLLECTION () { return 7 }
  static get geometryChangedFilter () { return geometryChangedFilter }
}

class geometryChangedFilter {
  static interfaces_ () {
    return [GeometryComponentFilter]
  }
  static filter (geom) {
    geom.geometryChangedAction();
  }
}

class CoordinateFilter {
  filter (coord) {}
  interfaces_ () {
    return []
  }
  getClass () {
    return CoordinateFilter
  }
}

class BoundaryNodeRule {
  isInBoundary (boundaryCount) {}
  interfaces_ () {
    return []
  }
  getClass () {
    return BoundaryNodeRule
  }
  static get Mod2BoundaryNodeRule () { return Mod2BoundaryNodeRule }
  static get EndPointBoundaryNodeRule () { return EndPointBoundaryNodeRule }
  static get MultiValentEndPointBoundaryNodeRule () { return MultiValentEndPointBoundaryNodeRule }
  static get MonoValentEndPointBoundaryNodeRule () { return MonoValentEndPointBoundaryNodeRule }
  static get MOD2_BOUNDARY_RULE () { return new Mod2BoundaryNodeRule() }
  static get ENDPOINT_BOUNDARY_RULE () { return new EndPointBoundaryNodeRule() }
  static get MULTIVALENT_ENDPOINT_BOUNDARY_RULE () { return new MultiValentEndPointBoundaryNodeRule() }
  static get MONOVALENT_ENDPOINT_BOUNDARY_RULE () { return new MonoValentEndPointBoundaryNodeRule() }
  static get OGC_SFS_BOUNDARY_RULE () { return BoundaryNodeRule.MOD2_BOUNDARY_RULE }
}

class Mod2BoundaryNodeRule {
  isInBoundary (boundaryCount) {
    return boundaryCount % 2 === 1
  }
  interfaces_ () {
    return [BoundaryNodeRule]
  }
  getClass () {
    return Mod2BoundaryNodeRule
  }
}

class EndPointBoundaryNodeRule {
  isInBoundary (boundaryCount) {
    return boundaryCount > 0
  }
  interfaces_ () {
    return [BoundaryNodeRule]
  }
  getClass () {
    return EndPointBoundaryNodeRule
  }
}

class MultiValentEndPointBoundaryNodeRule {
  isInBoundary (boundaryCount) {
    return boundaryCount > 1
  }
  interfaces_ () {
    return [BoundaryNodeRule]
  }
  getClass () {
    return MultiValentEndPointBoundaryNodeRule
  }
}

class MonoValentEndPointBoundaryNodeRule {
  isInBoundary (boundaryCount) {
    return boundaryCount === 1
  }
  interfaces_ () {
    return [BoundaryNodeRule]
  }
  getClass () {
    return MonoValentEndPointBoundaryNodeRule
  }
}

// import Iterator from './Iterator'

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
 *
 * @constructor
 * @private
 */
class Collection {
  /**
   * Ensures that this collection contains the specified element (optional
   * operation).
   * @param {Object} e
   * @return {boolean}
   */
  add () {}

  /**
   * Appends all of the elements in the specified collection to the end of this
   * list, in the order that they are returned by the specified collection's
   * iterator (optional operation).
   * @param {javascript.util.Collection} c
   * @return {boolean}
   */
  addAll () {}

  /**
   * Returns true if this collection contains no elements.
   * @return {boolean}
   */
  isEmpty () {}

  /**
   * Returns an iterator over the elements in this collection.
   * @return {javascript.util.Iterator}
   */
  iterator () {}

  /**
   * Returns an iterator over the elements in this collection.
   * @return {number}
   */
  size () {}

  /**
   * Returns an array containing all of the elements in this collection.
   * @return {Array}
   */
  toArray () {}

  /**
   * Removes a single instance of the specified element from this collection if it
   * is present. (optional)
   * @param {Object} e
   * @return {boolean}
   */
  remove () {}
}

/**
 * @param {string} [message] Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
class IndexOutOfBoundsException extends Error {
  constructor (message) {
    super();
    this.message = message || '';
  }

  /**
   * @type {string}
   */
  static get name () { return 'IndexOutOfBoundsException' }
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
 * @constructor
 * @private
 */
class Iterator {
  /**
   * Returns true if the iteration has more elements.
   * @return {boolean}
   */
  hasNext () {}

  /**
   * Returns the next element in the iteration.
   * @return {Object}
   */
  next () {}

  /**
   * Removes from the underlying collection the last element returned by the
   * iterator (optional operation).
   */
  remove () {}
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html
 *
 * @extends {javascript.util.Collection}
 * @constructor
 * @private
 */
class List extends Collection {
  /**
   * Returns the element at the specified position in this list.
   * @param {number} index
   * @return {Object}
   */
  get () { }

  /**
   * Replaces the element at the specified position in this list with the
   * specified element (optional operation).
   * @param {number} index
   * @param {Object} e
   * @return {Object}
   */
  set () { }

  /**
   * Returns true if this collection contains no elements.
   * @return {boolean}
   */
  isEmpty () { }
}

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function NoSuchElementException (message) {
  this.message = message || '';
}
NoSuchElementException.prototype = new Error();

/**
 * @type {string}
 */
NoSuchElementException.prototype.name = 'NoSuchElementException';

// import OperationNotSupported from './OperationNotSupported'

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html
 *
 * @extends List
 * @private
 */
class ArrayList extends List {
  constructor () {
    super();
    this.array_ = [];

    if (arguments[0] instanceof Collection) {
      this.addAll(arguments[0]);
    }
  }

  ensureCapacity () {}
  interfaces_ () { return [List, Collection] }

  /**
   * @override
   */
  add (e) {
    if (arguments.length === 1) {
      this.array_.push(e);
    } else {
      this.array_.splice(arguments[0], arguments[1]);
    }
    return true
  }

  clear () {
    this.array_ = [];
  }

  /**
   * @override
   */
  addAll (c) {
    for (var i = c.iterator(); i.hasNext();) {
      this.add(i.next());
    }
    return true
  }

  /**
   * @override
   */
  set (index, element) {
    var oldElement = this.array_[index];
    this.array_[index] = element;
    return oldElement
  }

  /**
   * @override
   */
  iterator () {
    return new Iterator_(this)
  }

  /**
   * @override
   */
  get (index) {
    if (index < 0 || index >= this.size()) {
      throw new IndexOutOfBoundsException()
    }

    return this.array_[index]
  }

  /**
   * @override
   */
  isEmpty () {
    return this.array_.length === 0
  }

  /**
   * @override
   */
  size () {
    return this.array_.length
  }

  /**
   * @override
   */
  toArray () {
    var array = [];

    for (var i = 0, len = this.array_.length; i < len; i++) {
      array.push(this.array_[i]);
    }

    return array
  }

  /**
   * @override
   */
  remove (o) {
    var found = false;

    for (var i = 0, len = this.array_.length; i < len; i++) {
      if (this.array_[i] === o) {
        this.array_.splice(i, 1);
        found = true;
        break
      }
    }

    return found
  }
}

/**
 * @extends {Iterator}
 * @param {ArrayList} arrayList
 * @constructor
 * @private
 */
class Iterator_ extends Iterator {
  constructor (arrayList) {
    super();
    /**
     * @type {ArrayList}
     * @private
    */
    this.arrayList_ = arrayList;
    /**
     * @type {number}
     * @private
    */
    this.position_ = 0;
  }

  /**
   * @override
   */
  next () {
    if (this.position_ === this.arrayList_.size()) {
      throw new NoSuchElementException()
    }
    return this.arrayList_.get(this.position_++)
  }

  /**
   * @override
   */
  hasNext () {
    if (this.position_ < this.arrayList_.size()) {
      return true
    } else {
      return false
    }
  }

  /**
   * TODO: should be in ListIterator
   * @override
   */
  set (element) {
    return this.arrayList_.set(this.position_ - 1, element)
  }

  /**
   * @override
   */
  remove () {
    this.arrayList_.remove(this.arrayList_.get(this.position_));
  }
}

class CoordinateList extends ArrayList {
  constructor () {
    super();
    if (arguments.length === 0) {
    } else if (arguments.length === 1) {
      let coord = arguments[0];
      this.ensureCapacity(coord.length);
      this.add(coord, true);
    } else if (arguments.length === 2) {
      const coord = arguments[0];
      const allowRepeated = arguments[1];
      this.ensureCapacity(coord.length);
      this.add(coord, allowRepeated);
    }
  }
  static get coordArrayType () { return new Array(0).fill(null) }
  getCoordinate (i) {
    return this.get(i)
  }
  addAll () {
    if (arguments.length === 2) {
      const coll = arguments[0];
      const allowRepeated = arguments[1];
      let isChanged = false;
      for (let i = coll.iterator(); i.hasNext();) {
        this.add(i.next(), allowRepeated);
        isChanged = true;
      }
      return isChanged
    } else return ArrayList.prototype.addAll.apply(this, arguments)
  }
  clone () {
    var clone = ArrayList.prototype.clone.call(this);
    for (var i = 0; i < this.size(); i++) {
      clone.add(i, this.get(i).copy());
    }
    return clone
  }
  toCoordinateArray () {
    return this.toArray(CoordinateList.coordArrayType)
  }
  add () {
    if (arguments.length === 1) {
      const coord = arguments[0];
      ArrayList.prototype.add.call(this, coord);
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
        const coord = arguments[0];
        const allowRepeated = arguments[1];
        this.add(coord, allowRepeated, true);
        return true
      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {
        const coord = arguments[0];
        const allowRepeated = arguments[1];
        if (!allowRepeated) {
          if (this.size() >= 1) {
            var last = this.get(this.size() - 1);
            if (last.equals2D(coord)) return null
          }
        }
        ArrayList.prototype.add.call(this, coord);
      } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {
        const obj = arguments[0];
        const allowRepeated = arguments[1];
        this.add(obj, allowRepeated);
        return true
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {
        const coord = arguments[0];
        const allowRepeated = arguments[1];
        const direction = arguments[2];
        if (direction) {
          for (let i = 0; i < coord.length; i++) {
            this.add(coord[i], allowRepeated);
          }
        } else {
          for (let i = coord.length - 1; i >= 0; i--) {
            this.add(coord[i], allowRepeated);
          }
        }
        return true
      } else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {
        const i = arguments[0];
        const coord = arguments[1];
        const allowRepeated = arguments[2];
        if (!allowRepeated) {
          const size = this.size();
          if (size > 0) {
            if (i > 0) {
              const prev = this.get(i - 1);
              if (prev.equals2D(coord)) return null
            }
            if (i < size) {
              const next = this.get(i);
              if (next.equals2D(coord)) return null
            }
          }
        }
        ArrayList.prototype.add.call(this, i, coord);
      }
    } else if (arguments.length === 4) {
      const coord = arguments[0];
      const allowRepeated = arguments[1];
      const start = arguments[2];
      const end = arguments[3];
      var inc = 1;
      if (start > end) inc = -1;
      for (var i = start; i !== end; i += inc) {
        this.add(coord[i], allowRepeated);
      }
      return true
    }
  }
  closeRing () {
    if (this.size() > 0) this.add(new Coordinate(this.get(0)), false);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return CoordinateList
  }
}

class CoordinateArrays {
  static get ForwardComparator () { return ForwardComparator }
  static get BidirectionalComparator () { return BidirectionalComparator }
  static get coordArrayType () { return new Array(0).fill(null) }

  interfaces_ () {
    return []
  }
  getClass () {
    return CoordinateArrays
  }
  static isRing (pts) {
    if (pts.length < 4) return false
    if (!pts[0].equals2D(pts[pts.length - 1])) return false
    return true
  }
  static ptNotInList (testPts, pts) {
    for (var i = 0; i < testPts.length; i++) {
      var testPt = testPts[i];
      if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt
    }
    return null
  }
  static scroll (coordinates, firstCoordinate) {
    var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
    if (i < 0) return null
    var newCoordinates = new Array(coordinates.length).fill(null);
    System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
    System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
    System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
  }
  static equals () {
    if (arguments.length === 2) {
      const coord1 = arguments[0];
      const coord2 = arguments[1];
      if (coord1 === coord2) return true
      if (coord1 === null || coord2 === null) return false
      if (coord1.length !== coord2.length) return false
      for (var i = 0; i < coord1.length; i++) {
        if (!coord1[i].equals(coord2[i])) return false
      }
      return true
    } else if (arguments.length === 3) {
      const coord1 = arguments[0];
      const coord2 = arguments[1];
      const coordinateComparator = arguments[2];
      if (coord1 === coord2) return true
      if (coord1 === null || coord2 === null) return false
      if (coord1.length !== coord2.length) return false
      for (let i = 0; i < coord1.length; i++) {
        if (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false
      }
      return true
    }
  }
  static intersection (coordinates, env) {
    var coordList = new CoordinateList();
    for (var i = 0; i < coordinates.length; i++) {
      if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);
    }
    return coordList.toCoordinateArray()
  }
  static hasRepeatedPoints (coord) {
    for (var i = 1; i < coord.length; i++) {
      if (coord[i - 1].equals(coord[i])) {
        return true
      }
    }
    return false
  }
  static removeRepeatedPoints (coord) {
    if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord
    var coordList = new CoordinateList(coord, false);
    return coordList.toCoordinateArray()
  }
  static reverse (coord) {
    var last = coord.length - 1;
    var mid = Math.trunc(last / 2);
    for (var i = 0; i <= mid; i++) {
      var tmp = coord[i];
      coord[i] = coord[last - i];
      coord[last - i] = tmp;
    }
  }
  static removeNull (coord) {
    let nonNull = 0;
    for (let i = 0; i < coord.length; i++) {
      if (coord[i] !== null) nonNull++;
    }
    const newCoord = new Array(nonNull).fill(null);
    if (nonNull === 0) return newCoord
    let j = 0;
    for (let i = 0; i < coord.length; i++) {
      if (coord[i] !== null) newCoord[j++] = coord[i];
    }
    return newCoord
  }
  static copyDeep () {
    if (arguments.length === 1) {
      const coordinates = arguments[0];
      const copy = new Array(coordinates.length).fill(null);
      for (let i = 0; i < coordinates.length; i++) {
        copy[i] = new Coordinate(coordinates[i]);
      }
      return copy
    } else if (arguments.length === 5) {
      const src = arguments[0];
      const srcStart = arguments[1];
      const dest = arguments[2];
      const destStart = arguments[3];
      const length = arguments[4];
      for (let i = 0; i < length; i++) {
        dest[destStart + i] = new Coordinate(src[srcStart + i]);
      }
    }
  }
  static isEqualReversed (pts1, pts2) {
    for (let i = 0; i < pts1.length; i++) {
      const p1 = pts1[i];
      const p2 = pts2[pts1.length - i - 1];
      if (p1.compareTo(p2) !== 0) return false
    }
    return true
  }
  static envelope (coordinates) {
    var env = new Envelope();
    for (let i = 0; i < coordinates.length; i++) {
      env.expandToInclude(coordinates[i]);
    }
    return env
  }
  static toCoordinateArray (coordList) {
    return coordList.toArray(CoordinateArrays.coordArrayType)
  }
  static atLeastNCoordinatesOrNothing (n, c) {
    return c.length >= n ? c : []
  }
  static indexOf (coordinate, coordinates) {
    for (var i = 0; i < coordinates.length; i++) {
      if (coordinate.equals(coordinates[i])) {
        return i
      }
    }
    return -1
  }
  static increasingDirection (pts) {
    for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
      var j = pts.length - 1 - i;
      var comp = pts[i].compareTo(pts[j]);
      if (comp !== 0) return comp
    }
    return 1
  }
  static compare (pts1, pts2) {
    var i = 0;
    while (i < pts1.length && i < pts2.length) {
      var compare = pts1[i].compareTo(pts2[i]);
      if (compare !== 0) return compare
      i++;
    }
    if (i < pts2.length) return -1
    if (i < pts1.length) return 1
    return 0
  }
  static minCoordinate (coordinates) {
    var minCoord = null;
    for (var i = 0; i < coordinates.length; i++) {
      if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
        minCoord = coordinates[i];
      }
    }
    return minCoord
  }
  static extract (pts, start, end) {
    start = MathUtil.clamp(start, 0, pts.length);
    end = MathUtil.clamp(end, -1, pts.length);
    var npts = end - start + 1;
    if (end < 0) npts = 0;
    if (start >= pts.length) npts = 0;
    if (end < start) npts = 0;
    var extractPts = new Array(npts).fill(null);
    if (npts === 0) return extractPts
    var iPts = 0;
    for (var i = start; i <= end; i++) {
      extractPts[iPts++] = pts[i];
    }
    return extractPts
  }
}
class ForwardComparator {
  compare (o1, o2) {
    var pts1 = o1;
    var pts2 = o2;
    return CoordinateArrays.compare(pts1, pts2)
  }
  interfaces_ () {
    return [Comparator]
  }
  getClass () {
    return ForwardComparator
  }
}

class BidirectionalComparator {
  compare (o1, o2) {
    var pts1 = o1;
    var pts2 = o2;
    if (pts1.length < pts2.length) return -1
    if (pts1.length > pts2.length) return 1
    if (pts1.length === 0) return 0
    var forwardComp = CoordinateArrays.compare(pts1, pts2);
    var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
    if (isEqualRev) return 0
    return forwardComp
  }
  OLDcompare (o1, o2) {
    var pts1 = o1;
    var pts2 = o2;
    if (pts1.length < pts2.length) return -1
    if (pts1.length > pts2.length) return 1
    if (pts1.length === 0) return 0
    var dir1 = CoordinateArrays.increasingDirection(pts1);
    var dir2 = CoordinateArrays.increasingDirection(pts2);
    var i1 = dir1 > 0 ? 0 : pts1.length - 1;
    var i2 = dir2 > 0 ? 0 : pts1.length - 1;
    for (var i = 0; i < pts1.length; i++) {
      var comparePt = pts1[i1].compareTo(pts2[i2]);
      if (comparePt !== 0) return comparePt
      i1 += dir1;
      i2 += dir2;
    }
    return 0
  }
  interfaces_ () {
    return [Comparator]
  }
  getClass () {
    return BidirectionalComparator
  }
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
 *
 * @constructor
 * @private
 */
class Map$1 {
  /**
   * Returns the value to which the specified key is mapped, or null if this map
   * contains no mapping for the key.
   * @param {Object} key
   * @return {Object}
   */
  get () {};
  /**
   * Associates the specified value with the specified key in this map (optional
   * operation).
   * @param {Object} key
   * @param {Object} value
   * @return {Object}
   */
  put () {};

  /**
   * Returns the number of key-value mappings in this map.
   * @return {number}
   */
  size () {};

  /**
   * Returns a Collection view of the values contained in this map.
   * @return {javascript.util.Collection}
   */
  values () {};

  /**
   * Returns a {@link Set} view of the mappings contained in this map.
   * The set is backed by the map, so changes to the map are
   * reflected in the set, and vice-versa.  If the map is modified
   * while an iteration over the set is in progress (except through
   * the iterator's own <tt>remove</tt> operation, or through the
   * <tt>setValue</tt> operation on a map entry returned by the
   * iterator) the results of the iteration are undefined.  The set
   * supports element removal, which removes the corresponding
   * mapping from the map, via the <tt>Iterator.remove</tt>,
   * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
   * <tt>clear</tt> operations.  It does not support the
   * <tt>add</tt> or <tt>addAll</tt> operations.
   *
   * @return {Set} a set view of the mappings contained in this map
   */
  entrySet () {};
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html
 *
 * @extends {Map}
 * @constructor
 * @private
 */
class SortedMap extends Map$1 {}

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function OperationNotSupported (message) {
  this.message = message || '';
}
OperationNotSupported.prototype = new Error();

/**
 * @type {string}
 */
OperationNotSupported.prototype.name = 'OperationNotSupported';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html
 *
 * @extends {Collection}
 * @constructor
 * @private
 */
function Set() {}
Set.prototype = new Collection();


/**
 * Returns true if this set contains the specified element. More formally,
 * returns true if and only if this set contains an element e such that (o==null ?
 * e==null : o.equals(e)).
 * @param {Object} e
 * @return {boolean}
 */
Set.prototype.contains = function() {};

/**
 * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html
 *
 * @extends {javascript.util.Set}
 * @constructor
 * @private
 */
class HashSet extends Set {
  constructor () {
    super();
    this.array_ = [];

    if (arguments[0] instanceof Collection) {
      this.addAll(arguments[0]);
    }
  }

  /**
   * @override
   */
  contains (o) {
    for (var i = 0, len = this.array_.length; i < len; i++) {
      var e = this.array_[i];
      if (e === o) {
        return true
      }
    }
    return false
  }

  /**
   * @override
   */
  add (o) {
    if (this.contains(o)) {
      return false
    }

    this.array_.push(o);

    return true
  }

  /**
   * @override
   */
  addAll (c) {
    for (var i = c.iterator(); i.hasNext();) {
      this.add(i.next());
    }
    return true
  }

  /**
   * @override
   */
  remove (o) {
    // throw new javascript.util.OperationNotSupported()
    throw new Error()
  }

  /**
   * @override
   */
  size () {
    return this.array_.length
  }

  /**
   * @override
   */
  isEmpty () {
    return this.array_.length === 0
  }

  /**
   * @override
   */
  toArray () {
    var array = [];

    for (var i = 0, len = this.array_.length; i < len; i++) {
      array.push(this.array_[i]);
    }

    return array
  }

  /**
   * @override
   */
  iterator () {
    return new Iterator_$1(this)
  }
}

  /**
   * @extends {Iterator}
   * @param {HashSet} hashSet
   * @constructor
   * @private
   */
class Iterator_$1 extends Iterator {
  constructor (hashSet) {
    super();
    /**
     * @type {HashSet}
     * @private
     */
    this.hashSet_ = hashSet;
    /**
     * @type {number}
     * @private
     */
    this.position_ = 0;
  }

  /**
   * @override
   */
  next () {
    if (this.position_ === this.hashSet_.size()) {
      throw new NoSuchElementException()
    }
    return this.hashSet_.array_[this.position_++]
  }

  /**
   * @override
   */
  hasNext () {
    if (this.position_ < this.hashSet_.size()) {
      return true
    } else {
      return false
    }
  }

  /**
   * @override
   */
  remove () {
    throw new OperationNotSupported()
  }
}

const BLACK = 0;
const RED = 1;
function colorOf (p) { return (p === null ? BLACK : p.color) }
function parentOf (p) { return (p === null ? null : p.parent) }
function setColor (p, c) { if (p !== null) p.color = c; }
function leftOf (p) { return (p === null ? null : p.left) }
function rightOf (p) { return (p === null ? null : p.right) }

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html
 *
 * @extends {SortedMap}
 * @constructor
 * @private
 */
function TreeMap () {
  /**
   * @type {Object}
   * @private
   */
  this.root_ = null;
  /**
   * @type {number}
   * @private
  */
  this.size_ = 0;
}
TreeMap.prototype = new SortedMap();

/**
 * @override
 */
TreeMap.prototype.get = function (key) {
  let p = this.root_;
  while (p !== null) {
    const cmp = key['compareTo'](p.key);
    if (cmp < 0) p = p.left;
    else if (cmp > 0) p = p.right;
    else return p.value
  }
  return null
};

/**
 * @override
 */
TreeMap.prototype.put = function (key, value) {
  if (this.root_ === null) {
    this.root_ = {
      key: key,
      value: value,
      left: null,
      right: null,
      parent: null,
      color: BLACK,
      getValue () { return this.value },
      getKey () { return this.key }
    };
    this.size_ = 1;
    return null
  }
  let t = this.root_;
  let parent;
  let cmp;
  do {
    parent = t;
    cmp = key['compareTo'](t.key);
    if (cmp < 0) {
      t = t.left;
    } else if (cmp > 0) {
      t = t.right;
    } else {
      const oldValue = t.value;
      t.value = value;
      return oldValue
    }
  } while (t !== null)
  const e = {
    key: key,
    left: null,
    right: null,
    value: value,
    parent: parent,
    color: BLACK,
    getValue () { return this.value },
    getKey () { return this.key }
  };
  if (cmp < 0) {
    parent.left = e;
  } else {
    parent.right = e;
  }
  this.fixAfterInsertion(e);
  this.size_++;
  return null
};

/**
 * @param {Object} x
 */
TreeMap.prototype.fixAfterInsertion = function (x) {
  x.color = RED;
  while (x != null && x !== this.root_ && x.parent.color === RED) {
    if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
      const y = rightOf(parentOf(parentOf(x)));
      if (colorOf(y) === RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x === rightOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateLeft(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateRight(parentOf(parentOf(x)));
      }
    } else {
      const y = leftOf(parentOf(parentOf(x)));
      if (colorOf(y) === RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x === leftOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateRight(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateLeft(parentOf(parentOf(x)));
      }
    }
  }
  this.root_.color = BLACK;
};

/**
 * @override
 */
TreeMap.prototype.values = function () {
  const arrayList = new ArrayList();
  let p = this.getFirstEntry();
  if (p !== null) {
    arrayList.add(p.value);
    while ((p = TreeMap.successor(p)) !== null) {
      arrayList.add(p.value);
    }
  }
  return arrayList
};

/**
 * @override
 */
TreeMap.prototype.entrySet = function () {
  const hashSet = new HashSet();
  let p = this.getFirstEntry();
  if (p !== null) {
    hashSet.add(p);
    while ((p = TreeMap.successor(p)) !== null) {
      hashSet.add(p);
    }
  }
  return hashSet
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateLeft = function (p) {
  if (p != null) {
    const r = p.right;
    p.right = r.left;
    if (r.left != null) { r.left.parent = p; }
    r.parent = p.parent;
    if (p.parent === null) { this.root_ = r; } else if (p.parent.left === p) { p.parent.left = r; } else { p.parent.right = r; }
    r.left = p;
    p.parent = r;
  }
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateRight = function (p) {
  if (p != null) {
    const l = p.left;
    p.left = l.right;
    if (l.right != null) l.right.parent = p;
    l.parent = p.parent;
    if (p.parent === null) { this.root_ = l; } else if (p.parent.right === p) { p.parent.right = l; } else p.parent.left = l;
    l.right = p;
    p.parent = l;
  }
};

/**
 * @return {Object}
 */
TreeMap.prototype.getFirstEntry = function () {
  let p = this.root_;
  if (p != null) {
    while (p.left != null) {
      p = p.left;
    }
  }
  return p
};

/**
 * @param {Object} t
 * @return {Object}
 * @private
 */
TreeMap.successor = function (t) {
  if (t === null) { return null } else if (t.right !== null) {
    let p = t.right;
    while (p.left !== null) {
      p = p.left;
    }
    return p
  } else {
    let p = t.parent;
    let ch = t;
    while (p !== null && ch === p.right) {
      ch = p;
      p = p.parent;
    }
    return p
  }
};

/**
 * @override
 */
TreeMap.prototype.size = function () {
  return this.size_
};

class Lineal {
  interfaces_ () {
    return []
  }
  getClass () {
    return Lineal
  }
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html
 *
 * @extends {Set}
 * @constructor
 * @private
 */
function SortedSet () {}
SortedSet.prototype = new Set();

// import Iterator from './Iterator'
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html
 *
 * @extends {SortedSet}
 * @constructor
 * @private
 */
function TreeSet () {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}
TreeSet.prototype = new SortedSet();

/**
 * @override
 */
TreeSet.prototype.contains = function (o) {
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 0) {
      return true
    }
  }
  return false
};

/**
 * @override
 */
TreeSet.prototype.add = function (o) {
  if (this.contains(o)) {
    return false
  }

  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 1) {
      this.array_.splice(i, 0, o);
      return true
    }
  }

  this.array_.push(o);

  return true
};

/**
 * @override
 */
TreeSet.prototype.addAll = function (c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true
};

/**
 * @override
 */
TreeSet.prototype.remove = function (e) {
  throw new OperationNotSupported()
};

/**
 * @override
 */
TreeSet.prototype.size = function () {
  return this.array_.length
};

/**
 * @override
 */
TreeSet.prototype.isEmpty = function () {
  return this.array_.length === 0
};

/**
 * @override
 */
TreeSet.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array
};

/**
 * @override
 */
TreeSet.prototype.iterator = function () {
  return new Iterator_$2(this)
};

/**
 * @extends {javascript.util.Iterator}
 * @param {javascript.util.TreeSet} treeSet
 * @constructor
 * @private
 */
var Iterator_$2 = function (treeSet) {
  /**
   * @type {javascript.util.TreeSet}
   * @private
   */
  this.treeSet_ = treeSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_$2.prototype.next = function () {
  if (this.position_ === this.treeSet_.size()) {
    throw new NoSuchElementException()
  }
  return this.treeSet_.array_[this.position_++]
};

/**
 * @override
 */
Iterator_$2.prototype.hasNext = function () {
  if (this.position_ < this.treeSet_.size()) {
    return true
  } else {
    return false
  }
};

/**
 * @override
 */
Iterator_$2.prototype.remove = function () {
  throw new OperationNotSupported()
};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html
 *
 * @constructor
 * @private
 */
class Arrays {
  static sort () {
    const a = arguments[0];
    let i;
    let t;
    let comparator;
    let compare;
    if (arguments.length === 1) {
      compare = function (a, b) {
        return a.compareTo(b)
      };
      a.sort(compare);
    } else if (arguments.length === 2) {
      comparator = arguments[1];
      compare = function (a, b) {
        return comparator['compare'](a, b)
      };
      a.sort(compare);
    } else if (arguments.length === 3) {
      t = a.slice(arguments[1], arguments[2]);
      t.sort();
      var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
      a.splice(0, a.length);
      for (i = 0; i < r.length; i++) {
        a.push(r[i]);
      }
    } else if (arguments.length === 4) {
      t = a.slice(arguments[1], arguments[2]);
      comparator = arguments[3];
      compare = function (a, b) {
        return comparator['compare'](a, b)
      };
      t.sort(compare);
      r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
      a.splice(0, a.length);
      for (i = 0; i < r.length; i++) {
        a.push(r[i]);
      }
    }
  }
  /**
   * @param {Array} array
   * @return {ArrayList}
   */
  static asList (array) {
    var arrayList = new ArrayList();
    for (var i = 0, len = array.length; i < len; i++) {
      arrayList.add(array[i]);
    }
    return arrayList
  }
}

class Dimension {
  static get P () { return 0 }
  static get L () { return 1 }
  static get A () { return 2 }
  static get FALSE () { return -1 }
  static get TRUE () { return -2 }
  static get DONTCARE () { return -3 }
  static get SYM_FALSE () { return 'F' }
  static get SYM_TRUE () { return 'T' }
  static get SYM_DONTCARE () { return '*' }
  static get SYM_P () { return '0' }
  static get SYM_L () { return '1' }
  static get SYM_A () { return '2' }

  interfaces_ () {
    return []
  }
  getClass () {
    return Dimension
  }
  static toDimensionSymbol (dimensionValue) {
    switch (dimensionValue) {
      case Dimension.FALSE:
        return Dimension.SYM_FALSE
      case Dimension.TRUE:
        return Dimension.SYM_TRUE
      case Dimension.DONTCARE:
        return Dimension.SYM_DONTCARE
      case Dimension.P:
        return Dimension.SYM_P
      case Dimension.L:
        return Dimension.SYM_L
      case Dimension.A:
        return Dimension.SYM_A
      default:
    }
    throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue)
  }
  static toDimensionValue (dimensionSymbol) {
    switch (Character.toUpperCase(dimensionSymbol)) {
      case Dimension.SYM_FALSE:
        return Dimension.FALSE
      case Dimension.SYM_TRUE:
        return Dimension.TRUE
      case Dimension.SYM_DONTCARE:
        return Dimension.DONTCARE
      case Dimension.SYM_P:
        return Dimension.P
      case Dimension.SYM_L:
        return Dimension.L
      case Dimension.SYM_A:
        return Dimension.A
      default:
    }
    throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol)
  }
}

class GeometryFilter {
  filter (geom) {}
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryFilter
  }
}

class CoordinateSequenceFilter {
  filter (seq, i) {}
  isDone () {}
  isGeometryChanged () {}
  interfaces_ () {
    return []
  }
  getClass () {
    return CoordinateSequenceFilter
  }
}

class GeometryCollection extends Geometry {
  constructor (geometries, factory) {
    super(factory);
    this._geometries = geometries || [];

    if (Geometry.hasNullElements(this._geometries)) {
      throw new IllegalArgumentException('geometries must not contain null elements')
    }
  }
  computeEnvelopeInternal () {
    var envelope = new Envelope();
    for (var i = 0; i < this._geometries.length; i++) {
      envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());
    }
    return envelope
  }
  getGeometryN (n) {
    return this._geometries[n]
  }
  getSortIndex () {
    return Geometry.SORTINDEX_GEOMETRYCOLLECTION
  }
  getCoordinates () {
    var coordinates = new Array(this.getNumPoints()).fill(null);
    var k = -1;
    for (var i = 0; i < this._geometries.length; i++) {
      var childCoordinates = this._geometries[i].getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates
  }
  getArea () {
    var area = 0.0;
    for (var i = 0; i < this._geometries.length; i++) {
      area += this._geometries[i].getArea();
    }
    return area
  }
  equalsExact () {
    if (arguments.length === 2) {
      const other = arguments[0];
      const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      var otherCollection = other;
      if (this._geometries.length !== otherCollection._geometries.length) {
        return false
      }
      for (var i = 0; i < this._geometries.length; i++) {
        if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
          return false
        }
      }
      return true
    } else return Geometry.prototype.equalsExact.apply(this, arguments)
  }
  normalize () {
    for (var i = 0; i < this._geometries.length; i++) {
      this._geometries[i].normalize();
    }
    Arrays.sort(this._geometries);
  }
  getCoordinate () {
    if (this.isEmpty()) return null
    return this._geometries[0].getCoordinate()
  }
  getBoundaryDimension () {
    var dimension = Dimension.FALSE;
    for (var i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());
    }
    return dimension
  }
  getDimension () {
    var dimension = Dimension.FALSE;
    for (var i = 0; i < this._geometries.length; i++) {
      dimension = Math.max(dimension, this._geometries[i].getDimension());
    }
    return dimension
  }
  getLength () {
    var sum = 0.0;
    for (var i = 0; i < this._geometries.length; i++) {
      sum += this._geometries[i].getLength();
    }
    return sum
  }
  getNumPoints () {
    var numPoints = 0;
    for (var i = 0; i < this._geometries.length; i++) {
      numPoints += this._geometries[i].getNumPoints();
    }
    return numPoints
  }
  getNumGeometries () {
    return this._geometries.length
  }
  reverse () {
    var n = this._geometries.length;
    var revGeoms = new Array(n).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this._geometries[i].reverse();
    }
    return this.getFactory().createGeometryCollection(revGeoms)
  }
  compareToSameClass () {
    if (arguments.length === 1) {
      const o = arguments[0];
      const theseElements = new TreeSet(Arrays.asList(this._geometries));
      const otherElements = new TreeSet(Arrays.asList(o._geometries));
      return this.compare(theseElements, otherElements)
    } else if (arguments.length === 2) {
      const o = arguments[0];
      const comp = arguments[1];
      const gc = o;
      const n1 = this.getNumGeometries();
      const n2 = gc.getNumGeometries();
      let i = 0;
      while (i < n1 && i < n2) {
        const thisGeom = this.getGeometryN(i);
        const otherGeom = gc.getGeometryN(i);
        const holeComp = thisGeom.compareToSameClass(otherGeom, comp);
        if (holeComp !== 0) return holeComp
        i++;
      }
      if (i < n1) return 1
      if (i < n2) return -1
      return 0
    }
  }
  apply () {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      const filter = arguments[0];
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      const filter = arguments[0];
      if (this._geometries.length === 0) return null
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
        if (filter.isDone()) {
          break
        }
      }
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      const filter = arguments[0];
      filter.filter(this);
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
      }
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      let filter = arguments[0];
      filter.filter(this);
      for (let i = 0; i < this._geometries.length; i++) {
        this._geometries[i].apply(filter);
      }
    }
  }
  getBoundary () {
    this.checkNotGeometryCollection(this);
    Assert.shouldNeverReachHere();
    return null
  }
  clone () {
    var gc = Geometry.prototype.clone.call(this);
    gc._geometries = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      gc._geometries[i] = this._geometries[i].clone();
    }
    return gc
  }
  getGeometryType () {
    return 'GeometryCollection'
  }
  copy () {
    var geometries = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < geometries.length; i++) {
      geometries[i] = this._geometries[i].copy();
    }
    return new GeometryCollection(geometries, this._factory)
  }
  isEmpty () {
    for (let i = 0; i < this._geometries.length; i++) {
      if (!this._geometries[i].isEmpty()) {
        return false
      }
    }
    return true
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryCollection
  }
  static get serialVersionUID () { return -5694727726395021467 }
}

class MultiLineString extends GeometryCollection {
  getSortIndex () {
    return Geometry.SORTINDEX_MULTILINESTRING
  }
  equalsExact () {
    if (arguments.length === 2) {
      const other = arguments[0];
      const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      return GeometryCollection.prototype.equalsExact.call(this, other, tolerance)
    } else return GeometryCollection.prototype.equalsExact.apply(this, arguments)
  }
  getBoundaryDimension () {
    if (this.isClosed()) {
      return Dimension.FALSE
    }
    return 0
  }
  isClosed () {
    if (this.isEmpty()) {
      return false
    }
    for (var i = 0; i < this._geometries.length; i++) {
      if (!this._geometries[i].isClosed()) {
        return false
      }
    }
    return true
  }
  getDimension () {
    return 1
  }
  reverse () {
    var nLines = this._geometries.length;
    var revLines = new Array(nLines).fill(null);
    for (var i = 0; i < this._geometries.length; i++) {
      revLines[nLines - 1 - i] = this._geometries[i].reverse();
    }
    return this.getFactory().createMultiLineString(revLines)
  }
  getBoundary () {
    return new BoundaryOp(this).getBoundary()
  }
  getGeometryType () {
    return 'MultiLineString'
  }
  copy () {
    var lineStrings = new Array(this._geometries.length).fill(null);
    for (var i = 0; i < lineStrings.length; i++) {
      lineStrings[i] = this._geometries[i].copy();
    }
    return new MultiLineString(lineStrings, this._factory)
  }
  interfaces_ () {
    return [Lineal]
  }
  getClass () {
    return MultiLineString
  }
  static get serialVersionUID () { return 8166665132445433741 }
}

class BoundaryOp {
  constructor () {
    this._geom = null;
    this._geomFact = null;
    this._bnRule = null;
    this._endpointMap = null;
    if (arguments.length === 1) {
      const geom = arguments[0];
      const bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;
      this._geom = geom;
      this._geomFact = geom.getFactory();
      this._bnRule = bnRule;
    } else if (arguments.length === 2) {
      const geom = arguments[0];
      const bnRule = arguments[1];
      this._geom = geom;
      this._geomFact = geom.getFactory();
      this._bnRule = bnRule;
    }
  }
  boundaryMultiLineString (mLine) {
    if (this._geom.isEmpty()) {
      return this.getEmptyMultiPoint()
    }
    const bdyPts = this.computeBoundaryCoordinates(mLine);
    if (bdyPts.length === 1) {
      return this._geomFact.createPoint(bdyPts[0])
    }
    return this._geomFact.createMultiPointFromCoords(bdyPts)
  }
  getBoundary () {
    if (this._geom instanceof LineString) return this.boundaryLineString(this._geom)
    if (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom)
    return this._geom.getBoundary()
  }
  boundaryLineString (line) {
    if (this._geom.isEmpty()) {
      return this.getEmptyMultiPoint()
    }
    if (line.isClosed()) {
      const closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
      if (closedEndpointOnBoundary) {
        return line.getStartPoint()
      } else {
        return this._geomFact.createMultiPoint()
      }
    }
    return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()])
  }
  getEmptyMultiPoint () {
    return this._geomFact.createMultiPoint()
  }
  computeBoundaryCoordinates (mLine) {
    const bdyPts = new ArrayList();
    this._endpointMap = new TreeMap();
    for (let i = 0; i < mLine.getNumGeometries(); i++) {
      const line = mLine.getGeometryN(i);
      if (line.getNumPoints() === 0) continue
      this.addEndpoint(line.getCoordinateN(0));
      this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
    }
    for (const it = this._endpointMap.entrySet().iterator(); it.hasNext();) {
      const entry = it.next();
      const counter = entry.getValue();
      const valence = counter.count;
      if (this._bnRule.isInBoundary(valence)) {
        bdyPts.add(entry.getKey());
      }
    }
    return CoordinateArrays.toCoordinateArray(bdyPts)
  }
  addEndpoint (pt) {
    let counter = this._endpointMap.get(pt);
    if (counter === null) {
      counter = new Counter();
      this._endpointMap.put(pt, counter);
    }
    counter.count++;
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return BoundaryOp
  }
  static getBoundary () {
    if (arguments.length === 1) {
      const g = arguments[0];
      const bop = new BoundaryOp(g);
      return bop.getBoundary()
    } else if (arguments.length === 2) {
      const g = arguments[0];
      const bnRule = arguments[1];
      const bop = new BoundaryOp(g, bnRule);
      return bop.getBoundary()
    }
  }
}

class Counter {
  constructor () {
    this.count = null;
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return Counter
  }
}

// boundary

function PrintStream () {}

function StringReader () {}

class DecimalFormat {}

function ByteArrayOutputStream () {}

function IOException () {}

function LineNumberReader () {}

class StringUtil {
  interfaces_ () {
    return []
  }
  getClass () {
    return StringUtil
  }
  static chars (c, n) {
    const ch = new Array(n).fill(null);
    for (let i = 0; i < n; i++) {
      ch[i] = c;
    }
    return String(ch)
  };
  static getStackTrace () {
    if (arguments.length === 1) {
      const t = arguments[0];
      const os = new ByteArrayOutputStream();
      const ps = new PrintStream(os);
      t.printStackTrace(ps);
      return os.toString()
    } else if (arguments.length === 2) {
      const t = arguments[0];
      const depth = arguments[1];
      let stackTrace = '';
      const stringReader = new StringReader(StringUtil.getStackTrace(t));
      const lineNumberReader = new LineNumberReader(stringReader);
      for (let i = 0; i < depth; i++) {
        try {
          stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
        } catch (e) {
          if (e instanceof IOException) {
            Assert.shouldNeverReachHere();
          } else throw e
        } finally {}
      }
      return stackTrace
    }
  }
  static split (s, separator) {
    const separatorlen = separator.length;
    const tokenList = new ArrayList();
    let tmpString = '' + s;
    let pos = tmpString.indexOf(separator);
    while (pos >= 0) {
      const token = tmpString.substring(0, pos);
      tokenList.add(token);
      tmpString = tmpString.substring(pos + separatorlen);
      pos = tmpString.indexOf(separator);
    }
    if (tmpString.length > 0) tokenList.add(tmpString);
    const res = new Array(tokenList.size()).fill(null);
    for (let i = 0; i < res.length; i++) {
      res[i] = tokenList.get(i);
    }
    return res
  }
  static toString () {
    if (arguments.length === 1) {
      const d = arguments[0];
      return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d)
    }
  }
  static spaces (n) {
    return StringUtil.chars(' ', n)
  }
  static get NEWLINE () { return System.getProperty('line.separator') }
  static get SIMPLE_ORDINATE_FORMAT () { return new DecimalFormat('0.#') }
}

class CoordinateSequences {
  interfaces_ () {
    return []
  }
  getClass () {
    return CoordinateSequences
  }
  static copyCoord (src, srcPos, dest, destPos) {
    var minDim = Math.min(src.getDimension(), dest.getDimension());
    for (var dim = 0; dim < minDim; dim++) {
      dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
    }
  }
  static isRing (seq) {
    var n = seq.size();
    if (n === 0) return true
    if (n <= 3) return false
    return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)
  }
  static isEqual (cs1, cs2) {
    var cs1Size = cs1.size();
    var cs2Size = cs2.size();
    if (cs1Size !== cs2Size) return false
    var dim = Math.min(cs1.getDimension(), cs2.getDimension());
    for (var i = 0; i < cs1Size; i++) {
      for (var d = 0; d < dim; d++) {
        var v1 = cs1.getOrdinate(i, d);
        var v2 = cs2.getOrdinate(i, d);
        if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue
        if (Double.isNaN(v1) && Double.isNaN(v2)) continue
        return false
      }
    }
    return true
  }
  static extend (fact, seq, size) {
    var newseq = fact.create(size, seq.getDimension());
    var n = seq.size();
    CoordinateSequences.copy(seq, 0, newseq, 0, n);
    if (n > 0) {
      for (var i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
    }
    return newseq
  }
  static reverse (seq) {
    var last = seq.size() - 1;
    var mid = Math.trunc(last / 2);
    for (var i = 0; i <= mid; i++) {
      CoordinateSequences.swap(seq, i, last - i);
    }
  }
  static swap (seq, i, j) {
    if (i === j) return null
    for (var dim = 0; dim < seq.getDimension(); dim++) {
      var tmp = seq.getOrdinate(i, dim);
      seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
      seq.setOrdinate(j, dim, tmp);
    }
  }
  static copy (src, srcPos, dest, destPos, length) {
    for (var i = 0; i < length; i++) {
      CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
    }
  }
  static toString () {
    if (arguments.length === 1) {
      let cs = arguments[0];
      var size = cs.size();
      if (size === 0) return '()'
      var dim = cs.getDimension();
      var buf = new StringBuffer();
      buf.append('(');
      for (var i = 0; i < size; i++) {
        if (i > 0) buf.append(' ');
        for (var d = 0; d < dim; d++) {
          if (d > 0) buf.append(',');
          buf.append(StringUtil.toString(cs.getOrdinate(i, d)));
        }
      }
      buf.append(')');
      return buf.toString()
    }
  }
  static ensureValidRing (fact, seq) {
    var n = seq.size();
    if (n === 0) return seq
    if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4)
    var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
    if (isClosed) return seq
    return CoordinateSequences.createClosedRing(fact, seq, n + 1)
  }
  static createClosedRing (fact, seq, size) {
    var newseq = fact.create(size, seq.getDimension());
    var n = seq.size();
    CoordinateSequences.copy(seq, 0, newseq, 0, n);
    for (var i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);
    return newseq
  }
}

class LineString extends Geometry {
  constructor (points, factory) {
    super(factory);
    this._points = null;
    this.init(points);
  }
  computeEnvelopeInternal () {
    if (this.isEmpty()) {
      return new Envelope()
    }
    return this._points.expandEnvelope(new Envelope())
  }
  isRing () {
    return this.isClosed() && this.isSimple()
  }
  getSortIndex () {
    return Geometry.SORTINDEX_LINESTRING
  }
  getCoordinates () {
    return this._points.toCoordinateArray()
  }
  equalsExact () {
    if (arguments.length === 2) {
      const other = arguments[0];
      const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      var otherLineString = other;
      if (this._points.size() !== otherLineString._points.size()) {
        return false
      }
      for (var i = 0; i < this._points.size(); i++) {
        if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
          return false
        }
      }
      return true
    } else return Geometry.prototype.equalsExact.apply(this, arguments)
  }
  normalize () {
    for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
      var j = this._points.size() - 1 - i;
      if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {
        if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {
          CoordinateSequences.reverse(this._points);
        }
        return null
      }
    }
  }
  getCoordinate () {
    if (this.isEmpty()) return null
    return this._points.getCoordinate(0)
  }
  getBoundaryDimension () {
    if (this.isClosed()) {
      return Dimension.FALSE
    }
    return 0
  }
  isClosed () {
    if (this.isEmpty()) {
      return false
    }
    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
  }
  getEndPoint () {
    if (this.isEmpty()) {
      return null
    }
    return this.getPointN(this.getNumPoints() - 1)
  }
  getDimension () {
    return 1
  }
  getLength () {
    return CGAlgorithms.computeLength(this._points)
  }
  getNumPoints () {
    return this._points.size()
  }
  reverse () {
    const seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    const revLine = this.getFactory().createLineString(seq);
    return revLine
  }
  compareToSameClass () {
    if (arguments.length === 1) {
      const o = arguments[0];
      const line = o;
      let i = 0;
      let j = 0;
      while (i < this._points.size() && j < line._points.size()) {
        var comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
        if (comparison !== 0) {
          return comparison
        }
        i++;
        j++;
      }
      if (i < this._points.size()) {
        return 1
      }
      if (j < line._points.size()) {
        return -1
      }
      return 0
    } else if (arguments.length === 2) {
      const o = arguments[0];
      const comp = arguments[1];
      const line = o;
      return comp.compare(this._points, line._points)
    }
  }
  apply () {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      let filter = arguments[0];
      for (var i = 0; i < this._points.size(); i++) {
        filter.filter(this._points.getCoordinate(i));
      }
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      const filter = arguments[0];
      if (this._points.size() === 0) return null
      for (let i = 0; i < this._points.size(); i++) {
        filter.filter(this._points, i);
        if (filter.isDone()) break
      }
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      const filter = arguments[0];
      filter.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      const filter = arguments[0];
      filter.filter(this);
    }
  }
  getBoundary () {
    return new BoundaryOp(this).getBoundary()
  }
  isEquivalentClass (other) {
    return other instanceof LineString
  }
  clone () {
    var ls = Geometry.prototype.clone.call(this);
    ls._points = this._points.clone();
    return ls
  }
  getCoordinateN (n) {
    return this._points.getCoordinate(n)
  }
  getGeometryType () {
    return 'LineString'
  }
  copy () {
    return new LineString(this._points.copy(), this._factory)
  }
  getCoordinateSequence () {
    return this._points
  }
  isEmpty () {
    return this._points.size() === 0
  }
  init (points) {
    if (points === null) {
      points = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    if (points.size() === 1) {
      throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')
    }
    this._points = points;
  }
  isCoordinate (pt) {
    for (var i = 0; i < this._points.size(); i++) {
      if (this._points.getCoordinate(i).equals(pt)) {
        return true
      }
    }
    return false
  }
  getStartPoint () {
    if (this.isEmpty()) {
      return null
    }
    return this.getPointN(0)
  }
  getPointN (n) {
    return this.getFactory().createPoint(this._points.getCoordinate(n))
  }
  interfaces_ () {
    return [Lineal]
  }
  getClass () {
    return LineString
  }
  static get serialVersionUID () { return 3110669828065365560 }
}

class Puntal {
  interfaces_ () {
    return []
  }
  getClass () {
    return Puntal
  }
}

class Point extends Geometry {
  constructor (coordinates, factory) {
    super(factory);
    this._coordinates = coordinates || null;
    this.init(this._coordinates);
  }
  computeEnvelopeInternal () {
    if (this.isEmpty()) {
      return new Envelope()
    }
    var env = new Envelope();
    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
    return env
  }
  getSortIndex () {
    return Geometry.SORTINDEX_POINT
  }
  getCoordinates () {
    return this.isEmpty() ? [] : [this.getCoordinate()]
  }
  equalsExact () {
    if (arguments.length === 2) {
      const other = arguments[0];
      const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      if (this.isEmpty() && other.isEmpty()) {
        return true
      }
      if (this.isEmpty() !== other.isEmpty()) {
        return false
      }
      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)
    } else return Geometry.prototype.equalsExact.apply(this, arguments)
  }
  normalize () {}
  getCoordinate () {
    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null
  }
  getBoundaryDimension () {
    return Dimension.FALSE
  }
  getDimension () {
    return 0
  }
  getNumPoints () {
    return this.isEmpty() ? 0 : 1
  }
  reverse () {
    return this.copy()
  }
  getX () {
    if (this.getCoordinate() === null) {
      throw new Error('getX called on empty Point')
    }
    return this.getCoordinate().x
  }
  compareToSameClass () {
    if (arguments.length === 1) {
      const other = arguments[0];
      const point = other;
      return this.getCoordinate().compareTo(point.getCoordinate())
    } else if (arguments.length === 2) {
      const other = arguments[0];
      const comp = arguments[1];
      var point = other;
      return comp.compare(this._coordinates, point._coordinates)
    }
  }
  apply () {
    if (hasInterface(arguments[0], CoordinateFilter)) {
      let filter = arguments[0];
      if (this.isEmpty()) {
        return null
      }
      filter.filter(this.getCoordinate());
    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
      let filter = arguments[0];
      if (this.isEmpty()) return null
      filter.filter(this._coordinates, 0);
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(arguments[0], GeometryFilter)) {
      let filter = arguments[0];
      filter.filter(this);
    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
      let filter = arguments[0];
      filter.filter(this);
    }
  }
  getBoundary () {
    return this.getFactory().createGeometryCollection(null)
  }
  clone () {
    var p = Geometry.prototype.clone.call(this);
    p._coordinates = this._coordinates.clone();
    return p
  }
  getGeometryType () {
    return 'Point'
  }
  copy () {
    return new Point(this._coordinates.copy(), this._factory)
  }
  getCoordinateSequence () {
    return this._coordinates
  }
  getY () {
    if (this.getCoordinate() === null) {
      throw new Error('getY called on empty Point')
    }
    return this.getCoordinate().y
  }
  isEmpty () {
    return this._coordinates.size() === 0
  }
  init (coordinates) {
    if (coordinates === null) {
      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
    }
    Assert.isTrue(coordinates.size() <= 1);
    this._coordinates = coordinates;
  }
  isSimple () {
    return true
  }
  interfaces_ () {
    return [Puntal]
  }
  getClass () {
    return Point
  }
  static get serialVersionUID () { return 4902022702746614570 }
}

class Polygonal {
  interfaces_ () {
    return []
  }
  getClass () {
    return Polygonal
  }
}

class Polygon extends Geometry {
  constructor (shell, holes, factory) {
    super(factory);
    this._shell = null;
    this._holes = null;
    if (shell === null) {
      shell = this.getFactory().createLinearRing();
    }
    if (holes === null) {
      holes = [];
    }
    if (Geometry.hasNullElements(holes)) {
      throw new IllegalArgumentException('holes must not contain null elements')
    }
    if (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {
      throw new IllegalArgumentException('shell is empty but holes are not')
    }
    this._shell = shell;
    this._holes = holes;
  }
  computeEnvelopeInternal () {
    return this._shell.getEnvelopeInternal()
  }
  getSortIndex () {
    return Geometry.SORTINDEX_POLYGON
  }
  getCoordinates () {
    if (this.isEmpty()) {
      return []
    }
    var coordinates = new Array(this.getNumPoints()).fill(null);
    var k = -1;
    var shellCoordinates = this._shell.getCoordinates();
    for (var x = 0; x < shellCoordinates.length; x++) {
      k++;
      coordinates[k] = shellCoordinates[x];
    }
    for (var i = 0; i < this._holes.length; i++) {
      var childCoordinates = this._holes[i].getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates
  }
  getArea () {
    var area = 0.0;
    area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));
    for (var i = 0; i < this._holes.length; i++) {
      area -= Math.abs(CGAlgorithms.signedArea(this._holes[i].getCoordinateSequence()));
    }
    return area
  }
  isRectangle () {
    if (this.getNumInteriorRing() !== 0) return false
    if (this._shell === null) return false
    if (this._shell.getNumPoints() !== 5) return false
    const seq = this._shell.getCoordinateSequence();
    const env = this.getEnvelopeInternal();
    for (let i = 0; i < 5; i++) {
      const x = seq.getX(i);
      if (!(x === env.getMinX() || x === env.getMaxX())) return false
      const y = seq.getY(i);
      if (!(y === env.getMinY() || y === env.getMaxY())) return false
    }
    let prevX = seq.getX(0);
    let prevY = seq.getY(0);
    for (let i = 1; i <= 4; i++) {
      const x = seq.getX(i);
      const y = seq.getY(i);
      const xChanged = x !== prevX;
      const yChanged = y !== prevY;
      if (xChanged === yChanged) return false
      prevX = x;
      prevY = y;
    }
    return true
  }
  equalsExact () {
    if (arguments.length === 2) {
      const other = arguments[0];
      const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      const otherPolygon = other;
      const thisShell = this._shell;
      const otherPolygonShell = otherPolygon._shell;
      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
        return false
      }
      if (this._holes.length !== otherPolygon._holes.length) {
        return false
      }
      for (let i = 0; i < this._holes.length; i++) {
        if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
          return false
        }
      }
      return true
    } else return Geometry.prototype.equalsExact.apply(this, arguments)
  }
  normalize () {
    if (arguments.length === 0) {
      this.normalize(this._shell, true);
      for (let i = 0; i < this._holes.length; i++) {
        this.normalize(this._holes[i], false);
      }
      Arrays.sort(this._holes);
    } else if (arguments.length === 2) {
      const ring = arguments[0];
      const clockwise = arguments[1];
      if (ring.isEmpty()) {
        return null
      }
      const uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
      const minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());
      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
      if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {
        CoordinateArrays.reverse(ring.getCoordinates());
      }
    }
  }
  getCoordinate () {
    return this._shell.getCoordinate()
  }
  getNumInteriorRing () {
    return this._holes.length
  }
  getBoundaryDimension () {
    return 1
  }
  getDimension () {
    return 2
  }
  getLength () {
    let len = 0.0;
    len += this._shell.getLength();
    for (let i = 0; i < this._holes.length; i++) {
      len += this._holes[i].getLength();
    }
    return len
  }
  getNumPoints () {
    let numPoints = this._shell.getNumPoints();
    for (let i = 0; i < this._holes.length; i++) {
      numPoints += this._holes[i].getNumPoints();
    }
    return numPoints
  }
  reverse () {
    const poly = this.copy();
    poly._shell = this._shell.copy().reverse();
    poly._holes = new Array(this._holes.length).fill(null);
    for (let i = 0; i < this._holes.length; i++) {
      poly._holes[i] = this._holes[i].copy().reverse();
    }
    return poly
  }
  convexHull () {
    return this.getExteriorRing().convexHull()
  }
  compareToSameClass () {
    if (arguments.length === 1) {
      const o = arguments[0];
      const thisShell = this._shell;
      const otherShell = o._shell;
      return thisShell.compareToSameClass(otherShell)
    } else if (arguments.length === 2) {
      const o = arguments[0];
      const comp = arguments[1];
      const poly = o;
      const thisShell = this._shell;
      const otherShell = poly._shell;
      const shellComp = thisShell.compareToSameClass(otherShell, comp);
      if (shellComp !== 0) return shellComp
      const nHole1 = this.getNumInteriorRing();
      const nHole2 = poly.getNumInteriorRing();
      let i = 0;
      while (i < nHole1 && i < nHole2) {
        const thisHole = this.getInteriorRingN(i);
        const otherHole = poly.getInteriorRingN(i);
        const holeComp = thisHole.compareToSameClass(otherHole, comp);
        if (holeComp !== 0) return holeComp
        i++;
      }
      if (i < nHole1) return 1
      if (i < nHole2) return -1
      return 0
    }
  }
  apply (filter) {
    if (hasInterface(filter, CoordinateFilter)) {
      this._shell.apply(filter);
      for (let i = 0; i < this._holes.length; i++) {
        this._holes[i].apply(filter);
      }
    } else if (hasInterface(filter, CoordinateSequenceFilter)) {
      this._shell.apply(filter);
      if (!filter.isDone()) {
        for (let i = 0; i < this._holes.length; i++) {
          this._holes[i].apply(filter);
          if (filter.isDone()) break
        }
      }
      if (filter.isGeometryChanged()) this.geometryChanged();
    } else if (hasInterface(filter, GeometryFilter)) {
      filter.filter(this);
    } else if (hasInterface(filter, GeometryComponentFilter)) {
      filter.filter(this);
      this._shell.apply(filter);
      for (var i = 0; i < this._holes.length; i++) {
        this._holes[i].apply(filter);
      }
    }
  }
  getBoundary () {
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString()
    }
    const rings = new Array(this._holes.length + 1).fill(null);
    rings[0] = this._shell;
    for (let i = 0; i < this._holes.length; i++) {
      rings[i + 1] = this._holes[i];
    }
    if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence())
    return this.getFactory().createMultiLineString(rings)
  }
  clone () {
    const poly = Geometry.prototype.clone.call(this);
    poly._shell = this._shell.clone();
    poly._holes = new Array(this._holes.length).fill(null);
    for (let i = 0; i < this._holes.length; i++) {
      poly._holes[i] = this._holes[i].clone();
    }
    return poly
  }
  getGeometryType () {
    return 'Polygon'
  }
  copy () {
    const shell = this._shell.copy();
    const holes = new Array(this._holes.length).fill(null);
    for (let i = 0; i < holes.length; i++) {
      holes[i] = this._holes[i].copy();
    }
    return new Polygon(shell, holes, this._factory)
  }
  getExteriorRing () {
    return this._shell
  }
  isEmpty () {
    return this._shell.isEmpty()
  }
  getInteriorRingN (n) {
    return this._holes[n]
  }
  interfaces_ () {
    return [Polygonal]
  }
  getClass () {
    return Polygon
  }
  static get serialVersionUID () { return -3494792200821764533 }
}

class MultiPoint extends GeometryCollection {
  getSortIndex () {
    return Geometry.SORTINDEX_MULTIPOINT
  }
  isValid () {
    return true
  }
  equalsExact () {
    if (arguments.length === 2) {
      const other = arguments[0];
      const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      return GeometryCollection.prototype.equalsExact.call(this, other, tolerance)
    } else return GeometryCollection.prototype.equalsExact.apply(this, arguments)
  }
  getCoordinate () {
    if (arguments.length === 1) {
      const n = arguments[0];
      return this._geometries[n].getCoordinate()
    } else return GeometryCollection.prototype.getCoordinate.apply(this, arguments)
  }
  getBoundaryDimension () {
    return Dimension.FALSE
  }
  getDimension () {
    return 0
  }
  getBoundary () {
    return this.getFactory().createGeometryCollection(null)
  }
  getGeometryType () {
    return 'MultiPoint'
  }
  copy () {
    const points = new Array(this._geometries.length).fill(null);
    for (let i = 0; i < points.length; i++) {
      points[i] = this._geometries[i].copy();
    }
    return new MultiPoint(points, this._factory)
  }
  interfaces_ () {
    return [Puntal]
  }
  getClass () {
    return MultiPoint
  }
  static get serialVersionUID () { return -8048474874175355449 }
}

class LinearRing extends LineString {
  constructor (points, factory) {
    if (points instanceof Coordinate && factory instanceof GeometryFactory) {
      points = factory.getCoordinateSequenceFactory().create(points);
    }
    super(points, factory);
    this.validateConstruction();
  }
  getSortIndex () {
    return Geometry.SORTINDEX_LINEARRING
  }
  getBoundaryDimension () {
    return Dimension.FALSE
  }
  isClosed () {
    if (this.isEmpty()) {
      return true
    }
    return LineString.prototype.isClosed.call(this)
  }
  reverse () {
    var seq = this._points.copy();
    CoordinateSequences.reverse(seq);
    var rev = this.getFactory().createLinearRing(seq);
    return rev
  }
  validateConstruction () {
    if (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {
      throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring')
    }
    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {
      throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')
    }
  }
  getGeometryType () {
    return 'LinearRing'
  }
  copy () {
    return new LinearRing(this._points.copy(), this._factory)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return LinearRing
  }
  static get MINIMUM_VALID_SIZE () { return 4 }
  static get serialVersionUID () { return -4261142084085851829 }
}

class MultiPolygon extends GeometryCollection {
  getSortIndex () {
    return Geometry.SORTINDEX_MULTIPOLYGON
  }
  equalsExact () {
    if (arguments.length === 2) {
      const other = arguments[0];
      const tolerance = arguments[1];
      if (!this.isEquivalentClass(other)) {
        return false
      }
      return GeometryCollection.prototype.equalsExact.call(this, other, tolerance)
    } else return GeometryCollection.prototype.equalsExact.apply(this, arguments)
  }
  getBoundaryDimension () {
    return 1
  }
  getDimension () {
    return 2
  }
  reverse () {
    const n = this._geometries.length;
    const revGeoms = new Array(n).fill(null);
    for (let i = 0; i < this._geometries.length; i++) {
      revGeoms[i] = this._geometries[i].reverse();
    }
    return this.getFactory().createMultiPolygon(revGeoms)
  }
  getBoundary () {
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString()
    }
    const allRings = new ArrayList();
    for (let i = 0; i < this._geometries.length; i++) {
      const polygon = this._geometries[i];
      const rings = polygon.getBoundary();
      for (let j = 0; j < rings.getNumGeometries(); j++) {
        allRings.add(rings.getGeometryN(j));
      }
    }
    const allRingsArray = new Array(allRings.size()).fill(null);
    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))
  }
  getGeometryType () {
    return 'MultiPolygon'
  }
  copy () {
    const polygons = new Array(this._geometries.length).fill(null);
    for (let i = 0; i < polygons.length; i++) {
      polygons[i] = this._geometries[i].copy();
    }
    return new MultiPolygon(polygons, this._factory)
  }
  interfaces_ () {
    return [Polygonal]
  }
  getClass () {
    return MultiPolygon
  }
  static get serialVersionUID () { return -551033529766975875 }
}

class GeometryEditor {
  constructor (factory) {
    this._factory = factory || null;
    this._isUserDataCopied = false;
  }
  setCopyUserData (isUserDataCopied) {
    this._isUserDataCopied = isUserDataCopied;
  }
  edit (geometry, operation) {
    if (geometry === null) return null
    var result = this.editInternal(geometry, operation);
    if (this._isUserDataCopied) {
      result.setUserData(geometry.getUserData());
    }
    return result
  }
  editInternal (geometry, operation) {
    if (this._factory === null) this._factory = geometry.getFactory();
    if (geometry instanceof GeometryCollection) {
      return this.editGeometryCollection(geometry, operation)
    }
    if (geometry instanceof Polygon) {
      return this.editPolygon(geometry, operation)
    }
    if (geometry instanceof Point) {
      return operation.edit(geometry, this._factory)
    }
    if (geometry instanceof LineString) {
      return operation.edit(geometry, this._factory)
    }
    Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());
    return null
  }
  editGeometryCollection (collection, operation) {
    var collectionForType = operation.edit(collection, this._factory);
    var geometries = new ArrayList();
    for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
      var geometry = this.edit(collectionForType.getGeometryN(i), operation);
      if (geometry === null || geometry.isEmpty()) {
        continue
      }
      geometries.add(geometry);
    }
    if (collectionForType.getClass() === MultiPoint) {
      return this._factory.createMultiPoint(geometries.toArray([]))
    }
    if (collectionForType.getClass() === MultiLineString) {
      return this._factory.createMultiLineString(geometries.toArray([]))
    }
    if (collectionForType.getClass() === MultiPolygon) {
      return this._factory.createMultiPolygon(geometries.toArray([]))
    }
    return this._factory.createGeometryCollection(geometries.toArray([]))
  }
  editPolygon (polygon, operation) {
    var newPolygon = operation.edit(polygon, this._factory);
    if (newPolygon === null) newPolygon = this._factory.createPolygon(null);
    if (newPolygon.isEmpty()) {
      return newPolygon
    }
    var shell = this.edit(newPolygon.getExteriorRing(), operation);
    if (shell === null || shell.isEmpty()) {
      return this._factory.createPolygon()
    }
    var holes = new ArrayList();
    for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
      var hole = this.edit(newPolygon.getInteriorRingN(i), operation);
      if (hole === null || hole.isEmpty()) {
        continue
      }
      holes.add(hole);
    }
    return this._factory.createPolygon(shell, holes.toArray([]))
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryEditor
  }
  static GeometryEditorOperation () {}
  static get NoOpGeometryOperation () { return NoOpGeometryOperation }
  static get CoordinateOperation () { return CoordinateOperation }
  static get CoordinateSequenceOperation () { return CoordinateSequenceOperation }
}

class NoOpGeometryOperation {
  edit (geometry, factory) {
    return geometry
  }
  interfaces_ () {
    return [GeometryEditor.GeometryEditorOperation]
  }
  getClass () {
    return NoOpGeometryOperation
  }
}

class CoordinateOperation {
  edit (geometry, factory) {
    var coords = this.editCoordinates(geometry.getCoordinates(), geometry);
    if (coords === null) return geometry
    if (geometry instanceof LinearRing) {
      return factory.createLinearRing(coords)
    }
    if (geometry instanceof LineString) {
      return factory.createLineString(coords)
    }
    if (geometry instanceof Point) {
      if (coords.length > 0) {
        return factory.createPoint(coords[0])
      } else {
        return factory.createPoint()
      }
    }
    return geometry
  }
  interfaces_ () {
    return [GeometryEditor.GeometryEditorOperation]
  }
  getClass () {
    return CoordinateOperation
  }
}

class CoordinateSequenceOperation {
  edit (geometry, factory) {
    if (geometry instanceof LinearRing) {
      return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry))
    }
    if (geometry instanceof LineString) {
      return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry))
    }
    if (geometry instanceof Point) {
      return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry))
    }
    return geometry
  }
  interfaces_ () {
    return [GeometryEditor.GeometryEditorOperation]
  }
  getClass () {
    return CoordinateSequenceOperation
  }
}

class CoordinateArraySequence {
  constructor () {
    this._dimension = 3;
    this._coordinates = null;
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        this._coordinates = arguments[0];
        this._dimension = 3;
      } else if (Number.isInteger(arguments[0])) {
        const size = arguments[0];
        this._coordinates = new Array(size).fill(null);
        for (let i = 0; i < size; i++) {
          this._coordinates[i] = new Coordinate();
        }
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        const coordSeq = arguments[0];
        if (coordSeq === null) {
          this._coordinates = new Array(0).fill(null);
          return null
        }
        this._dimension = coordSeq.getDimension();
        this._coordinates = new Array(coordSeq.size()).fill(null);
        for (let i = 0; i < this._coordinates.length; i++) {
          this._coordinates[i] = coordSeq.getCoordinateCopy(i);
        }
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
        const coordinates = arguments[0];
        const dimension = arguments[1];
        this._coordinates = coordinates;
        this._dimension = dimension;
        if (coordinates === null) this._coordinates = new Array(0).fill(null);
      } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
        const size = arguments[0];
        const dimension = arguments[1];
        this._coordinates = new Array(size).fill(null);
        this._dimension = dimension;
        for (let i = 0; i < size; i++) {
          this._coordinates[i] = new Coordinate();
        }
      }
    }
  }
  setOrdinate (index, ordinateIndex, value) {
    switch (ordinateIndex) {
      case CoordinateSequence.X:
        this._coordinates[index].x = value;
        break
      case CoordinateSequence.Y:
        this._coordinates[index].y = value;
        break
      case CoordinateSequence.Z:
        this._coordinates[index].z = value;
        break
      default:
        throw new IllegalArgumentException('invalid ordinateIndex')
    }
  }
  size () {
    return this._coordinates.length
  }
  getOrdinate (index, ordinateIndex) {
    switch (ordinateIndex) {
      case CoordinateSequence.X:
        return this._coordinates[index].x
      case CoordinateSequence.Y:
        return this._coordinates[index].y
      case CoordinateSequence.Z:
        return this._coordinates[index].z
      default:
    }
    return Double.NaN
  }
  getCoordinate () {
    if (arguments.length === 1) {
      let i = arguments[0];
      return this._coordinates[i]
    } else if (arguments.length === 2) {
      const index = arguments[0];
      const coord = arguments[1];
      coord.x = this._coordinates[index].x;
      coord.y = this._coordinates[index].y;
      coord.z = this._coordinates[index].z;
    }
  }
  getCoordinateCopy (i) {
    return new Coordinate(this._coordinates[i])
  }
  getDimension () {
    return this._dimension
  }
  getX (index) {
    return this._coordinates[index].x
  }
  clone () {
    const cloneCoordinates = new Array(this.size()).fill(null);
    for (let i = 0; i < this._coordinates.length; i++) {
      cloneCoordinates[i] = this._coordinates[i].clone();
    }
    return new CoordinateArraySequence(cloneCoordinates, this._dimension)
  }
  expandEnvelope (env) {
    for (let i = 0; i < this._coordinates.length; i++) {
      env.expandToInclude(this._coordinates[i]);
    }
    return env
  }
  copy () {
    const cloneCoordinates = new Array(this.size()).fill(null);
    for (let i = 0; i < this._coordinates.length; i++) {
      cloneCoordinates[i] = this._coordinates[i].copy();
    }
    return new CoordinateArraySequence(cloneCoordinates, this._dimension)
  }
  toString () {
    if (this._coordinates.length > 0) {
      const strBuf = new StringBuffer(17 * this._coordinates.length);
      strBuf.append('(');
      strBuf.append(this._coordinates[0]);
      for (let i = 1; i < this._coordinates.length; i++) {
        strBuf.append(', ');
        strBuf.append(this._coordinates[i]);
      }
      strBuf.append(')');
      return strBuf.toString()
    } else {
      return '()'
    }
  }
  getY (index) {
    return this._coordinates[index].y
  }
  toCoordinateArray () {
    return this._coordinates
  }
  interfaces_ () {
    return [CoordinateSequence, Serializable]
  }
  getClass () {
    return CoordinateArraySequence
  }
  static get serialVersionUID () { return -915438501601840650 }
}

class CoordinateArraySequenceFactory {
  readResolve () {
    return CoordinateArraySequenceFactory.instance()
  }
  create () {
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        const coordinates = arguments[0];
        return new CoordinateArraySequence(coordinates)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        const coordSeq = arguments[0];
        return new CoordinateArraySequence(coordSeq)
      }
    } else if (arguments.length === 2) {
      const size = arguments[0];
      let dimension = arguments[1];
      if (dimension > 3) dimension = 3;
      if (dimension < 2) return new CoordinateArraySequence(size)
      return new CoordinateArraySequence(size, dimension)
    }
  }
  interfaces_ () {
    return [CoordinateSequenceFactory, Serializable]
  }
  getClass () {
    return CoordinateArraySequenceFactory
  }
  static instance () {
    return CoordinateArraySequenceFactory.instanceObject
  }

  static get serialVersionUID () { return -4099577099607551657 }
  static get instanceObject () { return new CoordinateArraySequenceFactory() }
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html
 *
 * @extends {javascript.util.Map}
 * @constructor
 * @private
 */
class HashMap extends Map$1 {
  constructor () {
    super();
    this.map_ = new Map();
  }
  /**
   * @override
   */
  get (key) {
    return this.map_.get(key) || null
  }

  /**
   * @override
   */
  put (key, value) {
    this.map_.set(key, value);
    return value
  }

  /**
   * @override
   */
  values () {
    const arrayList = new ArrayList();
    const it = this.map_.values();
    let o = it.next();
    while (!o.done) {
      arrayList.add(o.value);
      o = it.next();
    }
    return arrayList
  }

  /**
   * @override
   */
  entrySet () {
    const hashSet = new HashSet();
    this.map_.entries().forEach(entry => hashSet.add(entry));
    return hashSet
  }

  /**
   * @override
   */
  size () {
    return this.map_.size()
  }
}

class PrecisionModel {
  constructor () {
    this._modelType = null;
    this._scale = null;
    if (arguments.length === 0) {
      this._modelType = PrecisionModel.FLOATING;
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Type) {
        let modelType = arguments[0];
        this._modelType = modelType;
        if (modelType === PrecisionModel.FIXED) {
          this.setScale(1.0);
        }
      } else if (typeof arguments[0] === 'number') {
        let scale = arguments[0];
        this._modelType = PrecisionModel.FIXED;
        this.setScale(scale);
      } else if (arguments[0] instanceof PrecisionModel) {
        let pm = arguments[0];
        this._modelType = pm._modelType;
        this._scale = pm._scale;
      }
    }
  }
  equals (other) {
    if (!(other instanceof PrecisionModel)) {
      return false
    }
    var otherPrecisionModel = other;
    return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale
  }
  compareTo (o) {
    var other = o;
    var sigDigits = this.getMaximumSignificantDigits();
    var otherSigDigits = other.getMaximumSignificantDigits();
    return new Integer(sigDigits).compareTo(new Integer(otherSigDigits))
  }
  getScale () {
    return this._scale
  }
  isFloating () {
    return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE
  }
  getType () {
    return this._modelType
  }
  toString () {
    var description = 'UNKNOWN';
    if (this._modelType === PrecisionModel.FLOATING) {
      description = 'Floating';
    } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
      description = 'Floating-Single';
    } else if (this._modelType === PrecisionModel.FIXED) {
      description = 'Fixed (Scale=' + this.getScale() + ')';
    }
    return description
  }
  makePrecise () {
    if (typeof arguments[0] === 'number') {
      let val = arguments[0];
      if (Double.isNaN(val)) return val
      if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
        var floatSingleVal = val;
        return floatSingleVal
      }
      if (this._modelType === PrecisionModel.FIXED) {
        return Math.round(val * this._scale) / this._scale
      }
      return val
    } else if (arguments[0] instanceof Coordinate) {
      let coord = arguments[0];
      if (this._modelType === PrecisionModel.FLOATING) return null
      coord.x = this.makePrecise(coord.x);
      coord.y = this.makePrecise(coord.y);
    }
  }
  getMaximumSignificantDigits () {
    var maxSigDigits = 16;
    if (this._modelType === PrecisionModel.FLOATING) {
      maxSigDigits = 16;
    } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
      maxSigDigits = 6;
    } else if (this._modelType === PrecisionModel.FIXED) {
      maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
    }
    return maxSigDigits
  }
  setScale (scale) {
    this._scale = Math.abs(scale);
  }
  interfaces_ () {
    return [Serializable, Comparable]
  }
  getClass () {
    return PrecisionModel
  }
  static mostPrecise (pm1, pm2) {
    if (pm1.compareTo(pm2) >= 0) return pm1
    return pm2
  }
  static get serialVersionUID () { return 7777263578777803835 }
  static get maximumPreciseValue () { return 9007199254740992.0 }
}

class Type {
  constructor (name) {
    this._name = name || null;
    Type.nameToTypeMap.put(name, this);
  }
  readResolve () {
    return Type.nameToTypeMap.get(this._name)
  }
  toString () {
    return this._name
  }
  interfaces_ () {
    return [Serializable]
  }
  getClass () {
    return Type
  }
  static get serialVersionUID () { return -5528602631731589822 }
  static get nameToTypeMap () { return new HashMap() }
}

PrecisionModel.Type = Type;
PrecisionModel.FIXED = new Type('FIXED');
PrecisionModel.FLOATING = new Type('FLOATING');
PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');

class GeometryFactory {
  constructor () {
    this._precisionModel = new PrecisionModel();
    this._SRID = 0;
    this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();

    if (arguments.length === 0) {
    } else if (arguments.length === 1) {
      if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
        this._coordinateSequenceFactory = arguments[0];
      } else if (arguments[0] instanceof PrecisionModel) {
        this._precisionModel = arguments[0];
      }
    } else if (arguments.length === 2) {
      this._precisionModel = arguments[0];
      this._SRID = arguments[1];
    } else if (arguments.length === 3) {
      this._precisionModel = arguments[0];
      this._SRID = arguments[1];
      this._coordinateSequenceFactory = arguments[2];
    }
  }
  toGeometry (envelope) {
    if (envelope.isNull()) {
      return this.createPoint(null)
    }
    if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
      return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))
    }
    if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
      return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])
    }
    return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)
  }
  createLineString (coordinates) {
    if (!coordinates) return new LineString(this.getCoordinateSequenceFactory().create([]), this)
    else if (coordinates instanceof Array) return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this)
    else if (hasInterface(coordinates, CoordinateSequence)) return new LineString(coordinates, this)
  }
  createMultiLineString () {
    if (arguments.length === 0) {
      return new MultiLineString(null, this)
    } else if (arguments.length === 1) {
      let lineStrings = arguments[0];
      return new MultiLineString(lineStrings, this)
    }
  }
  buildGeometry (geomList) {
    var geomClass = null;
    var isHeterogeneous = false;
    var hasGeometryCollection = false;
    for (var i = geomList.iterator(); i.hasNext();) {
      var geom = i.next();
      var partClass = geom.getClass();
      if (geomClass === null) {
        geomClass = partClass;
      }
      if (partClass !== geomClass) {
        isHeterogeneous = true;
      }
      if (geom.isGeometryCollectionOrDerived()) hasGeometryCollection = true;
    }
    if (geomClass === null) {
      return this.createGeometryCollection()
    }
    if (isHeterogeneous || hasGeometryCollection) {
      return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))
    }
    var geom0 = geomList.iterator().next();
    var isCollection = geomList.size() > 1;
    if (isCollection) {
      if (geom0 instanceof Polygon) {
        return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))
      } else if (geom0 instanceof LineString) {
        return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))
      } else if (geom0 instanceof Point) {
        return this.createMultiPoint(GeometryFactory.toPointArray(geomList))
      }
      Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());
    }
    return geom0
  }
  createMultiPointFromCoords (coordinates) {
    return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
  }
  createPoint () {
    if (arguments.length === 0) {
      return this.createPoint(this.getCoordinateSequenceFactory().create([]))
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        let coordinate = arguments[0];
        return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        let coordinates = arguments[0];
        return new Point(coordinates, this)
      }
    }
  }
  getCoordinateSequenceFactory () {
    return this._coordinateSequenceFactory
  }
  createPolygon () {
    if (arguments.length === 0) {
      return new Polygon(null, null, this)
    } else if (arguments.length === 1) {
      if (hasInterface(arguments[0], CoordinateSequence)) {
        let coordinates = arguments[0];
        return this.createPolygon(this.createLinearRing(coordinates))
      } else if (arguments[0] instanceof Array) {
        let coordinates = arguments[0];
        return this.createPolygon(this.createLinearRing(coordinates))
      } else if (arguments[0] instanceof LinearRing) {
        let shell = arguments[0];
        return this.createPolygon(shell, null)
      }
    } else if (arguments.length === 2) {
      const shell = arguments[0];
      const holes = arguments[1];
      return new Polygon(shell, holes, this)
    }
  }
  getSRID () {
    return this._SRID
  }
  createGeometryCollection () {
    if (arguments.length === 0) {
      return new GeometryCollection(null, this)
    } else if (arguments.length === 1) {
      let geometries = arguments[0];
      return new GeometryCollection(geometries, this)
    }
  }
  createGeometry (g) {
    var editor = new GeometryEditor(this);
    return editor.edit(g, {
      edit: function () {
        if (arguments.length === 2) {
          const coordSeq = arguments[0];
          // const geometry = arguments[1]
          return this._coordinateSequenceFactory.create(coordSeq)
        }
      }
    })
  }
  getPrecisionModel () {
    return this._precisionModel
  }
  createLinearRing () {
    if (arguments.length === 0) {
      return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        let coordinates = arguments[0];
        return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        let coordinates = arguments[0];
        return new LinearRing(coordinates, this)
      }
    }
  }
  createMultiPolygon () {
    if (arguments.length === 0) {
      return new MultiPolygon(null, this)
    } else if (arguments.length === 1) {
      let polygons = arguments[0];
      return new MultiPolygon(polygons, this)
    }
  }
  createMultiPoint () {
    if (arguments.length === 0) {
      return new MultiPoint(null, this)
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        let point = arguments[0];
        return new MultiPoint(point, this)
      } else if (arguments[0] instanceof Array) {
        let coordinates = arguments[0];
        return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        let coordinates = arguments[0];
        if (coordinates === null) {
          return this.createMultiPoint(new Array(0).fill(null))
        }
        var points = new Array(coordinates.size()).fill(null);
        for (var i = 0; i < coordinates.size(); i++) {
          var ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());
          CoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);
          points[i] = this.createPoint(ptSeq);
        }
        return this.createMultiPoint(points)
      }
    }
  }
  interfaces_ () {
    return [Serializable]
  }
  getClass () {
    return GeometryFactory
  }
  static toMultiPolygonArray (multiPolygons) {
    var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
    return multiPolygons.toArray(multiPolygonArray)
  }
  static toGeometryArray (geometries) {
    if (geometries === null) return null
    var geometryArray = new Array(geometries.size()).fill(null);
    return geometries.toArray(geometryArray)
  }
  static getDefaultCoordinateSequenceFactory () {
    return CoordinateArraySequenceFactory.instance()
  }
  static toMultiLineStringArray (multiLineStrings) {
    var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
    return multiLineStrings.toArray(multiLineStringArray)
  }
  static toLineStringArray (lineStrings) {
    var lineStringArray = new Array(lineStrings.size()).fill(null);
    return lineStrings.toArray(lineStringArray)
  }
  static toMultiPointArray (multiPoints) {
    var multiPointArray = new Array(multiPoints.size()).fill(null);
    return multiPoints.toArray(multiPointArray)
  }
  static toLinearRingArray (linearRings) {
    var linearRingArray = new Array(linearRings.size()).fill(null);
    return linearRings.toArray(linearRingArray)
  }
  static toPointArray (points) {
    var pointArray = new Array(points.size()).fill(null);
    return points.toArray(pointArray)
  }
  static toPolygonArray (polygons) {
    var polygonArray = new Array(polygons.size()).fill(null);
    return polygons.toArray(polygonArray)
  }
  static createPointFromInternalCoord (coord, exemplar) {
    exemplar.getPrecisionModel().makePrecise(coord);
    return exemplar.getFactory().createPoint(coord)
  }
  static get serialVersionUID () { return -6820524753094095635 }
}

const geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

/**
 * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/**
 * Create a new parser for GeoJSON
 *
 * @param {GeometryFactory} geometryFactory
 * @return An instance of GeoJsonParser.
 * @constructor
 * @private
 */
class GeoJSONParser {
  constructor (geometryFactory) {
    this.geometryFactory = geometryFactory || new GeometryFactory();
  }
  /**
   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
   *
   * @param {}
   *          A GeoJSON object.
   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
   * @private
   */
  read (json) {
    let obj;
    if (typeof json === 'string') {
      obj = JSON.parse(json);
    } else {
      obj = json;
    }

    const type = obj.type;

    if (!parse[type]) {
      throw new Error('Unknown GeoJSON type: ' + obj.type)
    }

    if (geometryTypes.indexOf(type) !== -1) {
      return parse[type].apply(this, [obj.coordinates])
    } else if (type === 'GeometryCollection') {
      return parse[type].apply(this, [obj.geometries])
    }

    // feature or feature collection
    return parse[type].apply(this, [obj])
  }

  /**
   * Serialize a Geometry object into GeoJSON
   *
   * @param {Geometry}
   *          geometry A Geometry or array of Geometries.
   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
   * @private
   */
  write (geometry) {
    const type = geometry.getGeometryType();

    if (!extract[type]) {
      throw new Error('Geometry is not supported')
    }

    return extract[type].apply(this, [geometry])
  }
}

const parse = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function (obj) {
    const feature = {};

    // copy features
    for (let key in obj) {
      feature[key] = obj[key];
    }

    // parse geometry
    if (obj.geometry) {
      const type = obj.geometry.type;
      if (!parse[type]) {
        throw new Error('Unknown GeoJSON type: ' + obj.type)
      }
      feature.geometry = this.read(obj.geometry);
    }

    // bbox
    if (obj.bbox) {
      feature.bbox = parse.bbox.apply(this, [obj.bbox]);
    }

    return feature
  },

  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function (obj) {
    const featureCollection = {};

    if (obj.features) {
      featureCollection.features = [];

      for (let i = 0; i < obj.features.length; ++i) {
        featureCollection.features.push(this.read(obj.features[i]));
      }
    }

    if (obj.bbox) {
      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);
    }

    return featureCollection
  },

  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function (array) {
    const coordinates = [];
    for (let i = 0; i < array.length; ++i) {
      const sub = array[i];
      coordinates.push(new Coordinate(sub[0], sub[1]));
    }
    return coordinates
  },

  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function (array) {
    return this.geometryFactory.createLinearRing([
      new Coordinate(array[0], array[1]),
      new Coordinate(array[2], array[1]),
      new Coordinate(array[2], array[3]),
      new Coordinate(array[0], array[3]),
      new Coordinate(array[0], array[1])
    ])
  },

  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function (array) {
    const coordinate = new Coordinate(array[0], array[1]);
    return this.geometryFactory.createPoint(coordinate)
  },

  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function (array) {
    const points = [];
    for (let i = 0; i < array.length; ++i) {
      points.push(parse.Point.apply(this, [array[i]]));
    }
    return this.geometryFactory.createMultiPoint(points)
  },

  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function (array) {
    const coordinates = parse.coordinates.apply(this, [array]);
    return this.geometryFactory.createLineString(coordinates)
  },

  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function (array) {
    const lineStrings = [];
    for (let i = 0; i < array.length; ++i) {
      lineStrings.push(parse.LineString.apply(this, [array[i]]));
    }
    return this.geometryFactory.createMultiLineString(lineStrings)
  },

  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function (array) {
    const shellCoordinates = parse.coordinates.apply(this, [array[0]]);
    const shell = this.geometryFactory.createLinearRing(shellCoordinates);
    const holes = [];
    for (let i = 1; i < array.length; ++i) {
      var hole = array[i];
      var coordinates = parse.coordinates.apply(this, [hole]);
      var linearRing = this.geometryFactory.createLinearRing(coordinates);
      holes.push(linearRing);
    }
    return this.geometryFactory.createPolygon(shell, holes)
  },

  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function (array) {
    const polygons = [];
    for (let i = 0; i < array.length; ++i) {
      const polygon = array[i];
      polygons.push(parse.Polygon.apply(this, [polygon]));
    }
    return this.geometryFactory.createMultiPolygon(polygons)
  },

  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function (array) {
    const geometries = [];
    for (let i = 0; i < array.length; ++i) {
      const geometry = array[i];
      geometries.push(this.read(geometry));
    }
    return this.geometryFactory.createGeometryCollection(geometries)
  }
};

const extract = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function (coordinate) {
    return [coordinate.x, coordinate.y]
  },

  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function (point) {
    const array = extract.coordinate.apply(this, [point.getCoordinate()]);
    return {
      type: 'Point',
      coordinates: array
    }
  },

  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function (multipoint) {
    const array = [];
    for (let i = 0; i < multipoint._geometries.length; ++i) {
      const point = multipoint._geometries[i];
      const geoJson = extract.Point.apply(this, [point]);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPoint',
      coordinates: array
    }
  },

  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function (linestring) {
    const array = [];
    const coordinates = linestring.getCoordinates();
    for (let i = 0; i < coordinates.length; ++i) {
      const coordinate = coordinates[i];
      array.push(extract.coordinate.apply(this, [coordinate]));
    }
    return {
      type: 'LineString',
      coordinates: array
    }
  },

  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function (multilinestring) {
    const array = [];
    for (let i = 0; i < multilinestring._geometries.length; ++i) {
      const linestring = multilinestring._geometries[i];
      const geoJson = extract.LineString.apply(this, [linestring]);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiLineString',
      coordinates: array
    }
  },

  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function (polygon) {
    const array = [];
    const shellGeoJson = extract.LineString.apply(this, [polygon._shell]);
    array.push(shellGeoJson.coordinates);
    for (let i = 0; i < polygon._holes.length; ++i) {
      const hole = polygon._holes[i];
      const holeGeoJson = extract.LineString.apply(this, [hole]);
      array.push(holeGeoJson.coordinates);
    }
    return {
      type: 'Polygon',
      coordinates: array
    }
  },

  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function (multipolygon) {
    const array = [];
    for (let i = 0; i < multipolygon._geometries.length; ++i) {
      const polygon = multipolygon._geometries[i];
      const geoJson = extract.Polygon.apply(this, [polygon]);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPolygon',
      coordinates: array
    }
  },

  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function (collection) {
    const array = [];
    for (let i = 0; i < collection._geometries.length; ++i) {
      const geometry = collection._geometries[i];
      const type = geometry.getGeometryType();
      array.push(extract[type].apply(this, [geometry]));
    }
    return {
      type: 'GeometryCollection',
      geometries: array
    }
  }
};

/**
 * Converts a geometry in GeoJSON to a {@link Geometry}.
 */

/**
 * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
class GeoJSONReader {
  constructor (geometryFactory) {
    this.geometryFactory = geometryFactory || new GeometryFactory();
    this.precisionModel = this.geometryFactory.getPrecisionModel();
    this.parser = new GeoJSONParser(this.geometryFactory);
  }
  /**
   * Reads a GeoJSON representation of a {@link Geometry}
   *
   * Will also parse GeoJSON Features/FeatureCollections as custom objects.
   *
   * @param {Object|String} geoJson a GeoJSON Object or String.
   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>
   * @memberof GeoJSONReader
   */
  read (geoJson) {
    var geometry = this.parser.read(geoJson);

    if (this.precisionModel.getType() === PrecisionModel.FIXED) {
      this.reducePrecision(geometry);
    }

    return geometry
  }

  // NOTE: this is a hack
  reducePrecision (geometry) {
    var i, len;

    if (geometry.coordinate) {
      this.precisionModel.makePrecise(geometry.coordinate);
    } else if (geometry.points) {
      for (i = 0, len = geometry.points.length; i < len; i++) {
        this.precisionModel.makePrecise(geometry.points[i]);
      }
    } else if (geometry.geometries) {
      for (i = 0, len = geometry.geometries.length; i < len; i++) {
        this.reducePrecision(geometry.geometries[i]);
      }
    }
  }
}

/**
 * @module GeoJSONWriter
 */

/**
 * Writes the GeoJSON representation of a {@link Geometry}. The
 * The GeoJSON format is defined <A
 * HREF="http://geojson.org/geojson-spec.html">here</A>.
 */

/**
 * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
class GeoJSONWriter {
  constructor () {
    this.parser = new GeoJSONParser(this.geometryFactory);
  }
  /**
   * Converts a <code>Geometry</code> to its GeoJSON representation.
   *
   * @param {Geometry}
   *          geometry a <code>Geometry</code> to process.
   * @return {Object} The GeoJSON representation of the Geometry.
   * @memberof GeoJSONWriter
   */
  write (geometry) {
    return this.parser.write(geometry)
  }
}

/* eslint-disable no-undef */

// io

class Position {
  interfaces_ () {
    return []
  }
  getClass () {
    return Position
  }
  static opposite (position) {
    if (position === Position.LEFT) return Position.RIGHT
    if (position === Position.RIGHT) return Position.LEFT
    return position
  }
  static get ON () { return 0 }
  static get LEFT () { return 1 }
  static get RIGHT () { return 2 }
}

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function EmptyStackException (message) {
  this.message = message || '';
}
EmptyStackException.prototype = new Error();

/**
 * @type {string}
 */
EmptyStackException.prototype.name = 'EmptyStackException';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html
 *
 * @extends {List}
 * @constructor
 * @private
 */
function Stack () {
  /**
   * @type {Array}
   * @private
   */
  this.array_ = [];
}
Stack.prototype = new List();

/**
 * @override
 */
Stack.prototype.add = function (e) {
  this.array_.push(e);
  return true
};

/**
 * @override
 */
Stack.prototype.get = function (index) {
  if (index < 0 || index >= this.size()) {
    throw new Error()
  }

  return this.array_[index]
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.push = function (e) {
  this.array_.push(e);
  return e
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.pop = function (e) {
  if (this.array_.length === 0) {
    throw new EmptyStackException()
  }

  return this.array_.pop()
};

/**
 * Looks at the object at the top of this stack without removing it from the
 * stack.
 * @return {Object}
 */
Stack.prototype.peek = function () {
  if (this.array_.length === 0) {
    throw new EmptyStackException()
  }

  return this.array_[this.array_.length - 1]
};

/**
 * Tests if this stack is empty.
 * @return {boolean} true if and only if this stack contains no items; false
 *         otherwise.
 */
Stack.prototype.empty = function () {
  if (this.array_.length === 0) {
    return true
  } else {
    return false
  }
};

/**
 * @return {boolean}
 */
Stack.prototype.isEmpty = function () {
  return this.empty()
};

/**
 * Returns the 1-based position where an object is on this stack. If the object
 * o occurs as an item in this stack, this method returns the distance from the
 * top of the stack of the occurrence nearest the top of the stack; the topmost
 * item on the stack is considered to be at distance 1. The equals method is
 * used to compare o to the items in this stack.
 *
 * NOTE: does not currently actually use equals. (=== is used)
 *
 * @param {Object} o
 * @return {number} the 1-based position from the top of the stack where the
 *         object is located; the return value -1 indicates that the object is
 *         not on the stack.
 */
Stack.prototype.search = function (o) {
  return this.array_.indexOf(o)
};

/**
 * @return {number}
 * @export
 */
Stack.prototype.size = function () {
  return this.array_.length
};

/**
 * @return {Array}
 */
Stack.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array
};

class RightmostEdgeFinder {
  constructor () {
    this._minIndex = -1;
    this._minCoord = null;
    this._minDe = null;
    this._orientedDe = null;
  }
  getCoordinate () {
    return this._minCoord
  }
  getRightmostSide (de, index) {
    var side = this.getRightmostSideOfSegment(de, index);
    if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);
    if (side < 0) {
      this._minCoord = null;
      this.checkForRightmostCoordinate(de);
    }
    return side
  }
  findRightmostEdgeAtVertex () {
    var pts = this._minDe.getEdge().getCoordinates();
    Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');
    var pPrev = pts[this._minIndex - 1];
    var pNext = pts[this._minIndex + 1];
    var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);
    var usePrev = false;
    if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {
      usePrev = true;
    } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {
      usePrev = true;
    }
    if (usePrev) {
      this._minIndex = this._minIndex - 1;
    }
  }
  getRightmostSideOfSegment (de, i) {
    var e = de.getEdge();
    var coord = e.getCoordinates();
    if (i < 0 || i + 1 >= coord.length) return -1
    if (coord[i].y === coord[i + 1].y) return -1
    var pos = Position.LEFT;
    if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;
    return pos
  }
  getEdge () {
    return this._orientedDe
  }
  checkForRightmostCoordinate (de) {
    var coord = de.getEdge().getCoordinates();
    for (var i = 0; i < coord.length - 1; i++) {
      if (this._minCoord === null || coord[i].x > this._minCoord.x) {
        this._minDe = de;
        this._minIndex = i;
        this._minCoord = coord[i];
      }
    }
  }
  findRightmostEdgeAtNode () {
    var node = this._minDe.getNode();
    var star = node.getEdges();
    this._minDe = star.getRightmostEdge();
    if (!this._minDe.isForward()) {
      this._minDe = this._minDe.getSym();
      this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
    }
  }
  findEdge (dirEdgeList) {
    for (var i = dirEdgeList.iterator(); i.hasNext();) {
      var de = i.next();
      if (!de.isForward()) continue
      this.checkForRightmostCoordinate(de);
    }
    Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');
    if (this._minIndex === 0) {
      this.findRightmostEdgeAtNode();
    } else {
      this.findRightmostEdgeAtVertex();
    }
    this._orientedDe = this._minDe;
    var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
    if (rightmostSide === Position.LEFT) {
      this._orientedDe = this._minDe.getSym();
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return RightmostEdgeFinder
  }
}

class TopologyException extends RuntimeException {
  constructor (msg, pt) {
    super(TopologyException.msgWithCoord(msg, pt));
    this.pt = pt ? new Coordinate(pt) : null;
    this.name = 'TopologyException';
  }
  getCoordinate () {
    return this.pt
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return TopologyException
  }
  static msgWithCoord (msg, pt) {
    if (!pt) return msg + ' [ ' + pt + ' ]'
    return msg
  }
}

class LinkedList {
  constructor () {
    this.array_ = [];
  }
  addLast (e) {
    this.array_.push(e);
  }
  removeFirst () {
    return this.array_.shift()
  }
  isEmpty () {
    return this.array_.length === 0
  }
}

class BufferSubgraph {
  constructor () {
    this._finder = null;
    this._dirEdgeList = new ArrayList();
    this._nodes = new ArrayList();
    this._rightMostCoord = null;
    this._env = null;
    this._finder = new RightmostEdgeFinder();
  }
  clearVisitedEdges () {
    for (const it = this._dirEdgeList.iterator(); it.hasNext();) {
      const de = it.next();
      de.setVisited(false);
    }
  }
  getRightmostCoordinate () {
    return this._rightMostCoord
  }
  computeNodeDepth (n) {
    let startEdge = null;
    for (const i = n.getEdges().iterator(); i.hasNext();) {
      const de = i.next();
      if (de.isVisited() || de.getSym().isVisited()) {
        startEdge = de;
        break
      }
    }
    if (startEdge === null) throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate())
    n.getEdges().computeDepths(startEdge);
    for (const i = n.getEdges().iterator(); i.hasNext();) {
      const de = i.next();
      de.setVisited(true);
      this.copySymDepths(de);
    }
  }
  computeDepth (outsideDepth) {
    this.clearVisitedEdges();
    const de = this._finder.getEdge();
    // const n = de.getNode()
    // const label = de.getLabel()
    de.setEdgeDepths(Position.RIGHT, outsideDepth);
    this.copySymDepths(de);
    this.computeDepths(de);
  }
  create (node) {
    this.addReachable(node);
    this._finder.findEdge(this._dirEdgeList);
    this._rightMostCoord = this._finder.getCoordinate();
  }
  findResultEdges () {
    for (const it = this._dirEdgeList.iterator(); it.hasNext();) {
      const de = it.next();
      if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
        de.setInResult(true);
      }
    }
  }
  computeDepths (startEdge) {
    const nodesVisited = new HashSet();
    const nodeQueue = new LinkedList();
    const startNode = startEdge.getNode();
    nodeQueue.addLast(startNode);
    nodesVisited.add(startNode);
    startEdge.setVisited(true);
    while (!nodeQueue.isEmpty()) {
      const n = nodeQueue.removeFirst();
      nodesVisited.add(n);
      this.computeNodeDepth(n);
      for (const i = n.getEdges().iterator(); i.hasNext();) {
        const de = i.next();
        const sym = de.getSym();
        if (sym.isVisited()) continue
        const adjNode = sym.getNode();
        if (!nodesVisited.contains(adjNode)) {
          nodeQueue.addLast(adjNode);
          nodesVisited.add(adjNode);
        }
      }
    }
  }
  compareTo (o) {
    const graph = o;
    if (this._rightMostCoord.x < graph._rightMostCoord.x) {
      return -1
    }
    if (this._rightMostCoord.x > graph._rightMostCoord.x) {
      return 1
    }
    return 0
  }
  getEnvelope () {
    if (this._env === null) {
      const edgeEnv = new Envelope();
      for (const it = this._dirEdgeList.iterator(); it.hasNext();) {
        const dirEdge = it.next();
        const pts = dirEdge.getEdge().getCoordinates();
        for (let i = 0; i < pts.length - 1; i++) {
          edgeEnv.expandToInclude(pts[i]);
        }
      }
      this._env = edgeEnv;
    }
    return this._env
  }
  addReachable (startNode) {
    const nodeStack = new Stack();
    nodeStack.add(startNode);
    while (!nodeStack.empty()) {
      const node = nodeStack.pop();
      this.add(node, nodeStack);
    }
  }
  copySymDepths (de) {
    const sym = de.getSym();
    sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
    sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
  }
  add (node, nodeStack) {
    node.setVisited(true);
    this._nodes.add(node);
    for (const i = node.getEdges().iterator(); i.hasNext();) {
      const de = i.next();
      this._dirEdgeList.add(de);
      const sym = de.getSym();
      const symNode = sym.getNode();
      if (!symNode.isVisited()) nodeStack.push(symNode);
    }
  }
  getNodes () {
    return this._nodes
  }
  getDirectedEdges () {
    return this._dirEdgeList
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return BufferSubgraph
  }
}

class TopologyLocation {
  constructor () {
    this.location = null;
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        const location = arguments[0];
        this.init(location.length);
      } else if (Number.isInteger(arguments[0])) {
        const on = arguments[0];
        this.init(1);
        this.location[Position.ON] = on;
      } else if (arguments[0] instanceof TopologyLocation) {
        const gl = arguments[0];
        this.init(gl.location.length);
        if (gl !== null) {
          for (let i = 0; i < this.location.length; i++) {
            this.location[i] = gl.location[i];
          }
        }
      }
    } else if (arguments.length === 3) {
      const on = arguments[0];
      const left = arguments[1];
      const right = arguments[2];
      this.init(3);
      this.location[Position.ON] = on;
      this.location[Position.LEFT] = left;
      this.location[Position.RIGHT] = right;
    }
  }
  setAllLocations (locValue) {
    for (let i = 0; i < this.location.length; i++) {
      this.location[i] = locValue;
    }
  }
  isNull () {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] !== Location.NONE) return false
    }
    return true
  }
  setAllLocationsIfNull (locValue) {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] === Location.NONE) this.location[i] = locValue;
    }
  }
  isLine () {
    return this.location.length === 1
  }
  merge (gl) {
    if (gl.location.length > this.location.length) {
      const newLoc = new Array(3).fill(null);
      newLoc[Position.ON] = this.location[Position.ON];
      newLoc[Position.LEFT] = Location.NONE;
      newLoc[Position.RIGHT] = Location.NONE;
      this.location = newLoc;
    }
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];
    }
  }
  getLocations () {
    return this.location
  }
  flip () {
    if (this.location.length <= 1) return null
    const temp = this.location[Position.LEFT];
    this.location[Position.LEFT] = this.location[Position.RIGHT];
    this.location[Position.RIGHT] = temp;
  }
  toString () {
    const buf = new StringBuffer();
    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));
    buf.append(Location.toLocationSymbol(this.location[Position.ON]));
    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));
    return buf.toString()
  }
  setLocations (on, left, right) {
    this.location[Position.ON] = on;
    this.location[Position.LEFT] = left;
    this.location[Position.RIGHT] = right;
  }
  get (posIndex) {
    if (posIndex < this.location.length) return this.location[posIndex]
    return Location.NONE
  }
  isArea () {
    return this.location.length > 1
  }
  isAnyNull () {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] === Location.NONE) return true
    }
    return false
  }
  setLocation () {
    if (arguments.length === 1) {
      const locValue = arguments[0];
      this.setLocation(Position.ON, locValue);
    } else if (arguments.length === 2) {
      const locIndex = arguments[0];
      const locValue = arguments[1];
      this.location[locIndex] = locValue;
    }
  }
  init (size) {
    this.location = new Array(size).fill(null);
    this.setAllLocations(Location.NONE);
  }
  isEqualOnSide (le, locIndex) {
    return this.location[locIndex] === le.location[locIndex]
  }
  allPositionsEqual (loc) {
    for (let i = 0; i < this.location.length; i++) {
      if (this.location[i] !== loc) return false
    }
    return true
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return TopologyLocation
  }
}

class Label {
  constructor () {
    this.elt = new Array(2).fill(null);
    if (arguments.length === 1) {
      if (Number.isInteger(arguments[0])) {
        const onLoc = arguments[0];
        this.elt[0] = new TopologyLocation(onLoc);
        this.elt[1] = new TopologyLocation(onLoc);
      } else if (arguments[0] instanceof Label) {
        const lbl = arguments[0];
        this.elt[0] = new TopologyLocation(lbl.elt[0]);
        this.elt[1] = new TopologyLocation(lbl.elt[1]);
      }
    } else if (arguments.length === 2) {
      const geomIndex = arguments[0];
      const onLoc = arguments[1];
      this.elt[0] = new TopologyLocation(Location.NONE);
      this.elt[1] = new TopologyLocation(Location.NONE);
      this.elt[geomIndex].setLocation(onLoc);
    } else if (arguments.length === 3) {
      const onLoc = arguments[0];
      const leftLoc = arguments[1];
      const rightLoc = arguments[2];
      this.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);
      this.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);
    } else if (arguments.length === 4) {
      const geomIndex = arguments[0];
      const onLoc = arguments[1];
      const leftLoc = arguments[2];
      const rightLoc = arguments[3];
      this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
      this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
      this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);
    }
  }
  getGeometryCount () {
    let count = 0;
    if (!this.elt[0].isNull()) count++;
    if (!this.elt[1].isNull()) count++;
    return count
  }
  setAllLocations (geomIndex, location) {
    this.elt[geomIndex].setAllLocations(location);
  }
  isNull (geomIndex) {
    return this.elt[geomIndex].isNull()
  }
  setAllLocationsIfNull () {
    if (arguments.length === 1) {
      const location = arguments[0];
      this.setAllLocationsIfNull(0, location);
      this.setAllLocationsIfNull(1, location);
    } else if (arguments.length === 2) {
      const geomIndex = arguments[0];
      const location = arguments[1];
      this.elt[geomIndex].setAllLocationsIfNull(location);
    }
  }
  isLine (geomIndex) {
    return this.elt[geomIndex].isLine()
  }
  merge (lbl) {
    for (let i = 0; i < 2; i++) {
      if (this.elt[i] === null && lbl.elt[i] !== null) {
        this.elt[i] = new TopologyLocation(lbl.elt[i]);
      } else {
        this.elt[i].merge(lbl.elt[i]);
      }
    }
  }
  flip () {
    this.elt[0].flip();
    this.elt[1].flip();
  }
  getLocation () {
    if (arguments.length === 1) {
      const geomIndex = arguments[0];
      return this.elt[geomIndex].get(Position.ON)
    } else if (arguments.length === 2) {
      const geomIndex = arguments[0];
      const posIndex = arguments[1];
      return this.elt[geomIndex].get(posIndex)
    }
  }
  toString () {
    const buf = new StringBuffer();
    if (this.elt[0] !== null) {
      buf.append('A:');
      buf.append(this.elt[0].toString());
    }
    if (this.elt[1] !== null) {
      buf.append(' B:');
      buf.append(this.elt[1].toString());
    }
    return buf.toString()
  }
  isArea () {
    if (arguments.length === 0) {
      return this.elt[0].isArea() || this.elt[1].isArea()
    } else if (arguments.length === 1) {
      const geomIndex = arguments[0];
      return this.elt[geomIndex].isArea()
    }
  }
  isAnyNull (geomIndex) {
    return this.elt[geomIndex].isAnyNull()
  }
  setLocation () {
    if (arguments.length === 2) {
      const geomIndex = arguments[0];
      const location = arguments[1];
      this.elt[geomIndex].setLocation(Position.ON, location);
    } else if (arguments.length === 3) {
      const geomIndex = arguments[0];
      const posIndex = arguments[1];
      const location = arguments[2];
      this.elt[geomIndex].setLocation(posIndex, location);
    }
  }
  isEqualOnSide (lbl, side) {
    return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)
  }
  allPositionsEqual (geomIndex, loc) {
    return this.elt[geomIndex].allPositionsEqual(loc)
  }
  toLine (geomIndex) {
    if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return Label
  }
  static toLineLabel (label) {
    const lineLabel = new Label(Location.NONE);
    for (let i = 0; i < 2; i++) {
      lineLabel.setLocation(i, label.getLocation(i));
    }
    return lineLabel
  }
}

class EdgeRing {
  constructor () {
    this._startDe = null;
    this._maxNodeDegree = -1;
    this._edges = new ArrayList();
    this._pts = new ArrayList();
    this._label = new Label(Location.NONE);
    this._ring = null;
    this._isHole = null;
    this._shell = null;
    this._holes = new ArrayList();
    this._geometryFactory = null;
    const start = arguments[0];
    const geometryFactory = arguments[1];
    this._geometryFactory = geometryFactory;
    this.computePoints(start);
    this.computeRing();
  }
  computeRing () {
    if (this._ring !== null) return null
    const coord = new Array(this._pts.size()).fill(null);
    for (let i = 0; i < this._pts.size(); i++) {
      coord[i] = this._pts.get(i);
    }
    this._ring = this._geometryFactory.createLinearRing(coord);
    this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());
  }
  isIsolated () {
    return this._label.getGeometryCount() === 1
  }
  computePoints (start) {
    this._startDe = start;
    let de = start;
    let isFirstEdge = true;
    do {
      if (de === null) throw new TopologyException('Found null DirectedEdge')
      if (de.getEdgeRing() === this) throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate())
      this._edges.add(de);
      const label = de.getLabel();
      Assert.isTrue(label.isArea());
      this.mergeLabel(label);
      this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
      isFirstEdge = false;
      this.setEdgeRing(de, this);
      de = this.getNext(de);
    } while (de !== this._startDe)
  }
  getLinearRing () {
    return this._ring
  }
  getCoordinate (i) {
    return this._pts.get(i)
  }
  computeMaxNodeDegree () {
    this._maxNodeDegree = 0;
    let de = this._startDe;
    do {
      const node = de.getNode();
      const degree = node.getEdges().getOutgoingDegree(this);
      if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;
      de = this.getNext(de);
    } while (de !== this._startDe)
    this._maxNodeDegree *= 2;
  }
  addPoints (edge, isForward, isFirstEdge) {
    const edgePts = edge.getCoordinates();
    if (isForward) {
      let startIndex = 1;
      if (isFirstEdge) startIndex = 0;
      for (let i = startIndex; i < edgePts.length; i++) {
        this._pts.add(edgePts[i]);
      }
    } else {
      let startIndex = edgePts.length - 2;
      if (isFirstEdge) startIndex = edgePts.length - 1;
      for (let i = startIndex; i >= 0; i--) {
        this._pts.add(edgePts[i]);
      }
    }
  }
  isHole () {
    return this._isHole
  }
  setInResult () {
    let de = this._startDe;
    do {
      de.getEdge().setInResult(true);
      de = de.getNext();
    } while (de !== this._startDe)
  }
  containsPoint (p) {
    const shell = this.getLinearRing();
    const env = shell.getEnvelopeInternal();
    if (!env.contains(p)) return false
    if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) return false
    for (let i = this._holes.iterator(); i.hasNext();) {
      const hole = i.next();
      if (hole.containsPoint(p)) return false
    }
    return true
  }
  addHole (ring) {
    this._holes.add(ring);
  }
  isShell () {
    return this._shell === null
  }
  getLabel () {
    return this._label
  }
  getEdges () {
    return this._edges
  }
  getMaxNodeDegree () {
    if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();
    return this._maxNodeDegree
  }
  getShell () {
    return this._shell
  }
  mergeLabel () {
    if (arguments.length === 1) {
      const deLabel = arguments[0];
      this.mergeLabel(deLabel, 0);
      this.mergeLabel(deLabel, 1);
    } else if (arguments.length === 2) {
      const deLabel = arguments[0];
      const geomIndex = arguments[1];
      const loc = deLabel.getLocation(geomIndex, Position.RIGHT);
      if (loc === Location.NONE) return null
      if (this._label.getLocation(geomIndex) === Location.NONE) {
        this._label.setLocation(geomIndex, loc);
        return null
      }
    }
  }
  setShell (shell) {
    this._shell = shell;
    if (shell !== null) shell.addHole(this);
  }
  toPolygon (geometryFactory) {
    const holeLR = new Array(this._holes.size()).fill(null);
    for (let i = 0; i < this._holes.size(); i++) {
      holeLR[i] = this._holes.get(i).getLinearRing();
    }
    const poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
    return poly
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return EdgeRing
  }
}

class MinimalEdgeRing extends EdgeRing {
  constructor () {
    const start = arguments[0];
    const geometryFactory = arguments[1];
    super(start, geometryFactory);
  }
  setEdgeRing (de, er) {
    de.setMinEdgeRing(er);
  }
  getNext (de) {
    return de.getNextMin()
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MinimalEdgeRing
  }
}

class MaximalEdgeRing extends EdgeRing {
  constructor () {
    const start = arguments[0];
    const geometryFactory = arguments[1];
    super(start, geometryFactory);
  }
  buildMinimalRings () {
    const minEdgeRings = new ArrayList();
    let de = this._startDe;
    do {
      if (de.getMinEdgeRing() === null) {
        const minEr = new MinimalEdgeRing(de, this._geometryFactory);
        minEdgeRings.add(minEr);
      }
      de = de.getNext();
    } while (de !== this._startDe)
    return minEdgeRings
  }
  setEdgeRing (de, er) {
    de.setEdgeRing(er);
  }
  linkDirectedEdgesForMinimalEdgeRings () {
    let de = this._startDe;
    do {
      const node = de.getNode();
      node.getEdges().linkMinimalDirectedEdges(this);
      de = de.getNext();
    } while (de !== this._startDe)
  }
  getNext (de) {
    return de.getNext()
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MaximalEdgeRing
  }
}

class GraphComponent {
  constructor () {
    this._label = null;
    this._isInResult = false;
    this._isCovered = false;
    this._isCoveredSet = false;
    this._isVisited = false;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      let label = arguments[0];
      this._label = label;
    }
  }
  setVisited (isVisited) {
    this._isVisited = isVisited;
  }
  setInResult (isInResult) {
    this._isInResult = isInResult;
  }
  isCovered () {
    return this._isCovered
  }
  isCoveredSet () {
    return this._isCoveredSet
  }
  setLabel (label) {
    this._label = label;
  }
  getLabel () {
    return this._label
  }
  setCovered (isCovered) {
    this._isCovered = isCovered;
    this._isCoveredSet = true;
  }
  updateIM (im) {
    Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');
    this.computeIM(im);
  }
  isInResult () {
    return this._isInResult
  }
  isVisited () {
    return this._isVisited
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GraphComponent
  }
}

class Node extends GraphComponent {
  constructor () {
    super();
    this._coord = null;
    this._edges = null;
    const coord = arguments[0];
    const edges = arguments[1];
    this._coord = coord;
    this._edges = edges;
    this._label = new Label(0, Location.NONE);
  }
  isIncidentEdgeInResult () {
    for (const it = this.getEdges().getEdges().iterator(); it.hasNext();) {
      const de = it.next();
      if (de.getEdge().isInResult()) return true
    }
    return false
  }
  isIsolated () {
    return this._label.getGeometryCount() === 1
  }
  getCoordinate () {
    return this._coord
  }
  print (out) {
    out.println('node ' + this._coord + ' lbl: ' + this._label);
  }
  computeIM (im) {}
  computeMergedLocation (label2, eltIndex) {
    let loc = Location.NONE;
    loc = this._label.getLocation(eltIndex);
    if (!label2.isNull(eltIndex)) {
      const nLoc = label2.getLocation(eltIndex);
      if (loc !== Location.BOUNDARY) loc = nLoc;
    }
    return loc
  }
  setLabel () {
    if (arguments.length === 2) {
      const argIndex = arguments[0];
      const onLocation = arguments[1];
      if (this._label === null) {
        this._label = new Label(argIndex, onLocation);
      } else this._label.setLocation(argIndex, onLocation);
    } else return GraphComponent.prototype.setLabel.apply(this, arguments)
  }
  getEdges () {
    return this._edges
  }
  mergeLabel () {
    if (arguments[0] instanceof Node) {
      const n = arguments[0];
      this.mergeLabel(n._label);
    } else if (arguments[0] instanceof Label) {
      const label2 = arguments[0];
      for (let i = 0; i < 2; i++) {
        const loc = this.computeMergedLocation(label2, i);
        const thisLoc = this._label.getLocation(i);
        if (thisLoc === Location.NONE) this._label.setLocation(i, loc);
      }
    }
  }
  add (e) {
    this._edges.insert(e);
    e.setNode(this);
  }
  setLabelBoundary (argIndex) {
    if (this._label === null) return null
    let loc = Location.NONE;
    if (this._label !== null) loc = this._label.getLocation(argIndex);
    let newLoc = null;
    switch (loc) {
      case Location.BOUNDARY:
        newLoc = Location.INTERIOR;
        break
      case Location.INTERIOR:
        newLoc = Location.BOUNDARY;
        break
      default:
        newLoc = Location.BOUNDARY;
        break
    }
    this._label.setLocation(argIndex, newLoc);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return Node
  }
}

class NodeMap {
  constructor () {
    this.nodeMap = new TreeMap();
    this.nodeFact = null;
    const nodeFact = arguments[0];
    this.nodeFact = nodeFact;
  }
  find (coord) {
    return this.nodeMap.get(coord)
  }
  addNode () {
    if (arguments[0] instanceof Coordinate) {
      const coord = arguments[0];
      let node = this.nodeMap.get(coord);
      if (node === null) {
        node = this.nodeFact.createNode(coord);
        this.nodeMap.put(coord, node);
      }
      return node
    } else if (arguments[0] instanceof Node) {
      const n = arguments[0];
      const node = this.nodeMap.get(n.getCoordinate());
      if (node === null) {
        this.nodeMap.put(n.getCoordinate(), n);
        return n
      }
      node.mergeLabel(n);
      return node
    }
  }
  print (out) {
    for (const it = this.iterator(); it.hasNext();) {
      const n = it.next();
      n.print(out);
    }
  }
  iterator () {
    return this.nodeMap.values().iterator()
  }
  values () {
    return this.nodeMap.values()
  }
  getBoundaryNodes (geomIndex) {
    const bdyNodes = new ArrayList();
    for (const i = this.iterator(); i.hasNext();) {
      const node = i.next();
      if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);
    }
    return bdyNodes
  }
  add (e) {
    const p = e.getCoordinate();
    const n = this.addNode(p);
    n.add(e);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return NodeMap
  }
}

class Quadrant {
  interfaces_ () {
    return []
  }
  getClass () {
    return Quadrant
  }
  static isNorthern (quad) {
    return quad === Quadrant.NE || quad === Quadrant.NW
  }
  static isOpposite (quad1, quad2) {
    if (quad1 === quad2) return false
    const diff = (quad1 - quad2 + 4) % 4;
    if (diff === 2) return true
    return false
  }
  static commonHalfPlane (quad1, quad2) {
    if (quad1 === quad2) return quad1
    const diff = (quad1 - quad2 + 4) % 4;
    if (diff === 2) return -1
    const min = quad1 < quad2 ? quad1 : quad2;
    const max = quad1 > quad2 ? quad1 : quad2;
    if (min === 0 && max === 3) return 3
    return min
  }
  static isInHalfPlane (quad, halfPlane) {
    if (halfPlane === Quadrant.SE) {
      return quad === Quadrant.SE || quad === Quadrant.SW
    }
    return quad === halfPlane || quad === halfPlane + 1
  }
  static quadrant () {
    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
      const dx = arguments[0];
      const dy = arguments[1];
      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )')
      if (dx >= 0.0) {
        if (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE
      } else {
        if (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW
      }
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
      const p0 = arguments[0];
      const p1 = arguments[1];
      if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0)
      if (p1.x >= p0.x) {
        if (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE
      } else {
        if (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW
      }
    }
  }
  static get NE () { return 0 }
  static get NW () { return 1 }
  static get SW () { return 2 }
  static get SE () { return 3 }
}

class EdgeEnd {
  constructor () {
    this._edge = null;
    this._label = null;
    this._node = null;
    this._p0 = null;
    this._p1 = null;
    this._dx = null;
    this._dy = null;
    this._quadrant = null;
    if (arguments.length === 1) {
      let edge = arguments[0];
      this._edge = edge;
    } else if (arguments.length === 3) {
      const edge = arguments[0];
      const p0 = arguments[1];
      const p1 = arguments[2];
      const label = null;
      this._edge = edge;
      this.init(p0, p1);
      this._label = label;
    } else if (arguments.length === 4) {
      const edge = arguments[0];
      const p0 = arguments[1];
      const p1 = arguments[2];
      const label = arguments[3];
      this._edge = edge;
      this.init(p0, p1);
      this._label = label;
    }
  }
  compareDirection (e) {
    if (this._dx === e._dx && this._dy === e._dy) return 0
    if (this._quadrant > e._quadrant) return 1
    if (this._quadrant < e._quadrant) return -1
    return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1)
  }
  getDy () {
    return this._dy
  }
  getCoordinate () {
    return this._p0
  }
  setNode (node) {
    this._node = node;
  }
  print (out) {
    var angle = Math.atan2(this._dy, this._dx);
    var className = this.getClass().getName();
    var lastDotPos = className.lastIndexOf('.');
    var name = className.substring(lastDotPos + 1);
    out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);
  }
  compareTo (obj) {
    var e = obj;
    return this.compareDirection(e)
  }
  getDirectedCoordinate () {
    return this._p1
  }
  getDx () {
    return this._dx
  }
  getLabel () {
    return this._label
  }
  getEdge () {
    return this._edge
  }
  getQuadrant () {
    return this._quadrant
  }
  getNode () {
    return this._node
  }
  toString () {
    var angle = Math.atan2(this._dy, this._dx);
    var className = this.getClass().getName();
    var lastDotPos = className.lastIndexOf('.');
    var name = className.substring(lastDotPos + 1);
    return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label
  }
  computeLabel (boundaryNodeRule) {}
  init (p0, p1) {
    this._p0 = p0;
    this._p1 = p1;
    this._dx = p1.x - p0.x;
    this._dy = p1.y - p0.y;
    this._quadrant = Quadrant.quadrant(this._dx, this._dy);
    Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return EdgeEnd
  }
}

class DirectedEdge extends EdgeEnd {
  constructor () {
    const edge = arguments[0];
    const isForward = arguments[1];
    super(edge);
    this._isForward = null;
    this._isInResult = false;
    this._isVisited = false;
    this._sym = null;
    this._next = null;
    this._nextMin = null;
    this._edgeRing = null;
    this._minEdgeRing = null;
    this._depth = [0, -999, -999];
    this._isForward = isForward;
    if (isForward) {
      this.init(edge.getCoordinate(0), edge.getCoordinate(1));
    } else {
      const n = edge.getNumPoints() - 1;
      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
    }
    this.computeDirectedLabel();
  }
  getNextMin () {
    return this._nextMin
  }
  getDepth (position) {
    return this._depth[position]
  }
  setVisited (isVisited) {
    this._isVisited = isVisited;
  }
  computeDirectedLabel () {
    this._label = new Label(this._edge.getLabel());
    if (!this._isForward) this._label.flip();
  }
  getNext () {
    return this._next
  }
  setDepth (position, depthVal) {
    if (this._depth[position] !== -999) {
      if (this._depth[position] !== depthVal) throw new TopologyException('assigned depths do not match', this.getCoordinate())
    }
    this._depth[position] = depthVal;
  }
  isInteriorAreaEdge () {
    let isInteriorAreaEdge = true;
    for (let i = 0; i < 2; i++) {
      if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
        isInteriorAreaEdge = false;
      }
    }
    return isInteriorAreaEdge
  }
  setNextMin (nextMin) {
    this._nextMin = nextMin;
  }
  print (out) {
    EdgeEnd.prototype.print.call(this, out);
    out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);
    out.print(' (' + this.getDepthDelta() + ')');
    if (this._isInResult) out.print(' inResult');
  }
  setMinEdgeRing (minEdgeRing) {
    this._minEdgeRing = minEdgeRing;
  }
  isLineEdge () {
    const isLine = this._label.isLine(0) || this._label.isLine(1);
    const isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
    const isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
    return isLine && isExteriorIfArea0 && isExteriorIfArea1
  }
  setEdgeRing (edgeRing) {
    this._edgeRing = edgeRing;
  }
  getMinEdgeRing () {
    return this._minEdgeRing
  }
  getDepthDelta () {
    let depthDelta = this._edge.getDepthDelta();
    if (!this._isForward) depthDelta = -depthDelta;
    return depthDelta
  }
  setInResult (isInResult) {
    this._isInResult = isInResult;
  }
  getSym () {
    return this._sym
  }
  isForward () {
    return this._isForward
  }
  getEdge () {
    return this._edge
  }
  printEdge (out) {
    this.print(out);
    out.print(' ');
    if (this._isForward) this._edge.print(out); else this._edge.printReverse(out);
  }
  setSym (de) {
    this._sym = de;
  }
  setVisitedEdge (isVisited) {
    this.setVisited(isVisited);
    this._sym.setVisited(isVisited);
  }
  setEdgeDepths (position, depth) {
    let depthDelta = this.getEdge().getDepthDelta();
    if (!this._isForward) depthDelta = -depthDelta;
    let directionFactor = 1;
    if (position === Position.LEFT) directionFactor = -1;
    const oppositePos = Position.opposite(position);
    const delta = depthDelta * directionFactor;
    const oppositeDepth = depth + delta;
    this.setDepth(position, depth);
    this.setDepth(oppositePos, oppositeDepth);
  }
  getEdgeRing () {
    return this._edgeRing
  }
  isInResult () {
    return this._isInResult
  }
  setNext (next) {
    this._next = next;
  }
  isVisited () {
    return this._isVisited
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return DirectedEdge
  }
  static depthFactor (currLocation, nextLocation) {
    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1
    return 0
  }
}

class NodeFactory {
  createNode (coord) {
    return new Node(coord, null)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return NodeFactory
  }
}

class PlanarGraph {
  constructor () {
    this._edges = new ArrayList();
    this._nodes = null;
    this._edgeEndList = new ArrayList();
    if (arguments.length === 0) {
      this._nodes = new NodeMap(new NodeFactory());
    } else if (arguments.length === 1) {
      const nodeFact = arguments[0];
      this._nodes = new NodeMap(nodeFact);
    }
  }
  printEdges (out) {
    out.println('Edges:');
    for (let i = 0; i < this._edges.size(); i++) {
      out.println('edge ' + i + ':');
      const e = this._edges.get(i);
      e.print(out);
      e.eiList.print(out);
    }
  }
  find (coord) {
    return this._nodes.find(coord)
  }
  addNode () {
    if (arguments[0] instanceof Node) {
      const node = arguments[0];
      return this._nodes.addNode(node)
    } else if (arguments[0] instanceof Coordinate) {
      const coord = arguments[0];
      return this._nodes.addNode(coord)
    }
  }
  getNodeIterator () {
    return this._nodes.iterator()
  }
  linkResultDirectedEdges () {
    for (const nodeit = this._nodes.iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().linkResultDirectedEdges();
    }
  }
  debugPrintln (o) {
    System.out.println(o);
  }
  isBoundaryNode (geomIndex, coord) {
    const node = this._nodes.find(coord);
    if (node === null) return false
    const label = node.getLabel();
    if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true
    return false
  }
  linkAllDirectedEdges () {
    for (const nodeit = this._nodes.iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().linkAllDirectedEdges();
    }
  }
  matchInSameDirection (p0, p1, ep0, ep1) {
    if (!p0.equals(ep0)) return false
    if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true
    return false
  }
  getEdgeEnds () {
    return this._edgeEndList
  }
  debugPrint (o) {
    System.out.print(o);
  }
  getEdgeIterator () {
    return this._edges.iterator()
  }
  findEdgeInSameDirection (p0, p1) {
    for (let i = 0; i < this._edges.size(); i++) {
      const e = this._edges.get(i);
      const eCoord = e.getCoordinates();
      if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e
      if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e
    }
    return null
  }
  insertEdge (e) {
    this._edges.add(e);
  }
  findEdgeEnd (e) {
    for (let i = this.getEdgeEnds().iterator(); i.hasNext();) {
      const ee = i.next();
      if (ee.getEdge() === e) return ee
    }
    return null
  }
  addEdges (edgesToAdd) {
    for (const it = edgesToAdd.iterator(); it.hasNext();) {
      const e = it.next();
      this._edges.add(e);
      const de1 = new DirectedEdge(e, true);
      const de2 = new DirectedEdge(e, false);
      de1.setSym(de2);
      de2.setSym(de1);
      this.add(de1);
      this.add(de2);
    }
  }
  add (e) {
    this._nodes.add(e);
    this._edgeEndList.add(e);
  }
  getNodes () {
    return this._nodes.values()
  }
  findEdge (p0, p1) {
    for (let i = 0; i < this._edges.size(); i++) {
      const e = this._edges.get(i);
      const eCoord = e.getCoordinates();
      if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e
    }
    return null
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return PlanarGraph
  }
  static linkResultDirectedEdges (nodes) {
    for (const nodeit = nodes.iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().linkResultDirectedEdges();
    }
  }
}

class PolygonBuilder {
  constructor () {
    this._geometryFactory = null;
    this._shellList = new ArrayList();
    let geometryFactory = arguments[0];
    this._geometryFactory = geometryFactory;
  }
  sortShellsAndHoles (edgeRings, shellList, freeHoleList) {
    for (const it = edgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.isHole()) {
        freeHoleList.add(er);
      } else {
        shellList.add(er);
      }
    }
  }
  computePolygons (shellList) {
    const resultPolyList = new ArrayList();
    for (const it = shellList.iterator(); it.hasNext();) {
      const er = it.next();
      const poly = er.toPolygon(this._geometryFactory);
      resultPolyList.add(poly);
    }
    return resultPolyList
  }
  placeFreeHoles (shellList, freeHoleList) {
    for (const it = freeHoleList.iterator(); it.hasNext();) {
      const hole = it.next();
      if (hole.getShell() === null) {
        const shell = this.findEdgeRingContaining(hole, shellList);
        if (shell === null) throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0))
        hole.setShell(shell);
      }
    }
  }
  buildMinimalEdgeRings (maxEdgeRings, shellList, freeHoleList) {
    const edgeRings = new ArrayList();
    for (const it = maxEdgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.getMaxNodeDegree() > 2) {
        er.linkDirectedEdgesForMinimalEdgeRings();
        const minEdgeRings = er.buildMinimalRings();
        const shell = this.findShell(minEdgeRings);
        if (shell !== null) {
          this.placePolygonHoles(shell, minEdgeRings);
          shellList.add(shell);
        } else {
          freeHoleList.addAll(minEdgeRings);
        }
      } else {
        edgeRings.add(er);
      }
    }
    return edgeRings
  }
  containsPoint (p) {
    for (const it = this._shellList.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.containsPoint(p)) return true
    }
    return false
  }
  buildMaximalEdgeRings (dirEdges) {
    const maxEdgeRings = new ArrayList();
    for (const it = dirEdges.iterator(); it.hasNext();) {
      const de = it.next();
      if (de.isInResult() && de.getLabel().isArea()) {
        if (de.getEdgeRing() === null) {
          const er = new MaximalEdgeRing(de, this._geometryFactory);
          maxEdgeRings.add(er);
          er.setInResult();
        }
      }
    }
    return maxEdgeRings
  }
  placePolygonHoles (shell, minEdgeRings) {
    for (const it = minEdgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (er.isHole()) {
        er.setShell(shell);
      }
    }
  }
  getPolygons () {
    const resultPolyList = this.computePolygons(this._shellList);
    return resultPolyList
  }
  findEdgeRingContaining (testEr, shellList) {
    const testRing = testEr.getLinearRing();
    const testEnv = testRing.getEnvelopeInternal();
    const testPt = testRing.getCoordinateN(0);
    let minShell = null;
    let minEnv = null;
    for (const it = shellList.iterator(); it.hasNext();) {
      const tryShell = it.next();
      const tryRing = tryShell.getLinearRing();
      const tryEnv = tryRing.getEnvelopeInternal();
      if (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();
      let isContained = false;
      if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) isContained = true;
      if (isContained) {
        if (minShell === null || minEnv.contains(tryEnv)) {
          minShell = tryShell;
        }
      }
    }
    return minShell
  }
  findShell (minEdgeRings) {
    let shellCount = 0;
    let shell = null;
    for (const it = minEdgeRings.iterator(); it.hasNext();) {
      const er = it.next();
      if (!er.isHole()) {
        shell = er;
        shellCount++;
      }
    }
    Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
    return shell
  }
  add () {
    if (arguments.length === 1) {
      const graph = arguments[0];
      this.add(graph.getEdgeEnds(), graph.getNodes());
    } else if (arguments.length === 2) {
      const dirEdges = arguments[0];
      const nodes = arguments[1];
      PlanarGraph.linkResultDirectedEdges(nodes);
      const maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
      const freeHoleList = new ArrayList();
      const edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
      this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
      this.placeFreeHoles(this._shellList, freeHoleList);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return PolygonBuilder
  }
}

class Boundable {
  getBounds () {}
  interfaces_ () {
    return []
  }
  getClass () {
    return Boundable
  }
}

class ItemBoundable {
  constructor () {
    this._bounds = null;
    this._item = null;
    const bounds = arguments[0];
    const item = arguments[1];
    this._bounds = bounds;
    this._item = item;
  }
  getItem () {
    return this._item
  }
  getBounds () {
    return this._bounds
  }
  interfaces_ () {
    return [Boundable, Serializable]
  }
  getClass () {
    return ItemBoundable
  }
}

class PriorityQueue {
  constructor () {
    this._size = null;
    this._items = null;
    this._size = 0;
    this._items = new ArrayList();
    this._items.add(null);
  }
  poll () {
    if (this.isEmpty()) return null
    const minItem = this._items.get(1);
    this._items.set(1, this._items.get(this._size));
    this._size -= 1;
    this.reorder(1);
    return minItem
  }
  size () {
    return this._size
  }
  reorder (hole) {
    let child = null;
    const tmp = this._items.get(hole);
    for (; hole * 2 <= this._size; hole = child) {
      child = hole * 2;
      if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;
      if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child)); else break
    }
    this._items.set(hole, tmp);
  }
  clear () {
    this._size = 0;
    this._items.clear();
  }
  isEmpty () {
    return this._size === 0
  }
  add (x) {
    this._items.add(null);
    this._size += 1;
    let hole = this._size;
    this._items.set(0, x);
    for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
      this._items.set(hole, this._items.get(Math.trunc(hole / 2)));
    }
    this._items.set(hole, x);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return PriorityQueue
  }
}

class ItemVisitor {
  visitItem (item) {}
  interfaces_ () {
    return []
  }
  getClass () {
    return ItemVisitor
  }
}

class SpatialIndex {
  insert (itemEnv, item) {}
  remove (itemEnv, item) {}
  query () {
    // if (arguments.length === 1) {
    //   const searchEnv = arguments[0]
    // } else if (arguments.length === 2) {
    //   const searchEnv = arguments[0]
    //   const visitor = arguments[1]
    // }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SpatialIndex
  }
}

class AbstractNode {
  constructor () {
    this._childBoundables = new ArrayList();
    this._bounds = null;
    this._level = null;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      let level = arguments[0];
      this._level = level;
    }
  }
  getLevel () {
    return this._level
  }
  size () {
    return this._childBoundables.size()
  }
  getChildBoundables () {
    return this._childBoundables
  }
  addChildBoundable (childBoundable) {
    Assert.isTrue(this._bounds === null);
    this._childBoundables.add(childBoundable);
  }
  isEmpty () {
    return this._childBoundables.isEmpty()
  }
  getBounds () {
    if (this._bounds === null) {
      this._bounds = this.computeBounds();
    }
    return this._bounds
  }
  interfaces_ () {
    return [Boundable, Serializable]
  }
  getClass () {
    return AbstractNode
  }
  static get serialVersionUID () { return 6493722185909573708 }
}

class Collections {
  static reverseOrder () {
    return {
      compare (a, b) {
        return b.compareTo(a)
      }
    }
  }
  static min (l) {
    Collections.sort(l);
    return l.get(0)
  }
  static sort (l, c) {
    const a = l.toArray();
    if (c) {
      Arrays.sort(a, c);
    } else {
      Arrays.sort(a);
    }
    const i = l.iterator();
    for (let pos = 0, alen = a.length; pos < alen; pos++) {
      i.next();
      i.set(a[pos]);
    }
  }
  static singletonList (o) {
    const arrayList = new ArrayList();
    arrayList.add(o);
    return arrayList
  }
}

class BoundablePair {
  constructor () {
    this._boundable1 = null;
    this._boundable2 = null;
    this._distance = null;
    this._itemDistance = null;
    const boundable1 = arguments[0];
    const boundable2 = arguments[1];
    const itemDistance = arguments[2];
    this._boundable1 = boundable1;
    this._boundable2 = boundable2;
    this._itemDistance = itemDistance;
    this._distance = this.distance();
  }
  expandToQueue (priQ, minDistance) {
    var isComp1 = BoundablePair.isComposite(this._boundable1);
    var isComp2 = BoundablePair.isComposite(this._boundable2);
    if (isComp1 && isComp2) {
      if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
        this.expand(this._boundable1, this._boundable2, priQ, minDistance);
        return null
      } else {
        this.expand(this._boundable2, this._boundable1, priQ, minDistance);
        return null
      }
    } else if (isComp1) {
      this.expand(this._boundable1, this._boundable2, priQ, minDistance);
      return null
    } else if (isComp2) {
      this.expand(this._boundable2, this._boundable1, priQ, minDistance);
      return null
    }
    throw new IllegalArgumentException('neither boundable is composite')
  }
  isLeaves () {
    return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))
  }
  compareTo (o) {
    var nd = o;
    if (this._distance < nd._distance) return -1
    if (this._distance > nd._distance) return 1
    return 0
  }
  expand (bndComposite, bndOther, priQ, minDistance) {
    var children = bndComposite.getChildBoundables();
    for (var i = children.iterator(); i.hasNext();) {
      var child = i.next();
      var bp = new BoundablePair(child, bndOther, this._itemDistance);
      if (bp.getDistance() < minDistance) {
        priQ.add(bp);
      }
    }
  }
  getBoundable (i) {
    if (i === 0) return this._boundable1
    return this._boundable2
  }
  getDistance () {
    return this._distance
  }
  distance () {
    if (this.isLeaves()) {
      return this._itemDistance.distance(this._boundable1, this._boundable2)
    }
    return this._boundable1.getBounds().distance(this._boundable2.getBounds())
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return BoundablePair
  }
  static area (b) {
    return b.getBounds().getArea()
  }
  static isComposite (item) {
    return item instanceof AbstractNode
  }
}

class AbstractSTRtree {
  constructor () {
    this._root = null;
    this._built = false;
    this._itemBoundables = new ArrayList();
    this._nodeCapacity = null;
    if (arguments.length === 0) {
      const nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;
      this._nodeCapacity = nodeCapacity;
    } else if (arguments.length === 1) {
      const nodeCapacity = arguments[0];
      Assert.isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1');
      this._nodeCapacity = nodeCapacity;
    }
  }
  getNodeCapacity () {
    return this._nodeCapacity
  }
  lastNode (nodes) {
    return nodes.get(nodes.size() - 1)
  }
  size () {
    if (arguments.length === 0) {
      if (this.isEmpty()) {
        return 0
      }
      this.build();
      return this.size(this._root)
    } else if (arguments.length === 1) {
      const node = arguments[0];
      let size = 0;
      for (const i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (childBoundable instanceof AbstractNode) {
          size += this.size(childBoundable);
        } else if (childBoundable instanceof ItemBoundable) {
          size += 1;
        }
      }
      return size
    }
  }
  removeItem (node, item) {
    let childToRemove = null;
    for (const i = node.getChildBoundables().iterator(); i.hasNext();) {
      const childBoundable = i.next();
      if (childBoundable instanceof ItemBoundable) {
        if (childBoundable.getItem() === item) childToRemove = childBoundable;
      }
    }
    if (childToRemove !== null) {
      node.getChildBoundables().remove(childToRemove);
      return true
    }
    return false
  }
  itemsTree () {
    if (arguments.length === 0) {
      this.build();
      const valuesTree = this.itemsTree(this._root);
      if (valuesTree === null) return new ArrayList()
      return valuesTree
    } else if (arguments.length === 1) {
      const node = arguments[0];
      const valuesTreeForNode = new ArrayList();
      for (const i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (childBoundable instanceof AbstractNode) {
          const valuesTreeForChild = this.itemsTree(childBoundable);
          if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);
        } else if (childBoundable instanceof ItemBoundable) {
          valuesTreeForNode.add(childBoundable.getItem());
        } else {
          Assert.shouldNeverReachHere();
        }
      }
      if (valuesTreeForNode.size() <= 0) return null
      return valuesTreeForNode
    }
  }
  insert (bounds, item) {
    Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');
    this._itemBoundables.add(new ItemBoundable(bounds, item));
  }
  boundablesAtLevel () {
    if (arguments.length === 1) {
      const level = arguments[0];
      const boundables = new ArrayList();
      this.boundablesAtLevel(level, this._root, boundables);
      return boundables
    } else if (arguments.length === 3) {
      const level = arguments[0];
      const top = arguments[1];
      const boundables = arguments[2];
      Assert.isTrue(level > -2);
      if (top.getLevel() === level) {
        boundables.add(top);
        return null
      }
      for (const i = top.getChildBoundables().iterator(); i.hasNext();) {
        const boundable = i.next();
        if (boundable instanceof AbstractNode) {
          this.boundablesAtLevel(level, boundable, boundables);
        } else {
          Assert.isTrue(boundable instanceof ItemBoundable);
          if (level === -1) {
            boundables.add(boundable);
          }
        }
      }
      return null
    }
  }
  query () {
    if (arguments.length === 1) {
      const searchBounds = arguments[0];
      this.build();
      const matches = new ArrayList();
      if (this.isEmpty()) {
        return matches
      }
      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
        this.query(searchBounds, this._root, matches);
      }
      return matches
    } else if (arguments.length === 2) {
      const searchBounds = arguments[0];
      const visitor = arguments[1];
      this.build();
      if (this.isEmpty()) {
        return null
      }
      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
        this.query(searchBounds, this._root, visitor);
      }
    } else if (arguments.length === 3) {
      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        const searchBounds = arguments[0];
        const node = arguments[1];
        const visitor = arguments[2];
        const childBoundables = node.getChildBoundables();
        for (let i = 0; i < childBoundables.size(); i++) {
          const childBoundable = childBoundables.get(i);
          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
            continue
          }
          if (childBoundable instanceof AbstractNode) {
            this.query(searchBounds, childBoundable, visitor);
          } else if (childBoundable instanceof ItemBoundable) {
            visitor.visitItem(childBoundable.getItem());
          } else {
            Assert.shouldNeverReachHere();
          }
        }
      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        const searchBounds = arguments[0];
        const node = arguments[1];
        const matches = arguments[2];
        const childBoundables = node.getChildBoundables();
        for (let i = 0; i < childBoundables.size(); i++) {
          const childBoundable = childBoundables.get(i);
          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
            continue
          }
          if (childBoundable instanceof AbstractNode) {
            this.query(searchBounds, childBoundable, matches);
          } else if (childBoundable instanceof ItemBoundable) {
            matches.add(childBoundable.getItem());
          } else {
            Assert.shouldNeverReachHere();
          }
        }
      }
    }
  }
  build () {
    if (this._built) return null
    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
    this._itemBoundables = null;
    this._built = true;
  }
  getRoot () {
    this.build();
    return this._root
  }
  remove () {
    if (arguments.length === 2) {
      const searchBounds = arguments[0];
      const item = arguments[1];
      this.build();
      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
        return this.remove(searchBounds, this._root, item)
      }
      return false
    } else if (arguments.length === 3) {
      const searchBounds = arguments[0];
      const node = arguments[1];
      const item = arguments[2];
      let found = this.removeItem(node, item);
      if (found) return true
      let childToPrune = null;
      for (const i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
          continue
        }
        if (childBoundable instanceof AbstractNode) {
          found = this.remove(searchBounds, childBoundable, item);
          if (found) {
            childToPrune = childBoundable;
            break
          }
        }
      }
      if (childToPrune !== null) {
        if (childToPrune.getChildBoundables().isEmpty()) {
          node.getChildBoundables().remove(childToPrune);
        }
      }
      return found
    }
  }
  createHigherLevels (boundablesOfALevel, level) {
    Assert.isTrue(!boundablesOfALevel.isEmpty());
    const parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
    if (parentBoundables.size() === 1) {
      return parentBoundables.get(0)
    }
    return this.createHigherLevels(parentBoundables, level + 1)
  }
  depth () {
    if (arguments.length === 0) {
      if (this.isEmpty()) {
        return 0
      }
      this.build();
      return this.depth(this._root)
    } else if (arguments.length === 1) {
      const node = arguments[0];
      let maxChildDepth = 0;
      for (const i = node.getChildBoundables().iterator(); i.hasNext();) {
        const childBoundable = i.next();
        if (childBoundable instanceof AbstractNode) {
          const childDepth = this.depth(childBoundable);
          if (childDepth > maxChildDepth) maxChildDepth = childDepth;
        }
      }
      return maxChildDepth + 1
    }
  }
  createParentBoundables (childBoundables, newLevel) {
    Assert.isTrue(!childBoundables.isEmpty());
    const parentBoundables = new ArrayList();
    parentBoundables.add(this.createNode(newLevel));
    const sortedChildBoundables = new ArrayList(childBoundables);
    Collections.sort(sortedChildBoundables, this.getComparator());
    for (const i = sortedChildBoundables.iterator(); i.hasNext();) {
      const childBoundable = i.next();
      if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {
        parentBoundables.add(this.createNode(newLevel));
      }
      this.lastNode(parentBoundables).addChildBoundable(childBoundable);
    }
    return parentBoundables
  }
  isEmpty () {
    if (!this._built) return this._itemBoundables.isEmpty()
    return this._root.isEmpty()
  }
  interfaces_ () {
    return [Serializable]
  }
  getClass () {
    return AbstractSTRtree
  }
  static compareDoubles (a, b) {
    return a > b ? 1 : a < b ? -1 : 0
  }
  static get IntersectsOp () { return IntersectsOp }
  static get serialVersionUID () { return -3886435814360241337 }
  static get DEFAULT_NODE_CAPACITY () { return 10 }
}

class IntersectsOp {

}

class ItemDistance {
  distance (item1, item2) {}
  interfaces_ () {
    return []
  }
  getClass () {
    return ItemDistance
  }
}

class STRtree extends AbstractSTRtree {
  constructor (nodeCapacity) {
    nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;
    super(nodeCapacity);
  }
  createParentBoundablesFromVerticalSlices (verticalSlices, newLevel) {
    Assert.isTrue(verticalSlices.length > 0);
    const parentBoundables = new ArrayList();
    for (let i = 0; i < verticalSlices.length; i++) {
      parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
    }
    return parentBoundables
  }
  createNode (level) {
    return new STRtreeNode(level)
  }
  size () {
    if (arguments.length === 0) {
      return AbstractSTRtree.prototype.size.call(this)
    } else return AbstractSTRtree.prototype.size.apply(this, arguments)
  }
  insert () {
    if (arguments.length === 2) {
      const itemEnv = arguments[0];
      const item = arguments[1];
      if (itemEnv.isNull()) {
        return null
      }
      AbstractSTRtree.prototype.insert.call(this, itemEnv, item);
    } else return AbstractSTRtree.prototype.insert.apply(this, arguments)
  }
  getIntersectsOp () {
    return STRtree.intersectsOp
  }
  verticalSlices (childBoundables, sliceCount) {
    const sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
    const slices = new Array(sliceCount).fill(null);
    const i = childBoundables.iterator();
    for (let j = 0; j < sliceCount; j++) {
      slices[j] = new ArrayList();
      let boundablesAddedToSlice = 0;
      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
        const childBoundable = i.next();
        slices[j].add(childBoundable);
        boundablesAddedToSlice++;
      }
    }
    return slices
  }
  query () {
    if (arguments.length === 1) {
      const searchEnv = arguments[0];
      return AbstractSTRtree.prototype.query.call(this, searchEnv)
    } else if (arguments.length === 2) {
      const searchEnv = arguments[0];
      const visitor = arguments[1];
      AbstractSTRtree.prototype.query.call(this, searchEnv, visitor);
    } else if (arguments.length === 3) {
      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        const searchBounds = arguments[0];
        const node = arguments[1];
        const visitor = arguments[2];
        AbstractSTRtree.prototype.query.call(this, searchBounds, node, visitor);
      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {
        const searchBounds = arguments[0];
        const node = arguments[1];
        const matches = arguments[2];
        AbstractSTRtree.prototype.query.call(this, searchBounds, node, matches);
      }
    }
  }
  getComparator () {
    return STRtree.yComparator
  }
  createParentBoundablesFromVerticalSlice (childBoundables, newLevel) {
    return AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel)
  }
  remove () {
    if (arguments.length === 2) {
      const itemEnv = arguments[0];
      const item = arguments[1];
      return AbstractSTRtree.prototype.remove.call(this, itemEnv, item)
    } else return AbstractSTRtree.prototype.remove.apply(this, arguments)
  }
  depth () {
    if (arguments.length === 0) {
      return AbstractSTRtree.prototype.depth.call(this)
    } else return AbstractSTRtree.prototype.depth.apply(this, arguments)
  }
  createParentBoundables (childBoundables, newLevel) {
    Assert.isTrue(!childBoundables.isEmpty());
    const minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
    const sortedChildBoundables = new ArrayList(childBoundables);
    Collections.sort(sortedChildBoundables, STRtree.xComparator);
    const verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)
  }
  nearestNeighbour () {
    if (arguments.length === 1) {
      if (hasInterface(arguments[0], ItemDistance)) {
        let itemDist = arguments[0];
        const bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
        return this.nearestNeighbour(bp)
      } else if (arguments[0] instanceof BoundablePair) {
        let initBndPair = arguments[0];
        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY)
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {
        const tree = arguments[0];
        const itemDist = arguments[1];
        const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);
        return this.nearestNeighbour(bp)
      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {
        const initBndPair = arguments[0];
        const maxDistance = arguments[1];
        let distanceLowerBound = maxDistance;
        let minPair = null;
        const priQ = new PriorityQueue();
        priQ.add(initBndPair);
        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
          const bndPair = priQ.poll();
          const currentDistance = bndPair.getDistance();
          if (currentDistance >= distanceLowerBound) break
          if (bndPair.isLeaves()) {
            distanceLowerBound = currentDistance;
            minPair = bndPair;
          } else {
            bndPair.expandToQueue(priQ, distanceLowerBound);
          }
        }
        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]
      }
    } else if (arguments.length === 3) {
      const env = arguments[0];
      const item = arguments[1];
      const itemDist = arguments[2];
      const bnd = new ItemBoundable(env, item);
      const bp = new BoundablePair(this.getRoot(), bnd, itemDist);
      return this.nearestNeighbour(bp)[0]
    }
  }
  interfaces_ () {
    return [SpatialIndex, Serializable]
  }
  getClass () {
    return STRtree
  }
  static centreX (e) {
    return STRtree.avg(e.getMinX(), e.getMaxX())
  }
  static avg (a, b) {
    return (a + b) / 2
  }
  static centreY (e) {
    return STRtree.avg(e.getMinY(), e.getMaxY())
  }
  static get STRtreeNode () { return STRtreeNode }
  static get serialVersionUID () { return 259274702368956900 }
  static get xComparator () {
    return {
      interfaces_: function () {
        return [Comparator]
      },
      compare: function (o1, o2) {
        return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))
      }
    }
  }
  static get yComparator () {
    return {
      interfaces_: function () {
        return [Comparator]
      },
      compare: function (o1, o2) {
        return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))
      }
    }
  }
  static get intersectsOp () {
    return {
      interfaces_: function () {
        return [AbstractSTRtree.IntersectsOp]
      },
      intersects: function (aBounds, bBounds) {
        return aBounds.intersects(bBounds)
      }
    }
  }
  static get DEFAULT_NODE_CAPACITY () { return 10 }
}

class STRtreeNode extends AbstractNode {
  constructor () {
    let level = arguments[0];
    super(level);
  }
  computeBounds () {
    let bounds = null;
    for (const i = this.getChildBoundables().iterator(); i.hasNext();) {
      const childBoundable = i.next();
      if (bounds === null) {
        bounds = new Envelope(childBoundable.getBounds());
      } else {
        bounds.expandToInclude(childBoundable.getBounds());
      }
    }
    return bounds
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return STRtreeNode
  }
}

class SegmentPointComparator {
  interfaces_ () {
    return []
  }
  getClass () {
    return SegmentPointComparator
  }
  static relativeSign (x0, x1) {
    if (x0 < x1) return -1
    if (x0 > x1) return 1
    return 0
  }
  static compare (octant, p0, p1) {
    if (p0.equals2D(p1)) return 0
    var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
    var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
    switch (octant) {
      case 0:
        return SegmentPointComparator.compareValue(xSign, ySign)
      case 1:
        return SegmentPointComparator.compareValue(ySign, xSign)
      case 2:
        return SegmentPointComparator.compareValue(ySign, -xSign)
      case 3:
        return SegmentPointComparator.compareValue(-xSign, ySign)
      case 4:
        return SegmentPointComparator.compareValue(-xSign, -ySign)
      case 5:
        return SegmentPointComparator.compareValue(-ySign, -xSign)
      case 6:
        return SegmentPointComparator.compareValue(-ySign, xSign)
      case 7:
        return SegmentPointComparator.compareValue(xSign, -ySign)
      default:
    }
    Assert.shouldNeverReachHere('invalid octant value');
    return 0
  }
  static compareValue (compareSign0, compareSign1) {
    if (compareSign0 < 0) return -1
    if (compareSign0 > 0) return 1
    if (compareSign1 < 0) return -1
    if (compareSign1 > 0) return 1
    return 0
  }
}

class SegmentNode {
  constructor () {
    this._segString = null;
    this.coord = null;
    this.segmentIndex = null;
    this._segmentOctant = null;
    this._isInterior = null;
    const segString = arguments[0];
    const coord = arguments[1];
    const segmentIndex = arguments[2];
    const segmentOctant = arguments[3];
    this._segString = segString;
    this.coord = new Coordinate(coord);
    this.segmentIndex = segmentIndex;
    this._segmentOctant = segmentOctant;
    this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
  }
  getCoordinate () {
    return this.coord
  }
  print (out) {
    out.print(this.coord);
    out.print(' seg # = ' + this.segmentIndex);
  }
  compareTo (obj) {
    const other = obj;
    if (this.segmentIndex < other.segmentIndex) return -1
    if (this.segmentIndex > other.segmentIndex) return 1
    if (this.coord.equals2D(other.coord)) return 0
    return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)
  }
  isEndPoint (maxSegmentIndex) {
    if (this.segmentIndex === 0 && !this._isInterior) return true
    if (this.segmentIndex === maxSegmentIndex) return true
    return false
  }
  isInterior () {
    return this._isInterior
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return SegmentNode
  }
}

// import Iterator from '../../../../java/util/Iterator'
class SegmentNodeList {
  constructor () {
    this._nodeMap = new TreeMap();
    this._edge = null;
    let edge = arguments[0];
    this._edge = edge;
  }
  getSplitCoordinates () {
    const coordList = new CoordinateList();
    this.addEndpoints();
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      this.addEdgeCoordinates(eiPrev, ei, coordList);
      eiPrev = ei;
    }
    return coordList.toCoordinateArray()
  }
  addCollapsedNodes () {
    const collapsedVertexIndexes = new ArrayList();
    this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
    this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
    for (const it = collapsedVertexIndexes.iterator(); it.hasNext();) {
      const vertexIndex = it.next().intValue();
      this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);
    }
  }
  print (out) {
    out.println('Intersections:');
    for (const it = this.iterator(); it.hasNext();) {
      const ei = it.next();
      ei.print(out);
    }
  }
  findCollapsesFromExistingVertices (collapsedVertexIndexes) {
    for (let i = 0; i < this._edge.size() - 2; i++) {
      const p0 = this._edge.getCoordinate(i);
      // const p1 = this._edge.getCoordinate(i + 1)
      const p2 = this._edge.getCoordinate(i + 2);
      if (p0.equals2D(p2)) {
        collapsedVertexIndexes.add(new Integer(i + 1));
      }
    }
  }
  addEdgeCoordinates (ei0, ei1, coordList) {
    // let npts = ei1.segmentIndex - ei0.segmentIndex + 2
    const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
    const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
    // if (!useIntPt1) {
    //   npts--
    // }
    // const ipt = 0
    coordList.add(new Coordinate(ei0.coord), false);
    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
      coordList.add(this._edge.getCoordinate(i));
    }
    if (useIntPt1) {
      coordList.add(new Coordinate(ei1.coord));
    }
  }
  iterator () {
    return this._nodeMap.values().iterator()
  }
  addSplitEdges (edgeList) {
    this.addEndpoints();
    this.addCollapsedNodes();
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      const newEdge = this.createSplitEdge(eiPrev, ei);
      edgeList.add(newEdge);
      eiPrev = ei;
    }
  }
  findCollapseIndex (ei0, ei1, collapsedVertexIndex) {
    if (!ei0.coord.equals2D(ei1.coord)) return false
    let numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
    if (!ei1.isInterior()) {
      numVerticesBetween--;
    }
    if (numVerticesBetween === 1) {
      collapsedVertexIndex[0] = ei0.segmentIndex + 1;
      return true
    }
    return false
  }
  findCollapsesFromInsertedNodes (collapsedVertexIndexes) {
    const collapsedVertexIndex = new Array(1).fill(null);
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      const isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
      if (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));
      eiPrev = ei;
    }
  }
  getEdge () {
    return this._edge
  }
  addEndpoints () {
    const maxSegIndex = this._edge.size() - 1;
    this.add(this._edge.getCoordinate(0), 0);
    this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
  }
  createSplitEdge (ei0, ei1) {
    let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
    const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
    const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
    if (!useIntPt1) {
      npts--;
    }
    const pts = new Array(npts).fill(null);
    let ipt = 0;
    pts[ipt++] = new Coordinate(ei0.coord);
    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
      pts[ipt++] = this._edge.getCoordinate(i);
    }
    if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);
    return new NodedSegmentString(pts, this._edge.getData())
  }
  add (intPt, segmentIndex) {
    const eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
    const ei = this._nodeMap.get(eiNew);
    if (ei !== null) {
      Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');
      return ei
    }
    this._nodeMap.put(eiNew, eiNew);
    return eiNew
  }
  checkSplitEdgesCorrectness (splitEdges) {
    const edgePts = this._edge.getCoordinates();
    const split0 = splitEdges.get(0);
    const pt0 = split0.getCoordinate(0);
    if (!pt0.equals2D(edgePts[0])) throw new RuntimeException('bad split edge start point at ' + pt0)
    const splitn = splitEdges.get(splitEdges.size() - 1);
    const splitnPts = splitn.getCoordinates();
    const ptn = splitnPts[splitnPts.length - 1];
    if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException('bad split edge end point at ' + ptn)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SegmentNodeList
  }
}

// class NodeVertexIterator {
//   constructor () {
//     this._nodeList = null
//     this._edge = null
//     this._nodeIt = null
//     this._currNode = null
//     this._nextNode = null
//     this._currSegIndex = 0
//     let nodeList = arguments[0]
//     this._nodeList = nodeList
//     this._edge = nodeList.getEdge()
//     this._nodeIt = nodeList.iterator()
//     this.readNextNode()
//   }
//   next () {
//     if (this._currNode === null) {
//       this._currNode = this._nextNode
//       this._currSegIndex = this._currNode.segmentIndex
//       this.readNextNode()
//       return this._currNode
//     }
//     if (this._nextNode === null) return null
//     if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {
//       this._currNode = this._nextNode
//       this._currSegIndex = this._currNode.segmentIndex
//       this.readNextNode()
//       return this._currNode
//     }
//     if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}
//     return null
//   }
//   remove () {
//     // throw new UnsupportedOperationException(this.getClass().getName())
//   }
//   hasNext () {
//     if (this._nextNode === null) return false
//     return true
//   }
//   readNextNode () {
//     if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null
//   }
//   interfaces_ () {
//     return [Iterator]
//   }
//   getClass () {
//     return NodeVertexIterator
//   }
// }

class Octant {
  interfaces_ () {
    return []
  }
  getClass () {
    return Octant
  }
  static octant () {
    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
      const dx = arguments[0];
      const dy = arguments[1];
      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )')
      const adx = Math.abs(dx);
      const ady = Math.abs(dy);
      if (dx >= 0) {
        if (dy >= 0) {
          if (adx >= ady) return 0; else return 1
        } else {
          if (adx >= ady) return 7; else return 6
        }
      } else {
        if (dy >= 0) {
          if (adx >= ady) return 3; else return 2
        } else {
          if (adx >= ady) return 4; else return 5
        }
      }
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
      const p0 = arguments[0];
      const p1 = arguments[1];
      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0)
      return Octant.octant(dx, dy)
    }
  }
}

class SegmentString {
  getCoordinates () {}
  size () {}
  getCoordinate (i) {}
  isClosed () {}
  setData (data) {}
  getData () {}
  interfaces_ () {
    return []
  }
  getClass () {
    return SegmentString
  }
}

class NodableSegmentString {
  addIntersection (intPt, segmentIndex) {}
  interfaces_ () {
    return [SegmentString]
  }
  getClass () {
    return NodableSegmentString
  }
}

class NodedSegmentString {
  constructor () {
    this._nodeList = new SegmentNodeList(this);
    this._pts = null;
    this._data = null;
    const pts = arguments[0];
    const data = arguments[1];
    this._pts = pts;
    this._data = data;
  }
  getCoordinates () {
    return this._pts
  }
  size () {
    return this._pts.length
  }
  getCoordinate (i) {
    return this._pts[i]
  }
  isClosed () {
    return this._pts[0].equals(this._pts[this._pts.length - 1])
  }
  getSegmentOctant (index) {
    if (index === this._pts.length - 1) return -1
    return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))
  }
  setData (data) {
    this._data = data;
  }
  safeOctant (p0, p1) {
    if (p0.equals2D(p1)) return 0
    return Octant.octant(p0, p1)
  }
  getData () {
    return this._data
  }
  addIntersection () {
    if (arguments.length === 2) {
      const intPt = arguments[0];
      const segmentIndex = arguments[1];
      this.addIntersectionNode(intPt, segmentIndex);
    } else if (arguments.length === 4) {
      const li = arguments[0];
      const segmentIndex = arguments[1];
      // const geomIndex = arguments[2]
      const intIndex = arguments[3];
      var intPt = new Coordinate(li.getIntersection(intIndex));
      this.addIntersection(intPt, segmentIndex);
    }
  }
  toString () {
    return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))
  }
  getNodeList () {
    return this._nodeList
  }
  addIntersectionNode (intPt, segmentIndex) {
    var normalizedSegmentIndex = segmentIndex;
    var nextSegIndex = normalizedSegmentIndex + 1;
    if (nextSegIndex < this._pts.length) {
      var nextPt = this._pts[nextSegIndex];
      if (intPt.equals2D(nextPt)) {
        normalizedSegmentIndex = nextSegIndex;
      }
    }
    var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
    return ei
  }
  addIntersections (li, segmentIndex, geomIndex) {
    for (var i = 0; i < li.getIntersectionNum(); i++) {
      this.addIntersection(li, segmentIndex, geomIndex, i);
    }
  }
  interfaces_ () {
    return [NodableSegmentString]
  }
  getClass () {
    return NodedSegmentString
  }
  static getNodedSubstrings () {
    if (arguments.length === 1) {
      const segStrings = arguments[0];
      var resultEdgelist = new ArrayList();
      NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
      return resultEdgelist
    } else if (arguments.length === 2) {
      const segStrings = arguments[0];
      const resultEdgelist = arguments[1];
      for (var i = segStrings.iterator(); i.hasNext();) {
        var ss = i.next();
        ss.getNodeList().addSplitEdges(resultEdgelist);
      }
    }
  }
}

class LineSegment {
  constructor () {
    this.p0 = null;
    this.p1 = null;
    if (arguments.length === 0) {
      this.p0 = new Coordinate();
      this.p1 = new Coordinate();
    } else if (arguments.length === 1) {
      const ls = arguments[0];
      this.p0 = new Coordinate(ls.p0);
      this.p1 = new Coordinate(ls.p1);
    } else if (arguments.length === 2) {
      this.p0 = arguments[0];
      this.p1 = arguments[1];
    } else if (arguments.length === 4) {
      const x0 = arguments[0];
      const y0 = arguments[1];
      const x1 = arguments[2];
      const y1 = arguments[3];
      this.p0 = new Coordinate(x0, y0);
      this.p1 = new Coordinate(x1, y1);
    }
  }
  minX () {
    return Math.min(this.p0.x, this.p1.x)
  }
  orientationIndex () {
    if (arguments[0] instanceof LineSegment) {
      let seg = arguments[0];
      var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
      var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
      if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1)
      if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1)
      return 0
    } else if (arguments[0] instanceof Coordinate) {
      let p = arguments[0];
      return CGAlgorithms.orientationIndex(this.p0, this.p1, p)
    }
  }
  toGeometry (geomFactory) {
    return geomFactory.createLineString([this.p0, this.p1])
  }
  isVertical () {
    return this.p0.x === this.p1.x
  }
  equals (o) {
    if (!(o instanceof LineSegment)) {
      return false
    }
    var other = o;
    return this.p0.equals(other.p0) && this.p1.equals(other.p1)
  }
  intersection (line) {
    var li = new RobustLineIntersector();
    li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
    if (li.hasIntersection()) return li.getIntersection(0)
    return null
  }
  project () {
    if (arguments[0] instanceof Coordinate) {
      let p = arguments[0];
      if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p)
      var r = this.projectionFactor(p);
      var coord = new Coordinate();
      coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
      coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
      return coord
    } else if (arguments[0] instanceof LineSegment) {
      let seg = arguments[0];
      var pf0 = this.projectionFactor(seg.p0);
      var pf1 = this.projectionFactor(seg.p1);
      if (pf0 >= 1.0 && pf1 >= 1.0) return null
      if (pf0 <= 0.0 && pf1 <= 0.0) return null
      var newp0 = this.project(seg.p0);
      if (pf0 < 0.0) newp0 = this.p0;
      if (pf0 > 1.0) newp0 = this.p1;
      var newp1 = this.project(seg.p1);
      if (pf1 < 0.0) newp1 = this.p0;
      if (pf1 > 1.0) newp1 = this.p1;
      return new LineSegment(newp0, newp1)
    }
  }
  normalize () {
    if (this.p1.compareTo(this.p0) < 0) this.reverse();
  }
  angle () {
    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
  }
  getCoordinate (i) {
    if (i === 0) return this.p0
    return this.p1
  }
  distancePerpendicular (p) {
    return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1)
  }
  minY () {
    return Math.min(this.p0.y, this.p1.y)
  }
  midPoint () {
    return LineSegment.midPoint(this.p0, this.p1)
  }
  projectionFactor (p) {
    if (p.equals(this.p0)) return 0.0
    if (p.equals(this.p1)) return 1.0
    var dx = this.p1.x - this.p0.x;
    var dy = this.p1.y - this.p0.y;
    var len = dx * dx + dy * dy;
    if (len <= 0.0) return Double.NaN
    var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
    return r
  }
  closestPoints (line) {
    var intPt = this.intersection(line);
    if (intPt !== null) {
      return [intPt, intPt]
    }
    var closestPt = new Array(2).fill(null);
    var minDistance = Double.MAX_VALUE;
    var dist = null;
    var close00 = this.closestPoint(line.p0);
    minDistance = close00.distance(line.p0);
    closestPt[0] = close00;
    closestPt[1] = line.p0;
    var close01 = this.closestPoint(line.p1);
    dist = close01.distance(line.p1);
    if (dist < minDistance) {
      minDistance = dist;
      closestPt[0] = close01;
      closestPt[1] = line.p1;
    }
    var close10 = line.closestPoint(this.p0);
    dist = close10.distance(this.p0);
    if (dist < minDistance) {
      minDistance = dist;
      closestPt[0] = this.p0;
      closestPt[1] = close10;
    }
    var close11 = line.closestPoint(this.p1);
    dist = close11.distance(this.p1);
    if (dist < minDistance) {
      minDistance = dist;
      closestPt[0] = this.p1;
      closestPt[1] = close11;
    }
    return closestPt
  }
  closestPoint (p) {
    var factor = this.projectionFactor(p);
    if (factor > 0 && factor < 1) {
      return this.project(p)
    }
    var dist0 = this.p0.distance(p);
    var dist1 = this.p1.distance(p);
    if (dist0 < dist1) return this.p0
    return this.p1
  }
  maxX () {
    return Math.max(this.p0.x, this.p1.x)
  }
  getLength () {
    return this.p0.distance(this.p1)
  }
  compareTo (o) {
    var other = o;
    var comp0 = this.p0.compareTo(other.p0);
    if (comp0 !== 0) return comp0
    return this.p1.compareTo(other.p1)
  }
  reverse () {
    var temp = this.p0;
    this.p0 = this.p1;
    this.p1 = temp;
  }
  equalsTopo (other) {
    return this.p0.equals(other.p0) &&
          (this.p1.equals(other.p1) || this.p0.equals(other.p1)) &&
           this.p1.equals(other.p0)
  }
  lineIntersection (line) {
    try {
      var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
      return intPt
    } catch (ex) {
      if (ex instanceof NotRepresentableException) {} else throw ex
    } finally {}
    return null
  }
  maxY () {
    return Math.max(this.p0.y, this.p1.y)
  }
  pointAlongOffset (segmentLengthFraction, offsetDistance) {
    var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
    var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
    var dx = this.p1.x - this.p0.x;
    var dy = this.p1.y - this.p0.y;
    var len = Math.sqrt(dx * dx + dy * dy);
    var ux = 0.0;
    var uy = 0.0;
    if (offsetDistance !== 0.0) {
      if (len <= 0.0) throw new Error('Cannot compute offset from zero-length line segment')
      ux = offsetDistance * dx / len;
      uy = offsetDistance * dy / len;
    }
    var offsetx = segx - uy;
    var offsety = segy + ux;
    var coord = new Coordinate(offsetx, offsety);
    return coord
  }
  setCoordinates () {
    if (arguments.length === 1) {
      const ls = arguments[0];
      this.setCoordinates(ls.p0, ls.p1);
    } else if (arguments.length === 2) {
      const p0 = arguments[0];
      const p1 = arguments[1];
      this.p0.x = p0.x;
      this.p0.y = p0.y;
      this.p1.x = p1.x;
      this.p1.y = p1.y;
    }
  }
  segmentFraction (inputPt) {
    var segFrac = this.projectionFactor(inputPt);
    if (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;
    return segFrac
  }
  toString () {
    return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'
  }
  isHorizontal () {
    return this.p0.y === this.p1.y
  }
  distance () {
    if (arguments[0] instanceof LineSegment) {
      const ls = arguments[0];
      return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1)
    } else if (arguments[0] instanceof Coordinate) {
      const p = arguments[0];
      return CGAlgorithms.distancePointLine(p, this.p0, this.p1)
    }
  }
  pointAlong (segmentLengthFraction) {
    const coord = new Coordinate();
    coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
    coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
    return coord
  }
  hashCode () {
    let bits0 = Double.doubleToLongBits(this.p0.x);
    bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;
    let hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
    let bits1 = Double.doubleToLongBits(this.p1.x);
    bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;
    let hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
    return hash0 ^ hash1
  }
  interfaces_ () {
    return [Comparable, Serializable]
  }
  getClass () {
    return LineSegment
  }
  static midPoint (p0, p1) {
    return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)
  }
  static get serialVersionUID () { return 3252005833466256227 }
}

class MonotoneChainOverlapAction {
  constructor () {
    this.tempEnv1 = new Envelope();
    this.tempEnv2 = new Envelope();
    this._overlapSeg1 = new LineSegment();
    this._overlapSeg2 = new LineSegment();
  }
  overlap () {
    if (arguments.length === 2) {
      // const seg1 = arguments[0]
      // const seg2 = arguments[1]
    } else if (arguments.length === 4) {
      const mc1 = arguments[0];
      const start1 = arguments[1];
      const mc2 = arguments[2];
      const start2 = arguments[3];
      mc1.getLineSegment(start1, this._overlapSeg1);
      mc2.getLineSegment(start2, this._overlapSeg2);
      this.overlap(this._overlapSeg1, this._overlapSeg2);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MonotoneChainOverlapAction
  }
}

class MonotoneChain {
  constructor () {
    this._pts = null;
    this._start = null;
    this._end = null;
    this._env = null;
    this._context = null;
    this._id = null;
    const pts = arguments[0];
    const start = arguments[1];
    const end = arguments[2];
    const context = arguments[3];
    this._pts = pts;
    this._start = start;
    this._end = end;
    this._context = context;
  }
  getLineSegment (index, ls) {
    ls.p0 = this._pts[index];
    ls.p1 = this._pts[index + 1];
  }
  computeSelect (searchEnv, start0, end0, mcs) {
    const p0 = this._pts[start0];
    const p1 = this._pts[end0];
    mcs.tempEnv1.init(p0, p1);
    if (end0 - start0 === 1) {
      mcs.select(this, start0);
      return null
    }
    if (!searchEnv.intersects(mcs.tempEnv1)) return null
    const mid = Math.trunc((start0 + end0) / 2);
    if (start0 < mid) {
      this.computeSelect(searchEnv, start0, mid, mcs);
    }
    if (mid < end0) {
      this.computeSelect(searchEnv, mid, end0, mcs);
    }
  }
  getCoordinates () {
    const coord = new Array(this._end - this._start + 1).fill(null);
    let index = 0;
    for (let i = this._start; i <= this._end; i++) {
      coord[index++] = this._pts[i];
    }
    return coord
  }
  computeOverlaps (mc, mco) {
    this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
  }
  setId (id) {
    this._id = id;
  }
  select (searchEnv, mcs) {
    this.computeSelect(searchEnv, this._start, this._end, mcs);
  }
  getEnvelope () {
    if (this._env === null) {
      const p0 = this._pts[this._start];
      const p1 = this._pts[this._end];
      this._env = new Envelope(p0, p1);
    }
    return this._env
  }
  getEndIndex () {
    return this._end
  }
  getStartIndex () {
    return this._start
  }
  getContext () {
    return this._context
  }
  getId () {
    return this._id
  }
  computeOverlapsInternal (start0, end0, mc, start1, end1, mco) {
    const p00 = this._pts[start0];
    const p01 = this._pts[end0];
    const p10 = mc._pts[start1];
    const p11 = mc._pts[end1];
    if (end0 - start0 === 1 && end1 - start1 === 1) {
      mco.overlap(this, start0, mc, start1);
      return null
    }
    mco.tempEnv1.init(p00, p01);
    mco.tempEnv2.init(p10, p11);
    if (!mco.tempEnv1.intersects(mco.tempEnv2)) return null
    const mid0 = Math.trunc((start0 + end0) / 2);
    const mid1 = Math.trunc((start1 + end1) / 2);
    if (start0 < mid0) {
      if (start1 < mid1) this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);
      if (mid1 < end1) this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);
    }
    if (mid0 < end0) {
      if (start1 < mid1) this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);
      if (mid1 < end1) this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MonotoneChain
  }
}

class MonotoneChainBuilder {
  interfaces_ () {
    return []
  }
  getClass () {
    return MonotoneChainBuilder
  }
  static getChainStartIndices (pts) {
    let start = 0;
    const startIndexList = new ArrayList();
    startIndexList.add(new Integer(start));
    do {
      const last = MonotoneChainBuilder.findChainEnd(pts, start);
      startIndexList.add(new Integer(last));
      start = last;
    } while (start < pts.length - 1)
    const startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
    return startIndex
  }
  static findChainEnd (pts, start) {
    let safeStart = start;
    while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
      safeStart++;
    }
    if (safeStart >= pts.length - 1) {
      return pts.length - 1
    }
    const chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
    let last = start + 1;
    while (last < pts.length) {
      if (!pts[last - 1].equals2D(pts[last])) {
        const quad = Quadrant.quadrant(pts[last - 1], pts[last]);
        if (quad !== chainQuad) break
      }
      last++;
    }
    return last - 1
  }
  static getChains () {
    if (arguments.length === 1) {
      const pts = arguments[0];
      return MonotoneChainBuilder.getChains(pts, null)
    } else if (arguments.length === 2) {
      const pts = arguments[0];
      const context = arguments[1];
      const mcList = new ArrayList();
      const startIndex = MonotoneChainBuilder.getChainStartIndices(pts);
      for (let i = 0; i < startIndex.length - 1; i++) {
        const mc = new MonotoneChain(pts, startIndex[i], startIndex[i + 1], context);
        mcList.add(mc);
      }
      return mcList
    }
  }
  static toIntArray (list) {
    const array = new Array(list.size()).fill(null);
    for (let i = 0; i < array.length; i++) {
      array[i] = list.get(i).intValue();
    }
    return array
  }
}

class Noder {
  computeNodes (segStrings) {}
  getNodedSubstrings () {}
  interfaces_ () {
    return []
  }
  getClass () {
    return Noder
  }
}

class SinglePassNoder {
  constructor () {
    this._segInt = null;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      let segInt = arguments[0];
      this.setSegmentIntersector(segInt);
    }
  }
  setSegmentIntersector (segInt) {
    this._segInt = segInt;
  }
  interfaces_ () {
    return [Noder]
  }
  getClass () {
    return SinglePassNoder
  }
}

class MCIndexNoder extends SinglePassNoder {
  constructor (si) {
    if (si) super(si);
    else super();
    this._monoChains = new ArrayList();
    this._index = new STRtree();
    this._idCounter = 0;
    this._nodedSegStrings = null;
    this._nOverlaps = 0;
  }
  getMonotoneChains () {
    return this._monoChains
  }
  getNodedSubstrings () {
    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
  }
  getIndex () {
    return this._index
  }
  add (segStr) {
    const segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
    for (const i = segChains.iterator(); i.hasNext();) {
      const mc = i.next();
      mc.setId(this._idCounter++);
      this._index.insert(mc.getEnvelope(), mc);
      this._monoChains.add(mc);
    }
  }
  computeNodes (inputSegStrings) {
    this._nodedSegStrings = inputSegStrings;
    for (const i = inputSegStrings.iterator(); i.hasNext();) {
      this.add(i.next());
    }
    this.intersectChains();
  }
  intersectChains () {
    const overlapAction = new SegmentOverlapAction(this._segInt);
    for (const i = this._monoChains.iterator(); i.hasNext();) {
      const queryChain = i.next();
      const overlapChains = this._index.query(queryChain.getEnvelope());
      for (const j = overlapChains.iterator(); j.hasNext();) {
        const testChain = j.next();
        if (testChain.getId() > queryChain.getId()) {
          queryChain.computeOverlaps(testChain, overlapAction);
          this._nOverlaps++;
        }
        if (this._segInt.isDone()) return null
      }
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MCIndexNoder
  }
  static get SegmentOverlapAction () { return SegmentOverlapAction }
}

class SegmentOverlapAction extends MonotoneChainOverlapAction {
  constructor () {
    super();
    this._si = null;
    const si = arguments[0];
    this._si = si;
  }
  overlap () {
    if (arguments.length === 4) {
      const mc1 = arguments[0];
      const start1 = arguments[1];
      const mc2 = arguments[2];
      const start2 = arguments[3];
      const ss1 = mc1.getContext();
      const ss2 = mc2.getContext();
      this._si.processIntersections(ss1, start1, ss2, start2);
    } else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SegmentOverlapAction
  }
}

class BufferParameters {
  constructor () {
    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
    this._endCapStyle = BufferParameters.CAP_ROUND;
    this._joinStyle = BufferParameters.JOIN_ROUND;
    this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
    this._isSingleSided = false;
    this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;

    if (arguments.length === 0) {} else if (arguments.length === 1) {
      const quadrantSegments = arguments[0];
      this.setQuadrantSegments(quadrantSegments);
    } else if (arguments.length === 2) {
      const quadrantSegments = arguments[0];
      const endCapStyle = arguments[1];
      this.setQuadrantSegments(quadrantSegments);
      this.setEndCapStyle(endCapStyle);
    } else if (arguments.length === 4) {
      const quadrantSegments = arguments[0];
      const endCapStyle = arguments[1];
      const joinStyle = arguments[2];
      const mitreLimit = arguments[3];
      this.setQuadrantSegments(quadrantSegments);
      this.setEndCapStyle(endCapStyle);
      this.setJoinStyle(joinStyle);
      this.setMitreLimit(mitreLimit);
    }
  }
  getEndCapStyle () {
    return this._endCapStyle
  }
  isSingleSided () {
    return this._isSingleSided
  }
  setQuadrantSegments (quadSegs) {
    this._quadrantSegments = quadSegs;
    if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;
    if (this._quadrantSegments < 0) {
      this._joinStyle = BufferParameters.JOIN_MITRE;
      this._mitreLimit = Math.abs(this._quadrantSegments);
    }
    if (quadSegs <= 0) {
      this._quadrantSegments = 1;
    }
    if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
      this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
    }
  }
  getJoinStyle () {
    return this._joinStyle
  }
  setJoinStyle (joinStyle) {
    this._joinStyle = joinStyle;
  }
  setSimplifyFactor (simplifyFactor) {
    this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
  }
  getSimplifyFactor () {
    return this._simplifyFactor
  }
  getQuadrantSegments () {
    return this._quadrantSegments
  }
  setEndCapStyle (endCapStyle) {
    this._endCapStyle = endCapStyle;
  }
  getMitreLimit () {
    return this._mitreLimit
  }
  setMitreLimit (mitreLimit) {
    this._mitreLimit = mitreLimit;
  }
  setSingleSided (isSingleSided) {
    this._isSingleSided = isSingleSided;
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return BufferParameters
  }
  static bufferDistanceError (quadSegs) {
    var alpha = Math.PI / 2.0 / quadSegs;
    return 1 - Math.cos(alpha / 2.0)
  }
  static get CAP_ROUND () { return 1 }
  static get CAP_FLAT () { return 2 }
  static get CAP_SQUARE () { return 3 }
  static get JOIN_ROUND () { return 1 }
  static get JOIN_MITRE () { return 2 }
  static get JOIN_BEVEL () { return 3 }
  static get DEFAULT_QUADRANT_SEGMENTS () { return 8 }
  static get DEFAULT_MITRE_LIMIT () { return 5.0 }
  static get DEFAULT_SIMPLIFY_FACTOR () { return 0.01 }
}

class BufferInputLineSimplifier {
  constructor (inputLine) {
    this._distanceTol = null;
    this._isDeleted = null;
    this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;
    this._inputLine = inputLine || null;
  }
  isDeletable (i0, i1, i2, distanceTol) {
    const p0 = this._inputLine[i0];
    const p1 = this._inputLine[i1];
    const p2 = this._inputLine[i2];
    if (!this.isConcave(p0, p1, p2)) return false
    if (!this.isShallow(p0, p1, p2, distanceTol)) return false
    return this.isShallowSampled(p0, p1, i0, i2, distanceTol)
  }
  deleteShallowConcavities () {
    let index = 1;
    // const maxIndex = this._inputLine.length - 1
    let midIndex = this.findNextNonDeletedIndex(index);
    let lastIndex = this.findNextNonDeletedIndex(midIndex);
    let isChanged = false;
    while (lastIndex < this._inputLine.length) {
      let isMiddleVertexDeleted = false;
      if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {
        this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
        isMiddleVertexDeleted = true;
        isChanged = true;
      }
      if (isMiddleVertexDeleted) index = lastIndex; else index = midIndex;
      midIndex = this.findNextNonDeletedIndex(index);
      lastIndex = this.findNextNonDeletedIndex(midIndex);
    }
    return isChanged
  }
  isShallowConcavity (p0, p1, p2, distanceTol) {
    const orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
    const isAngleToSimplify = orientation === this._angleOrientation;
    if (!isAngleToSimplify) return false
    const dist = CGAlgorithms.distancePointLine(p1, p0, p2);
    return dist < distanceTol
  }
  isShallowSampled (p0, p2, i0, i2, distanceTol) {
    let inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
    if (inc <= 0) inc = 1;
    for (let i = i0; i < i2; i += inc) {
      if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false
    }
    return true
  }
  isConcave (p0, p1, p2) {
    const orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
    const isConcave = orientation === this._angleOrientation;
    return isConcave
  }
  simplify (distanceTol) {
    this._distanceTol = Math.abs(distanceTol);
    if (distanceTol < 0) this._angleOrientation = CGAlgorithms.CLOCKWISE;
    this._isDeleted = new Array(this._inputLine.length).fill(null);
    let isChanged = false;
    do {
      isChanged = this.deleteShallowConcavities();
    } while (isChanged)
    return this.collapseLine()
  }
  findNextNonDeletedIndex (index) {
    let next = index + 1;
    while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) next++;
    return next
  }
  isShallow (p0, p1, p2, distanceTol) {
    const dist = CGAlgorithms.distancePointLine(p1, p0, p2);
    return dist < distanceTol
  }
  collapseLine () {
    const coordList = new CoordinateList();
    for (let i = 0; i < this._inputLine.length; i++) {
      if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);
    }
    return coordList.toCoordinateArray()
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return BufferInputLineSimplifier
  }
  static simplify (inputLine, distanceTol) {
    const simp = new BufferInputLineSimplifier(inputLine);
    return simp.simplify(distanceTol)
  }
  static get INIT () { return 0 }
  static get DELETE () { return 1 }
  static get KEEP () { return 1 }
  static get NUM_PTS_TO_CHECK () { return 10 }
}

class OffsetSegmentString {
  constructor () {
    this._ptList = null;
    this._precisionModel = null;
    this._minimimVertexDistance = 0.0;
    this._ptList = new ArrayList();
  }
  getCoordinates () {
    const coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
    return coord
  }
  setPrecisionModel (precisionModel) {
    this._precisionModel = precisionModel;
  }
  addPt (pt) {
    const bufPt = new Coordinate(pt);
    this._precisionModel.makePrecise(bufPt);
    if (this.isRedundant(bufPt)) return null
    this._ptList.add(bufPt);
  }
  revere () {}
  addPts (pt, isForward) {
    if (isForward) {
      for (let i = 0; i < pt.length; i++) {
        this.addPt(pt[i]);
      }
    } else {
      for (let i = pt.length - 1; i >= 0; i--) {
        this.addPt(pt[i]);
      }
    }
  }
  isRedundant (pt) {
    if (this._ptList.size() < 1) return false
    const lastPt = this._ptList.get(this._ptList.size() - 1);
    const ptDist = pt.distance(lastPt);
    if (ptDist < this._minimimVertexDistance) return true
    return false
  }
  toString () {
    const fact = new GeometryFactory();
    const line = fact.createLineString(this.getCoordinates());
    return line.toString()
  }
  closeRing () {
    if (this._ptList.size() < 1) return null
    const startPt = new Coordinate(this._ptList.get(0));
    const lastPt = this._ptList.get(this._ptList.size() - 1);
    // const last2Pt = null
    // if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)
    if (startPt.equals(lastPt)) return null
    this._ptList.add(startPt);
  }
  setMinimumVertexDistance (minimimVertexDistance) {
    this._minimimVertexDistance = minimimVertexDistance;
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return OffsetSegmentString
  }
  static get COORDINATE_ARRAY_TYPE () { return new Array(0).fill(null) }
}

class Angle {
  interfaces_ () {
    return []
  }
  getClass () {
    return Angle
  }
  static toDegrees (radians) {
    return radians * 180 / Math.PI
  }
  static normalize (angle) {
    while (angle > Math.PI) angle -= Angle.PI_TIMES_2;
    while (angle <= -Math.PI) angle += Angle.PI_TIMES_2;
    return angle
  }
  static angle () {
    if (arguments.length === 1) {
      const p = arguments[0];
      return Math.atan2(p.y, p.x)
    } else if (arguments.length === 2) {
      const p0 = arguments[0];
      const p1 = arguments[1];
      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      return Math.atan2(dy, dx)
    }
  }
  static isAcute (p0, p1, p2) {
    const dx0 = p0.x - p1.x;
    const dy0 = p0.y - p1.y;
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dotprod = dx0 * dx1 + dy0 * dy1;
    return dotprod > 0
  }
  static isObtuse (p0, p1, p2) {
    const dx0 = p0.x - p1.x;
    const dy0 = p0.y - p1.y;
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dotprod = dx0 * dx1 + dy0 * dy1;
    return dotprod < 0
  }
  static interiorAngle (p0, p1, p2) {
    const anglePrev = Angle.angle(p1, p0);
    const angleNext = Angle.angle(p1, p2);
    return Math.abs(angleNext - anglePrev)
  }
  static normalizePositive (angle) {
    if (angle < 0.0) {
      while (angle < 0.0) angle += Angle.PI_TIMES_2;
      if (angle >= Angle.PI_TIMES_2) angle = 0.0;
    } else {
      while (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2;
      if (angle < 0.0) angle = 0.0;
    }
    return angle
  }
  static angleBetween (tip1, tail, tip2) {
    const a1 = Angle.angle(tail, tip1);
    const a2 = Angle.angle(tail, tip2);
    return Angle.diff(a1, a2)
  }
  static diff (ang1, ang2) {
    let delAngle = null;
    if (ang1 < ang2) {
      delAngle = ang2 - ang1;
    } else {
      delAngle = ang1 - ang2;
    }
    if (delAngle > Math.PI) {
      delAngle = 2 * Math.PI - delAngle;
    }
    return delAngle
  }
  static toRadians (angleDegrees) {
    return angleDegrees * Math.PI / 180.0
  }
  static getTurn (ang1, ang2) {
    const crossproduct = Math.sin(ang2 - ang1);
    if (crossproduct > 0) {
      return Angle.COUNTERCLOCKWISE
    }
    if (crossproduct < 0) {
      return Angle.CLOCKWISE
    }
    return Angle.NONE
  }
  static angleBetweenOriented (tip1, tail, tip2) {
    const a1 = Angle.angle(tail, tip1);
    const a2 = Angle.angle(tail, tip2);
    const angDel = a2 - a1;
    if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2
    if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2
    return angDel
  }
  static get PI_TIMES_2 () { return 2.0 * Math.PI }
  static get PI_OVER_2 () { return Math.PI / 2.0 }
  static get PI_OVER_4 () { return Math.PI / 4.0 }
  static get COUNTERCLOCKWISE () { return CGAlgorithms.COUNTERCLOCKWISE }
  static get CLOCKWISE () { return CGAlgorithms.CLOCKWISE }
  static get NONE () { return CGAlgorithms.COLLINEAR }
}

class OffsetSegmentGenerator {
  constructor () {
    this._maxCurveSegmentError = 0.0;
    this._filletAngleQuantum = null;
    this._closingSegLengthFactor = 1;
    this._segList = null;
    this._distance = 0.0;
    this._precisionModel = null;
    this._bufParams = null;
    this._li = null;
    this._s0 = null;
    this._s1 = null;
    this._s2 = null;
    this._seg0 = new LineSegment();
    this._seg1 = new LineSegment();
    this._offset0 = new LineSegment();
    this._offset1 = new LineSegment();
    this._side = 0;
    this._hasNarrowConcaveAngle = false;
    const precisionModel = arguments[0];
    const bufParams = arguments[1];
    const distance = arguments[2];
    this._precisionModel = precisionModel;
    this._bufParams = bufParams;
    this._li = new RobustLineIntersector();
    this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
    if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
    this.init(distance);
  }
  addNextSegment (p, addStartPoint) {
    this._s0 = this._s1;
    this._s1 = this._s2;
    this._s2 = p;
    this._seg0.setCoordinates(this._s0, this._s1);
    this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
    this._seg1.setCoordinates(this._s1, this._s2);
    this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
    if (this._s1.equals(this._s2)) return null
    const orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);
    const outsideTurn = (orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT) || (orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT);
    if (orientation === 0) {
      this.addCollinear(addStartPoint);
    } else if (outsideTurn) {
      this.addOutsideTurn(orientation, addStartPoint);
    } else {
      this.addInsideTurn(orientation, addStartPoint);
    }
  }
  addLineEndCap (p0, p1) {
    const seg = new LineSegment(p0, p1);
    const offsetL = new LineSegment();
    this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
    const offsetR = new LineSegment();
    this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
    const dx = p1.x - p0.x;
    const dy = p1.y - p0.y;
    const angle = Math.atan2(dy, dx);
    switch (this._bufParams.getEndCapStyle()) {
      case BufferParameters.CAP_ROUND:
        this._segList.addPt(offsetL.p1);
        this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);
        this._segList.addPt(offsetR.p1);
        break
      case BufferParameters.CAP_FLAT:
        this._segList.addPt(offsetL.p1);
        this._segList.addPt(offsetR.p1);
        break
      case BufferParameters.CAP_SQUARE:
        const squareCapSideOffset = new Coordinate();
        squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
        squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
        const squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
        const squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
        this._segList.addPt(squareCapLOffset);
        this._segList.addPt(squareCapROffset);
        break
      default:
    }
  }
  getCoordinates () {
    const pts = this._segList.getCoordinates();
    return pts
  }
  addMitreJoin (p, offset0, offset1, distance) {
    let isMitreWithinLimit = true;
    let intPt = null;
    try {
      intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
      const mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
      if (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;
    } catch (ex) {
      if (ex instanceof NotRepresentableException) {
        intPt = new Coordinate(0, 0);
        isMitreWithinLimit = false;
      } else throw ex
    } finally {}
    if (isMitreWithinLimit) {
      this._segList.addPt(intPt);
    } else {
      this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
    }
  }
  addFilletCorner (p, p0, p1, direction, radius) {
    const dx0 = p0.x - p.x;
    const dy0 = p0.y - p.y;
    let startAngle = Math.atan2(dy0, dx0);
    const dx1 = p1.x - p.x;
    const dy1 = p1.y - p.y;
    const endAngle = Math.atan2(dy1, dx1);
    if (direction === CGAlgorithms.CLOCKWISE) {
      if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;
    } else {
      if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;
    }
    this._segList.addPt(p0);
    this.addFilletArc(p, startAngle, endAngle, direction, radius);
    this._segList.addPt(p1);
  }
  addOutsideTurn (orientation, addStartPoint) {
    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
      this._segList.addPt(this._offset0.p1);
      return null
    }
    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
      this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
    } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
      this.addBevelJoin(this._offset0, this._offset1);
    } else {
      if (addStartPoint) this._segList.addPt(this._offset0.p1);
      this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
      this._segList.addPt(this._offset1.p0);
    }
  }
  createSquare (p) {
    this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
    this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
    this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
    this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
    this._segList.closeRing();
  }
  addSegments (pt, isForward) {
    this._segList.addPts(pt, isForward);
  }
  addFirstSegment () {
    this._segList.addPt(this._offset1.p0);
  }
  addLastSegment () {
    this._segList.addPt(this._offset1.p1);
  }
  initSideSegments (s1, s2, side) {
    this._s1 = s1;
    this._s2 = s2;
    this._side = side;
    this._seg1.setCoordinates(s1, s2);
    this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
  }
  addLimitedMitreJoin (offset0, offset1, distance, mitreLimit) {
    const basePt = this._seg0.p1;
    const ang0 = Angle.angle(basePt, this._seg0.p0);
    // const ang1 = Angle.angle(basePt, this._seg1.p1)
    const angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
    const angDiffHalf = angDiff / 2;
    const midAng = Angle.normalize(ang0 + angDiffHalf);
    const mitreMidAng = Angle.normalize(midAng + Math.PI);
    const mitreDist = mitreLimit * distance;
    const bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
    const bevelHalfLen = distance - bevelDelta;
    const bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
    const bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
    const bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
    const mitreMidLine = new LineSegment(basePt, bevelMidPt);
    const bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
    const bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
    if (this._side === Position.LEFT) {
      this._segList.addPt(bevelEndLeft);
      this._segList.addPt(bevelEndRight);
    } else {
      this._segList.addPt(bevelEndRight);
      this._segList.addPt(bevelEndLeft);
    }
  }
  computeOffsetSegment (seg, side, distance, offset) {
    const sideSign = side === Position.LEFT ? 1 : -1;
    const dx = seg.p1.x - seg.p0.x;
    const dy = seg.p1.y - seg.p0.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    const ux = sideSign * distance * dx / len;
    const uy = sideSign * distance * dy / len;
    offset.p0.x = seg.p0.x - uy;
    offset.p0.y = seg.p0.y + ux;
    offset.p1.x = seg.p1.x - uy;
    offset.p1.y = seg.p1.y + ux;
  }
  addFilletArc (p, startAngle, endAngle, direction, radius) {
    const directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;
    const totalAngle = Math.abs(startAngle - endAngle);
    const nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
    if (nSegs < 1) return null
    const initAngle = 0.0;
    const currAngleInc = totalAngle / nSegs;
    let currAngle = initAngle;
    const pt = new Coordinate();
    while (currAngle < totalAngle) {
      const angle = startAngle + directionFactor * currAngle;
      pt.x = p.x + radius * Math.cos(angle);
      pt.y = p.y + radius * Math.sin(angle);
      this._segList.addPt(pt);
      currAngle += currAngleInc;
    }
  }
  addInsideTurn (orientation, addStartPoint) {
    this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
    if (this._li.hasIntersection()) {
      this._segList.addPt(this._li.getIntersection(0));
    } else {
      this._hasNarrowConcaveAngle = true;
      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
        this._segList.addPt(this._offset0.p1);
      } else {
        this._segList.addPt(this._offset0.p1);
        if (this._closingSegLengthFactor > 0) {
          const mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
          this._segList.addPt(mid0);
          const mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
          this._segList.addPt(mid1);
        } else {
          this._segList.addPt(this._s1);
        }
        this._segList.addPt(this._offset1.p0);
      }
    }
  }
  createCircle (p) {
    const pt = new Coordinate(p.x + this._distance, p.y);
    this._segList.addPt(pt);
    this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);
    this._segList.closeRing();
  }
  addBevelJoin (offset0, offset1) {
    this._segList.addPt(offset0.p1);
    this._segList.addPt(offset1.p0);
  }
  init (distance) {
    this._distance = distance;
    this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
    this._segList = new OffsetSegmentString();
    this._segList.setPrecisionModel(this._precisionModel);
    this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
  }
  addCollinear (addStartPoint) {
    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
    const numInt = this._li.getIntersectionNum();
    if (numInt >= 2) {
      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
        if (addStartPoint) this._segList.addPt(this._offset0.p1);
        this._segList.addPt(this._offset1.p0);
      } else {
        this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);
      }
    }
  }
  closeRing () {
    this._segList.closeRing();
  }
  hasNarrowConcaveAngle () {
    return this._hasNarrowConcaveAngle
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return OffsetSegmentGenerator
  }
  static get OFFSET_SEGMENT_SEPARATION_FACTOR () { return 1.0E-3 }
  static get INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR () { return 1.0E-3 }
  static get CURVE_VERTEX_SNAP_DISTANCE_FACTOR () { return 1.0E-6 }
  static get MAX_CLOSING_SEG_LEN_FACTOR () { return 80 }
}

class OffsetCurveBuilder {
  constructor () {
    this._distance = 0.0;
    this._precisionModel = null;
    this._bufParams = null;
    const precisionModel = arguments[0];
    const bufParams = arguments[1];
    this._precisionModel = precisionModel;
    this._bufParams = bufParams;
  }
  getOffsetCurve (inputPts, distance) {
    this._distance = distance;
    if (distance === 0.0) return null
    let isRightSide = distance < 0.0;
    const posDistance = Math.abs(distance);
    const segGen = this.getSegGen(posDistance);
    if (inputPts.length <= 1) {
      this.computePointCurve(inputPts[0], segGen);
    } else {
      this.computeOffsetCurve(inputPts, isRightSide, segGen);
    }
    const curvePts = segGen.getCoordinates();
    if (isRightSide) CoordinateArrays.reverse(curvePts);
    return curvePts
  }
  computeSingleSidedBufferCurve (inputPts, isRightSide, segGen) {
    const distTol = this.simplifyTolerance(this._distance);
    if (isRightSide) {
      segGen.addSegments(inputPts, true);
      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
      const n2 = simp2.length - 1;
      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = n2 - 2; i >= 0; i--) {
        segGen.addNextSegment(simp2[i], true);
      }
    } else {
      segGen.addSegments(inputPts, false);
      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
      const n1 = simp1.length - 1;
      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = 2; i <= n1; i++) {
        segGen.addNextSegment(simp1[i], true);
      }
    }
    segGen.addLastSegment();
    segGen.closeRing();
  }
  computeRingBufferCurve (inputPts, side, segGen) {
    let distTol = this.simplifyTolerance(this._distance);
    if (side === Position.RIGHT) distTol = -distTol;
    const simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
    const n = simp.length - 1;
    segGen.initSideSegments(simp[n - 1], simp[0], side);
    for (let i = 1; i <= n; i++) {
      const addStartPoint = i !== 1;
      segGen.addNextSegment(simp[i], addStartPoint);
    }
    segGen.closeRing();
  }
  computeLineBufferCurve (inputPts, segGen) {
    const distTol = this.simplifyTolerance(this._distance);
    const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
    const n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
    for (let i = 2; i <= n1; i++) {
      segGen.addNextSegment(simp1[i], true);
    }
    segGen.addLastSegment();
    segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
    const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
    const n2 = simp2.length - 1;
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
    for (let i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
    segGen.addLastSegment();
    segGen.addLineEndCap(simp2[1], simp2[0]);
    segGen.closeRing();
  }
  computePointCurve (pt, segGen) {
    switch (this._bufParams.getEndCapStyle()) {
      case BufferParameters.CAP_ROUND:
        segGen.createCircle(pt);
        break
      case BufferParameters.CAP_SQUARE:
        segGen.createSquare(pt);
        break
      default:
    }
  }
  getLineCurve (inputPts, distance) {
    this._distance = distance;
    if (distance < 0.0 && !this._bufParams.isSingleSided()) return null
    if (distance === 0.0) return null
    const posDistance = Math.abs(distance);
    const segGen = this.getSegGen(posDistance);
    if (inputPts.length <= 1) {
      this.computePointCurve(inputPts[0], segGen);
    } else {
      if (this._bufParams.isSingleSided()) {
        let isRightSide = distance < 0.0;
        this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
      } else this.computeLineBufferCurve(inputPts, segGen);
    }
    const lineCoord = segGen.getCoordinates();
    return lineCoord
  }
  getBufferParameters () {
    return this._bufParams
  }
  simplifyTolerance (bufDistance) {
    return bufDistance * this._bufParams.getSimplifyFactor()
  }
  getRingCurve (inputPts, side, distance) {
    this._distance = distance;
    if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance)
    if (distance === 0.0) {
      return OffsetCurveBuilder.copyCoordinates(inputPts)
    }
    const segGen = this.getSegGen(distance);
    this.computeRingBufferCurve(inputPts, side, segGen);
    return segGen.getCoordinates()
  }
  computeOffsetCurve (inputPts, isRightSide, segGen) {
    const distTol = this.simplifyTolerance(this._distance);
    if (isRightSide) {
      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
      const n2 = simp2.length - 1;
      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = n2 - 2; i >= 0; i--) {
        segGen.addNextSegment(simp2[i], true);
      }
    } else {
      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
      const n1 = simp1.length - 1;
      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
      segGen.addFirstSegment();
      for (let i = 2; i <= n1; i++) {
        segGen.addNextSegment(simp1[i], true);
      }
    }
    segGen.addLastSegment();
  }
  getSegGen (distance) {
    return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return OffsetCurveBuilder
  }
  static copyCoordinates (pts) {
    const copy = new Array(pts.length).fill(null);
    for (let i = 0; i < copy.length; i++) {
      copy[i] = new Coordinate(pts[i]);
    }
    return copy
  }
}

class SubgraphDepthLocater {
  constructor () {
    this._subgraphs = null;
    this._seg = new LineSegment();
    this._cga = new CGAlgorithms();
    let subgraphs = arguments[0];
    this._subgraphs = subgraphs;
  }
  findStabbedSegments () {
    if (arguments.length === 1) {
      let stabbingRayLeftPt = arguments[0];
      const stabbedSegments = new ArrayList();
      for (let i = this._subgraphs.iterator(); i.hasNext();) {
        const bsg = i.next();
        const env = bsg.getEnvelope();
        if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue
        this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
      }
      return stabbedSegments
    } else if (arguments.length === 3) {
      if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {
        const stabbingRayLeftPt = arguments[0];
        const dirEdge = arguments[1];
        const stabbedSegments = arguments[2];
        const pts = dirEdge.getEdge().getCoordinates();
        for (let i = 0; i < pts.length - 1; i++) {
          this._seg.p0 = pts[i];
          this._seg.p1 = pts[i + 1];
          if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();
          const maxx = Math.max(this._seg.p0.x, this._seg.p1.x);
          if (maxx < stabbingRayLeftPt.x) continue
          if (this._seg.isHorizontal()) continue
          if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue
          if (CGAlgorithms.computeOrientation(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === CGAlgorithms.RIGHT) continue
          let depth = dirEdge.getDepth(Position.LEFT);
          if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);
          const ds = new DepthSegment(this._seg, depth);
          stabbedSegments.add(ds);
        }
      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {
        const stabbingRayLeftPt = arguments[0];
        const dirEdges = arguments[1];
        const stabbedSegments = arguments[2];
        for (let i = dirEdges.iterator(); i.hasNext();) {
          const de = i.next();
          if (!de.isForward()) continue
          this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);
        }
      }
    }
  }
  getDepth (p) {
    const stabbedSegments = this.findStabbedSegments(p);
    if (stabbedSegments.size() === 0) return 0
    const ds = Collections.min(stabbedSegments);
    return ds._leftDepth
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SubgraphDepthLocater
  }
  static get DepthSegment () { return DepthSegment }
}

class DepthSegment {
  constructor () {
    this._upwardSeg = null;
    this._leftDepth = null;
    const seg = arguments[0];
    const depth = arguments[1];
    this._upwardSeg = new LineSegment(seg);
    this._leftDepth = depth;
  }
  compareTo (obj) {
    const other = obj;
    if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1
    if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1
    let orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
    if (orientIndex !== 0) return orientIndex
    orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
    if (orientIndex !== 0) return orientIndex
    return this._upwardSeg.compareTo(other._upwardSeg)
  }
  compareX (seg0, seg1) {
    const compare0 = seg0.p0.compareTo(seg1.p0);
    if (compare0 !== 0) return compare0
    return seg0.p1.compareTo(seg1.p1)
  }
  toString () {
    return this._upwardSeg.toString()
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return DepthSegment
  }
}

class Triangle {
  constructor (p0, p1, p2) {
    this.p0 = p0 || null;
    this.p1 = p1 || null;
    this.p2 = p2 || null;
  }
  area () {
    return Triangle.area(this.p0, this.p1, this.p2)
  }
  signedArea () {
    return Triangle.signedArea(this.p0, this.p1, this.p2)
  }
  interpolateZ (p) {
    if (p === null) throw new IllegalArgumentException('Supplied point is null.')
    return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)
  }
  longestSideLength () {
    return Triangle.longestSideLength(this.p0, this.p1, this.p2)
  }
  isAcute () {
    return Triangle.isAcute(this.p0, this.p1, this.p2)
  }
  circumcentre () {
    return Triangle.circumcentre(this.p0, this.p1, this.p2)
  }
  area3D () {
    return Triangle.area3D(this.p0, this.p1, this.p2)
  }
  centroid () {
    return Triangle.centroid(this.p0, this.p1, this.p2)
  }
  inCentre () {
    return Triangle.inCentre(this.p0, this.p1, this.p2)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return Triangle
  }
  static area (a, b, c) {
    return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)
  }
  static signedArea (a, b, c) {
    return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2
  }
  static det (m00, m01, m10, m11) {
    return m00 * m11 - m01 * m10
  }
  static interpolateZ (p, v0, v1, v2) {
    var x0 = v0.x;
    var y0 = v0.y;
    var a = v1.x - x0;
    var b = v2.x - x0;
    var c = v1.y - y0;
    var d = v2.y - y0;
    var det = a * d - b * c;
    var dx = p.x - x0;
    var dy = p.y - y0;
    var t = (d * dx - b * dy) / det;
    var u = (-c * dx + a * dy) / det;
    var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
    return z
  }
  static longestSideLength (a, b, c) {
    var lenAB = a.distance(b);
    var lenBC = b.distance(c);
    var lenCA = c.distance(a);
    var maxLen = lenAB;
    if (lenBC > maxLen) maxLen = lenBC;
    if (lenCA > maxLen) maxLen = lenCA;
    return maxLen
  }
  static isAcute (a, b, c) {
    if (!Angle.isAcute(a, b, c)) return false
    if (!Angle.isAcute(b, c, a)) return false
    if (!Angle.isAcute(c, a, b)) return false
    return true
  }
  static circumcentre (a, b, c) {
    var cx = c.x;
    var cy = c.y;
    var ax = a.x - cx;
    var ay = a.y - cy;
    var bx = b.x - cx;
    var by = b.y - cy;
    var denom = 2 * Triangle.det(ax, ay, bx, by);
    var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
    var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
    var ccx = cx - numx / denom;
    var ccy = cy + numy / denom;
    return new Coordinate(ccx, ccy)
  }
  static perpendicularBisector (a, b) {
    var dx = b.x - a.x;
    var dy = b.y - a.y;
    var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
    var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
    return new HCoordinate(l1, l2)
  }
  static angleBisector (a, b, c) {
    var len0 = b.distance(a);
    var len2 = b.distance(c);
    var frac = len0 / (len0 + len2);
    var dx = c.x - a.x;
    var dy = c.y - a.y;
    var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
    return splitPt
  }
  static area3D (a, b, c) {
    var ux = b.x - a.x;
    var uy = b.y - a.y;
    var uz = b.z - a.z;
    var vx = c.x - a.x;
    var vy = c.y - a.y;
    var vz = c.z - a.z;
    var crossx = uy * vz - uz * vy;
    var crossy = uz * vx - ux * vz;
    var crossz = ux * vy - uy * vx;
    var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
    var area3D = Math.sqrt(absSq) / 2;
    return area3D
  }
  static centroid (a, b, c) {
    var x = (a.x + b.x + c.x) / 3;
    var y = (a.y + b.y + c.y) / 3;
    return new Coordinate(x, y)
  }
  static inCentre (a, b, c) {
    var len0 = b.distance(c);
    var len1 = a.distance(c);
    var len2 = a.distance(b);
    var circum = len0 + len1 + len2;
    var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
    var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
    return new Coordinate(inCentreX, inCentreY)
  }
}

class OffsetCurveSetBuilder {
  constructor () {
    this._inputGeom = null;
    this._distance = null;
    this._curveBuilder = null;
    this._curveList = new ArrayList();
    const inputGeom = arguments[0];
    const distance = arguments[1];
    const curveBuilder = arguments[2];
    this._inputGeom = inputGeom;
    this._distance = distance;
    this._curveBuilder = curveBuilder;
  }
  addPoint (p) {
    if (this._distance <= 0.0) return null
    const coord = p.getCoordinates();
    const curve = this._curveBuilder.getLineCurve(coord, this._distance);
    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
  }
  addPolygon (p) {
    let offsetDistance = this._distance;
    let offsetSide = Position.LEFT;
    if (this._distance < 0.0) {
      offsetDistance = -this._distance;
      offsetSide = Position.RIGHT;
    }
    const shell = p.getExteriorRing();
    const shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
    if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null
    if (this._distance <= 0.0 && shellCoord.length < 3) return null
    this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
    for (let i = 0; i < p.getNumInteriorRing(); i++) {
      const hole = p.getInteriorRingN(i);
      const holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
      if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue
      this.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
    }
  }
  isTriangleErodedCompletely (triangleCoord, bufferDistance) {
    const tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
    const inCentre = tri.inCentre();
    const distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);
    return distToCentre < Math.abs(bufferDistance)
  }
  addLineString (line) {
    if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null
    const coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
    const curve = this._curveBuilder.getLineCurve(coord, this._distance);
    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
  }
  addCurve (coord, leftLoc, rightLoc) {
    if (coord === null || coord.length < 2) return null
    const e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
    this._curveList.add(e);
  }
  getCurves () {
    this.add(this._inputGeom);
    return this._curveList
  }
  addPolygonRing (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
    if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null
    let leftLoc = cwLeftLoc;
    let rightLoc = cwRightLoc;
    if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {
      leftLoc = cwRightLoc;
      rightLoc = cwLeftLoc;
      side = Position.opposite(side);
    }
    const curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
    this.addCurve(curve, leftLoc, rightLoc);
  }
  add (g) {
    if (g.isEmpty()) return null
    if (g instanceof Polygon) this.addPolygon(g);
    else if (g instanceof LineString) this.addLineString(g);
    else if (g instanceof Point) this.addPoint(g);
    else if (g instanceof MultiPoint) this.addCollection(g);
    else if (g instanceof MultiLineString) this.addCollection(g);
    else if (g instanceof MultiPolygon) this.addCollection(g);
    else if (g instanceof GeometryCollection) this.addCollection(g);
    // else throw new UnsupportedOperationException(g.getClass().getName())
  }
  isErodedCompletely (ring, bufferDistance) {
    const ringCoord = ring.getCoordinates();
    // const minDiam = 0.0
    if (ringCoord.length < 4) return bufferDistance < 0
    if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance)
    const env = ring.getEnvelopeInternal();
    const envMinDimension = Math.min(env.getHeight(), env.getWidth());
    if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true
    return false
  }
  addCollection (gc) {
    for (let i = 0; i < gc.getNumGeometries(); i++) {
      const g = gc.getGeometryN(i);
      this.add(g);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return OffsetCurveSetBuilder
  }
}

class PointOnGeometryLocator {
  locate (p) {}
  interfaces_ () {
    return []
  }
  getClass () {
    return PointOnGeometryLocator
  }
}

class GeometryCollectionIterator {
  constructor () {
    this._parent = null;
    this._atStart = null;
    this._max = null;
    this._index = null;
    this._subcollectionIterator = null;
    let parent = arguments[0];
    this._parent = parent;
    this._atStart = true;
    this._index = 0;
    this._max = parent.getNumGeometries();
  }
  next () {
    if (this._atStart) {
      this._atStart = false;
      if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;
      return this._parent
    }
    if (this._subcollectionIterator !== null) {
      if (this._subcollectionIterator.hasNext()) {
        return this._subcollectionIterator.next()
      } else {
        this._subcollectionIterator = null;
      }
    }
    if (this._index >= this._max) {
      throw new NoSuchElementException()
    }
    var obj = this._parent.getGeometryN(this._index++);
    if (obj instanceof GeometryCollection) {
      this._subcollectionIterator = new GeometryCollectionIterator(obj);
      return this._subcollectionIterator.next()
    }
    return obj
  }
  remove () {
    throw new Error(this.getClass().getName())
  }
  hasNext () {
    if (this._atStart) {
      return true
    }
    if (this._subcollectionIterator !== null) {
      if (this._subcollectionIterator.hasNext()) {
        return true
      }
      this._subcollectionIterator = null;
    }
    if (this._index >= this._max) {
      return false
    }
    return true
  }
  interfaces_ () {
    return [Iterator]
  }
  getClass () {
    return GeometryCollectionIterator
  }
  static isAtomic (geom) {
    return !(geom instanceof GeometryCollection)
  }
}

class SimplePointInAreaLocator {
  constructor () {
    this._geom = null;
    const geom = arguments[0];
    this._geom = geom;
  }
  locate (p) {
    return SimplePointInAreaLocator.locate(p, this._geom)
  }
  interfaces_ () {
    return [PointOnGeometryLocator]
  }
  getClass () {
    return SimplePointInAreaLocator
  }
  static isPointInRing (p, ring) {
    if (!ring.getEnvelopeInternal().intersects(p)) return false
    return CGAlgorithms.isPointInRing(p, ring.getCoordinates())
  }
  static containsPointInPolygon (p, poly) {
    if (poly.isEmpty()) return false
    const shell = poly.getExteriorRing();
    if (!SimplePointInAreaLocator.isPointInRing(p, shell)) return false
    for (let i = 0; i < poly.getNumInteriorRing(); i++) {
      const hole = poly.getInteriorRingN(i);
      if (SimplePointInAreaLocator.isPointInRing(p, hole)) return false
    }
    return true
  }
  static containsPoint (p, geom) {
    if (geom instanceof Polygon) {
      return SimplePointInAreaLocator.containsPointInPolygon(p, geom)
    } else if (geom instanceof GeometryCollection) {
      const geomi = new GeometryCollectionIterator(geom);
      while (geomi.hasNext()) {
        const g2 = geomi.next();
        if (g2 !== geom) if (SimplePointInAreaLocator.containsPoint(p, g2)) return true
      }
    }
    return false
  }
  static locate (p, geom) {
    if (geom.isEmpty()) return Location.EXTERIOR
    if (SimplePointInAreaLocator.containsPoint(p, geom)) return Location.INTERIOR
    return Location.EXTERIOR
  }
}

class EdgeEndStar {
  constructor () {
    this._edgeMap = new TreeMap();
    this._edgeList = null;
    this._ptInAreaLocation = [Location.NONE, Location.NONE];
  }
  getNextCW (ee) {
    this.getEdges();
    const i = this._edgeList.indexOf(ee);
    let iNextCW = i - 1;
    if (i === 0) iNextCW = this._edgeList.size() - 1;
    return this._edgeList.get(iNextCW)
  }
  propagateSideLabels (geomIndex) {
    let startLoc = Location.NONE;
    for (const it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);
    }
    if (startLoc === Location.NONE) return null
    let currLoc = startLoc;
    for (const it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      if (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);
      if (label.isArea(geomIndex)) {
        const leftLoc = label.getLocation(geomIndex, Position.LEFT);
        const rightLoc = label.getLocation(geomIndex, Position.RIGHT);
        if (rightLoc !== Location.NONE) {
          if (rightLoc !== currLoc) throw new TopologyException('side location conflict', e.getCoordinate())
          if (leftLoc === Location.NONE) {
            Assert.shouldNeverReachHere('found single null side (at ' + e.getCoordinate() + ')');
          }
          currLoc = leftLoc;
        } else {
          Assert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');
          label.setLocation(geomIndex, Position.RIGHT, currLoc);
          label.setLocation(geomIndex, Position.LEFT, currLoc);
        }
      }
    }
  }
  getCoordinate () {
    const it = this.iterator();
    if (!it.hasNext()) return null
    const e = it.next();
    return e.getCoordinate()
  }
  print (out) {
    System.out.println('EdgeEndStar:   ' + this.getCoordinate());
    for (const it = this.iterator(); it.hasNext();) {
      const e = it.next();
      e.print(out);
    }
  }
  isAreaLabelsConsistent (geomGraph) {
    this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
    return this.checkAreaLabelsConsistent(0)
  }
  checkAreaLabelsConsistent (geomIndex) {
    const edges = this.getEdges();
    if (edges.size() <= 0) return true
    const lastEdgeIndex = edges.size() - 1;
    const startLabel = edges.get(lastEdgeIndex).getLabel();
    const startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
    Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');
    let currLoc = startLoc;
    for (const it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');
      const leftLoc = label.getLocation(geomIndex, Position.LEFT);
      const rightLoc = label.getLocation(geomIndex, Position.RIGHT);
      if (leftLoc === rightLoc) {
        return false
      }
      if (rightLoc !== currLoc) {
        return false
      }
      currLoc = leftLoc;
    }
    return true
  }
  findIndex (eSearch) {
    this.iterator();
    for (let i = 0; i < this._edgeList.size(); i++) {
      const e = this._edgeList.get(i);
      if (e === eSearch) return i
    }
    return -1
  }
  iterator () {
    return this.getEdges().iterator()
  }
  getEdges () {
    if (this._edgeList === null) {
      this._edgeList = new ArrayList(this._edgeMap.values());
    }
    return this._edgeList
  }
  getLocation (geomIndex, p, geom) {
    if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
      this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
    }
    return this._ptInAreaLocation[geomIndex]
  }
  toString () {
    const buf = new StringBuffer();
    buf.append('EdgeEndStar:   ' + this.getCoordinate());
    buf.append('\n');
    for (const it = this.iterator(); it.hasNext();) {
      const e = it.next();
      buf.append(e);
      buf.append('\n');
    }
    return buf.toString()
  }
  computeEdgeEndLabels (boundaryNodeRule) {
    for (const it = this.iterator(); it.hasNext();) {
      const ee = it.next();
      ee.computeLabel(boundaryNodeRule);
    }
  }
  computeLabelling (geomGraph) {
    this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
    this.propagateSideLabels(0);
    this.propagateSideLabels(1);
    const hasDimensionalCollapseEdge = [false, false];
    for (const it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      for (let geomi = 0; geomi < 2; geomi++) {
        if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;
      }
    }
    for (const it = this.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      for (let geomi = 0; geomi < 2; geomi++) {
        if (label.isAnyNull(geomi)) {
          let loc = Location.NONE;
          if (hasDimensionalCollapseEdge[geomi]) {
            loc = Location.EXTERIOR;
          } else {
            const p = e.getCoordinate();
            loc = this.getLocation(geomi, p, geomGraph);
          }
          label.setAllLocationsIfNull(geomi, loc);
        }
      }
    }
  }
  getDegree () {
    return this._edgeMap.size()
  }
  insertEdgeEnd (e, obj) {
    this._edgeMap.put(e, obj);
    this._edgeList = null;
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return EdgeEndStar
  }
}

class DirectedEdgeStar extends EdgeEndStar {
  constructor () {
    super();
    this._resultAreaEdgeList = null;
    this._label = null;
    this._SCANNING_FOR_INCOMING = 1;
    this._LINKING_TO_OUTGOING = 2;
  }
  linkResultDirectedEdges () {
    this.getResultAreaEdges();
    let firstOut = null;
    let incoming = null;
    let state = this._SCANNING_FOR_INCOMING;
    for (let i = 0; i < this._resultAreaEdgeList.size(); i++) {
      const nextOut = this._resultAreaEdgeList.get(i);
      const nextIn = nextOut.getSym();
      if (!nextOut.getLabel().isArea()) continue
      if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;
      switch (state) {
        case this._SCANNING_FOR_INCOMING:
          if (!nextIn.isInResult()) continue
          incoming = nextIn;
          state = this._LINKING_TO_OUTGOING;
          break
        case this._LINKING_TO_OUTGOING:
          if (!nextOut.isInResult()) continue
          incoming.setNext(nextOut);
          state = this._SCANNING_FOR_INCOMING;
          break
        default:
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      if (firstOut === null) throw new TopologyException('no outgoing dirEdge found', this.getCoordinate())
      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');
      incoming.setNext(firstOut);
    }
  }
  insert (ee) {
    const de = ee;
    this.insertEdgeEnd(de, de);
  }
  getRightmostEdge () {
    const edges = this.getEdges();
    const size = edges.size();
    if (size < 1) return null
    const de0 = edges.get(0);
    if (size === 1) return de0
    const deLast = edges.get(size - 1);
    const quad0 = de0.getQuadrant();
    const quad1 = deLast.getQuadrant();
    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0; else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast; else {
      // const nonHorizontalEdge = null
      if (de0.getDy() !== 0) return de0; else if (deLast.getDy() !== 0) return deLast
    }
    Assert.shouldNeverReachHere('found two horizontal edges incident on node');
    return null
  }
  print (out) {
    System.out.println('DirectedEdgeStar: ' + this.getCoordinate());
    for (const it = this.iterator(); it.hasNext();) {
      const de = it.next();
      out.print('out ');
      de.print(out);
      out.println();
      out.print('in ');
      de.getSym().print(out);
      out.println();
    }
  }
  getResultAreaEdges () {
    if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList
    this._resultAreaEdgeList = new ArrayList();
    for (const it = this.iterator(); it.hasNext();) {
      const de = it.next();
      if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);
    }
    return this._resultAreaEdgeList
  }
  updateLabelling (nodeLabel) {
    for (const it = this.iterator(); it.hasNext();) {
      const de = it.next();
      const label = de.getLabel();
      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
    }
  }
  linkAllDirectedEdges () {
    this.getEdges();
    let prevOut = null;
    let firstIn = null;
    for (let i = this._edgeList.size() - 1; i >= 0; i--) {
      const nextOut = this._edgeList.get(i);
      const nextIn = nextOut.getSym();
      if (firstIn === null) firstIn = nextIn;
      if (prevOut !== null) nextIn.setNext(prevOut);
      prevOut = nextOut;
    }
    firstIn.setNext(prevOut);
  }
  computeDepths () {
    if (arguments.length === 1) {
      let de = arguments[0];
      const edgeIndex = this.findIndex(de);
      // const label = de.getLabel()
      const startDepth = de.getDepth(Position.LEFT);
      const targetLastDepth = de.getDepth(Position.RIGHT);
      const nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
      const lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
      if (lastDepth !== targetLastDepth) throw new TopologyException('depth mismatch at ' + de.getCoordinate())
    } else if (arguments.length === 3) {
      const startIndex = arguments[0];
      const endIndex = arguments[1];
      const startDepth = arguments[2];
      let currDepth = startDepth;
      for (let i = startIndex; i < endIndex; i++) {
        const nextDe = this._edgeList.get(i);
        // const label = nextDe.getLabel()
        nextDe.setEdgeDepths(Position.RIGHT, currDepth);
        currDepth = nextDe.getDepth(Position.LEFT);
      }
      return currDepth
    }
  }
  mergeSymLabels () {
    for (const it = this.iterator(); it.hasNext();) {
      const de = it.next();
      const label = de.getLabel();
      label.merge(de.getSym().getLabel());
    }
  }
  linkMinimalDirectedEdges (er) {
    let firstOut = null;
    let incoming = null;
    let state = this._SCANNING_FOR_INCOMING;
    for (let i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
      const nextOut = this._resultAreaEdgeList.get(i);
      const nextIn = nextOut.getSym();
      if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;
      switch (state) {
        case this._SCANNING_FOR_INCOMING:
          if (nextIn.getEdgeRing() !== er) continue
          incoming = nextIn;
          state = this._LINKING_TO_OUTGOING;
          break
        case this._LINKING_TO_OUTGOING:
          if (nextOut.getEdgeRing() !== er) continue
          incoming.setNextMin(nextOut);
          state = this._SCANNING_FOR_INCOMING;
          break
        default:
      }
    }
    if (state === this._LINKING_TO_OUTGOING) {
      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');
      incoming.setNextMin(firstOut);
    }
  }
  getOutgoingDegree () {
    if (arguments.length === 0) {
      let degree = 0;
      for (const it = this.iterator(); it.hasNext();) {
        const de = it.next();
        if (de.isInResult()) degree++;
      }
      return degree
    } else if (arguments.length === 1) {
      let er = arguments[0];
      let degree = 0;
      for (const it = this.iterator(); it.hasNext();) {
        const de = it.next();
        if (de.getEdgeRing() === er) degree++;
      }
      return degree
    }
  }
  getLabel () {
    return this._label
  }
  findCoveredLineEdges () {
    let startLoc = Location.NONE;
    for (const it = this.iterator(); it.hasNext();) {
      const nextOut = it.next();
      const nextIn = nextOut.getSym();
      if (!nextOut.isLineEdge()) {
        if (nextOut.isInResult()) {
          startLoc = Location.INTERIOR;
          break
        }
        if (nextIn.isInResult()) {
          startLoc = Location.EXTERIOR;
          break
        }
      }
    }
    if (startLoc === Location.NONE) return null
    let currLoc = startLoc;
    for (const it = this.iterator(); it.hasNext();) {
      const nextOut = it.next();
      const nextIn = nextOut.getSym();
      if (nextOut.isLineEdge()) {
        nextOut.getEdge().setCovered(currLoc === Location.INTERIOR);
      } else {
        if (nextOut.isInResult()) currLoc = Location.EXTERIOR;
        if (nextIn.isInResult()) currLoc = Location.INTERIOR;
      }
    }
  }
  computeLabelling (geom) {
    EdgeEndStar.prototype.computeLabelling.call(this, geom);
    this._label = new Label(Location.NONE);
    for (const it = this.iterator(); it.hasNext();) {
      const ee = it.next();
      const e = ee.getEdge();
      const eLabel = e.getLabel();
      for (let i = 0; i < 2; i++) {
        const eLoc = eLabel.getLocation(i);
        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);
      }
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return DirectedEdgeStar
  }
}

class OverlayNodeFactory extends NodeFactory {
  createNode (coord) {
    return new Node(coord, new DirectedEdgeStar())
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return OverlayNodeFactory
  }
}

class OrientedCoordinateArray {
  constructor () {
    this._pts = null;
    this._orientation = null;
    const pts = arguments[0];
    this._pts = pts;
    this._orientation = OrientedCoordinateArray.orientation(pts);
  }
  compareTo (o1) {
    const oca = o1;
    const comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
    return comp
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return OrientedCoordinateArray
  }
  static orientation (pts) {
    return CoordinateArrays.increasingDirection(pts) === 1
  }
  static compareOriented (pts1, orientation1, pts2, orientation2) {
    const dir1 = orientation1 ? 1 : -1;
    const dir2 = orientation2 ? 1 : -1;
    const limit1 = orientation1 ? pts1.length : -1;
    const limit2 = orientation2 ? pts2.length : -1;
    let i1 = orientation1 ? 0 : pts1.length - 1;
    let i2 = orientation2 ? 0 : pts2.length - 1;
    // const comp = 0
    while (true) {
      const compPt = pts1[i1].compareTo(pts2[i2]);
      if (compPt !== 0) return compPt
      i1 += dir1;
      i2 += dir2;
      const done1 = i1 === limit1;
      const done2 = i2 === limit2;
      if (done1 && !done2) return -1
      if (!done1 && done2) return 1
      if (done1 && done2) return 0
    }
  }
}

class EdgeList {
  constructor () {
    this._edges = new ArrayList();
    this._ocaMap = new TreeMap();
  }
  print (out) {
    out.print('MULTILINESTRING ( ');
    for (let j = 0; j < this._edges.size(); j++) {
      const e = this._edges.get(j);
      if (j > 0) out.print(',');
      out.print('(');
      const pts = e.getCoordinates();
      for (let i = 0; i < pts.length; i++) {
        if (i > 0) out.print(',');
        out.print(pts[i].x + ' ' + pts[i].y);
      }
      out.println(')');
    }
    out.print(')  ');
  }
  addAll (edgeColl) {
    for (const i = edgeColl.iterator(); i.hasNext();) {
      this.add(i.next());
    }
  }
  findEdgeIndex (e) {
    for (let i = 0; i < this._edges.size(); i++) {
      if (this._edges.get(i).equals(e)) return i
    }
    return -1
  }
  iterator () {
    return this._edges.iterator()
  }
  getEdges () {
    return this._edges
  }
  get (i) {
    return this._edges.get(i)
  }
  findEqualEdge (e) {
    const oca = new OrientedCoordinateArray(e.getCoordinates());
    const matchEdge = this._ocaMap.get(oca);
    return matchEdge
  }
  add (e) {
    this._edges.add(e);
    const oca = new OrientedCoordinateArray(e.getCoordinates());
    this._ocaMap.put(oca, e);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return EdgeList
  }
}

class SegmentIntersector {
  processIntersections (e0, segIndex0, e1, segIndex1) {}
  isDone () {}
  interfaces_ () {
    return []
  }
  getClass () {
    return SegmentIntersector
  }
}

class IntersectionAdder {
  constructor () {
    this._hasIntersection = false;
    this._hasProper = false;
    this._hasProperInterior = false;
    this._hasInterior = false;
    this._properIntersectionPoint = null;
    this._li = null;
    this._isSelfIntersection = null;
    this.numIntersections = 0;
    this.numInteriorIntersections = 0;
    this.numProperIntersections = 0;
    this.numTests = 0;
    const li = arguments[0];
    this._li = li;
  }
  isTrivialIntersection (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1) {
      if (this._li.getIntersectionNum() === 1) {
        if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true
        if (e0.isClosed()) {
          const maxSegIndex = e0.size() - 1;
          if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
              (segIndex1 === 0 && segIndex0 === maxSegIndex)) {
            return true
          }
        }
      }
    }
    return false
  }
  getProperIntersectionPoint () {
    return this._properIntersectionPoint
  }
  hasProperInteriorIntersection () {
    return this._hasProperInterior
  }
  getLineIntersector () {
    return this._li
  }
  hasProperIntersection () {
    return this._hasProper
  }
  processIntersections (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1 && segIndex0 === segIndex1) return null
    this.numTests++;
    const p00 = e0.getCoordinates()[segIndex0];
    const p01 = e0.getCoordinates()[segIndex0 + 1];
    const p10 = e1.getCoordinates()[segIndex1];
    const p11 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p00, p01, p10, p11);
    if (this._li.hasIntersection()) {
      this.numIntersections++;
      if (this._li.isInteriorIntersection()) {
        this.numInteriorIntersections++;
        this._hasInterior = true;
      }
      if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
        this._hasIntersection = true;
        e0.addIntersections(this._li, segIndex0, 0);
        e1.addIntersections(this._li, segIndex1, 1);
        if (this._li.isProper()) {
          this.numProperIntersections++;
          this._hasProper = true;
          this._hasProperInterior = true;
        }
      }
    }
  }
  hasIntersection () {
    return this._hasIntersection
  }
  isDone () {
    return false
  }
  hasInteriorIntersection () {
    return this._hasInterior
  }
  interfaces_ () {
    return [SegmentIntersector]
  }
  getClass () {
    return IntersectionAdder
  }
  static isAdjacentSegments (i1, i2) {
    return Math.abs(i1 - i2) === 1
  }
}

class EdgeIntersection {
  constructor () {
    this.coord = null;
    this.segmentIndex = null;
    this.dist = null;
    const coord = arguments[0];
    const segmentIndex = arguments[1];
    const dist = arguments[2];
    this.coord = new Coordinate(coord);
    this.segmentIndex = segmentIndex;
    this.dist = dist;
  }
  getSegmentIndex () {
    return this.segmentIndex
  }
  getCoordinate () {
    return this.coord
  }
  print (out) {
    out.print(this.coord);
    out.print(' seg # = ' + this.segmentIndex);
    out.println(' dist = ' + this.dist);
  }
  compareTo (obj) {
    const other = obj;
    return this.compare(other.segmentIndex, other.dist)
  }
  isEndPoint (maxSegmentIndex) {
    if (this.segmentIndex === 0 && this.dist === 0.0) return true
    if (this.segmentIndex === maxSegmentIndex) return true
    return false
  }
  toString () {
    return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist
  }
  getDistance () {
    return this.dist
  }
  compare (segmentIndex, dist) {
    if (this.segmentIndex < segmentIndex) return -1
    if (this.segmentIndex > segmentIndex) return 1
    if (this.dist < dist) return -1
    if (this.dist > dist) return 1
    return 0
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return EdgeIntersection
  }
}

class EdgeIntersectionList {
  constructor () {
    this._nodeMap = new TreeMap();
    this.edge = null;
    const edge = arguments[0];
    this.edge = edge;
  }
  print (out) {
    out.println('Intersections:');
    for (const it = this.iterator(); it.hasNext();) {
      const ei = it.next();
      ei.print(out);
    }
  }
  iterator () {
    return this._nodeMap.values().iterator()
  }
  addSplitEdges (edgeList) {
    this.addEndpoints();
    const it = this.iterator();
    let eiPrev = it.next();
    while (it.hasNext()) {
      const ei = it.next();
      const newEdge = this.createSplitEdge(eiPrev, ei);
      edgeList.add(newEdge);
      eiPrev = ei;
    }
  }
  addEndpoints () {
    const maxSegIndex = this.edge.pts.length - 1;
    this.add(this.edge.pts[0], 0, 0.0);
    this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
  }
  createSplitEdge (ei0, ei1) {
    let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
    const lastSegStartPt = this.edge.pts[ei1.segmentIndex];
    const useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
    if (!useIntPt1) {
      npts--;
    }
    const pts = new Array(npts).fill(null);
    let ipt = 0;
    pts[ipt++] = new Coordinate(ei0.coord);
    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
      pts[ipt++] = this.edge.pts[i];
    }
    if (useIntPt1) pts[ipt] = ei1.coord;
    return new Edge(pts, new Label(this.edge._label))
  }
  add (intPt, segmentIndex, dist) {
    const eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
    const ei = this._nodeMap.get(eiNew);
    if (ei !== null) {
      return ei
    }
    this._nodeMap.put(eiNew, eiNew);
    return eiNew
  }
  isIntersection (pt) {
    for (const it = this.iterator(); it.hasNext();) {
      const ei = it.next();
      if (ei.coord.equals(pt)) return true
    }
    return false
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return EdgeIntersectionList
  }
}

class MonotoneChainIndexer {
  getChainStartIndices (pts) {
    let start = 0;
    const startIndexList = new ArrayList();
    startIndexList.add(new Integer(start));
    do {
      const last = this.findChainEnd(pts, start);
      startIndexList.add(new Integer(last));
      start = last;
    } while (start < pts.length - 1)
    const startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
    return startIndex
  }
  findChainEnd (pts, start) {
    const chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
    let last = start + 1;
    while (last < pts.length) {
      const quad = Quadrant.quadrant(pts[last - 1], pts[last]);
      if (quad !== chainQuad) break
      last++;
    }
    return last - 1
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MonotoneChainIndexer
  }
  static toIntArray (list) {
    const array = new Array(list.size()).fill(null);
    for (let i = 0; i < array.length; i++) {
      array[i] = list.get(i).intValue();
    }
    return array
  }
}

class MonotoneChainEdge {
  constructor () {
    this.e = null;
    this.pts = null;
    this.startIndex = null;
    this.env1 = new Envelope();
    this.env2 = new Envelope();
    const e = arguments[0];
    this.e = e;
    this.pts = e.getCoordinates();
    const mcb = new MonotoneChainIndexer();
    this.startIndex = mcb.getChainStartIndices(this.pts);
  }
  getCoordinates () {
    return this.pts
  }
  getMaxX (chainIndex) {
    const x1 = this.pts[this.startIndex[chainIndex]].x;
    const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
    return x1 > x2 ? x1 : x2
  }
  getMinX (chainIndex) {
    const x1 = this.pts[this.startIndex[chainIndex]].x;
    const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
    return x1 < x2 ? x1 : x2
  }
  computeIntersectsForChain () {
    if (arguments.length === 4) {
      const chainIndex0 = arguments[0];
      const mce = arguments[1];
      const chainIndex1 = arguments[2];
      const si = arguments[3];
      this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
    } else if (arguments.length === 6) {
      const start0 = arguments[0];
      const end0 = arguments[1];
      const mce = arguments[2];
      const start1 = arguments[3];
      const end1 = arguments[4];
      const ei = arguments[5];
      const p00 = this.pts[start0];
      const p01 = this.pts[end0];
      const p10 = mce.pts[start1];
      const p11 = mce.pts[end1];
      if (end0 - start0 === 1 && end1 - start1 === 1) {
        ei.addIntersections(this.e, start0, mce.e, start1);
        return null
      }
      this.env1.init(p00, p01);
      this.env2.init(p10, p11);
      if (!this.env1.intersects(this.env2)) return null
      const mid0 = Math.trunc((start0 + end0) / 2);
      const mid1 = Math.trunc((start1 + end1) / 2);
      if (start0 < mid0) {
        if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);
        if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);
      }
      if (mid0 < end0) {
        if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);
        if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);
      }
    }
  }
  getStartIndexes () {
    return this.startIndex
  }
  computeIntersects (mce, si) {
    for (let i = 0; i < this.startIndex.length - 1; i++) {
      for (let j = 0; j < mce.startIndex.length - 1; j++) {
        this.computeIntersectsForChain(i, mce, j, si);
      }
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MonotoneChainEdge
  }
}

class Depth {
  constructor () {
    this._depth = Array(2).fill().map(() => Array(3));
    for (let i = 0; i < 2; i++) {
      for (let j = 0; j < 3; j++) {
        this._depth[i][j] = Depth.NULL_VALUE;
      }
    }
  }
  getDepth (geomIndex, posIndex) {
    return this._depth[geomIndex][posIndex]
  }
  setDepth (geomIndex, posIndex, depthValue) {
    this._depth[geomIndex][posIndex] = depthValue;
  }
  isNull () {
    if (arguments.length === 0) {
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 3; j++) {
          if (this._depth[i][j] !== Depth.NULL_VALUE) return false
        }
      }
      return true
    } else if (arguments.length === 1) {
      const geomIndex = arguments[0];
      return this._depth[geomIndex][1] === Depth.NULL_VALUE
    } else if (arguments.length === 2) {
      const geomIndex = arguments[0];
      const posIndex = arguments[1];
      return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE
    }
  }
  normalize () {
    for (let i = 0; i < 2; i++) {
      if (!this.isNull(i)) {
        let minDepth = this._depth[i][1];
        if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];
        if (minDepth < 0) minDepth = 0;
        for (let j = 1; j < 3; j++) {
          let newValue = 0;
          if (this._depth[i][j] > minDepth) newValue = 1;
          this._depth[i][j] = newValue;
        }
      }
    }
  }
  getDelta (geomIndex) {
    return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]
  }
  getLocation (geomIndex, posIndex) {
    if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR
    return Location.INTERIOR
  }
  toString () {
    return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]
  }
  add () {
    if (arguments.length === 1) {
      const lbl = arguments[0];
      for (let i = 0; i < 2; i++) {
        for (let j = 1; j < 3; j++) {
          const loc = lbl.getLocation(i, j);
          if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
            if (this.isNull(i, j)) {
              this._depth[i][j] = Depth.depthAtLocation(loc);
            } else this._depth[i][j] += Depth.depthAtLocation(loc);
          }
        }
      }
    } else if (arguments.length === 3) {
      const geomIndex = arguments[0];
      const posIndex = arguments[1];
      const location = arguments[2];
      if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return Depth
  }
  static depthAtLocation (location) {
    if (location === Location.EXTERIOR) return 0
    if (location === Location.INTERIOR) return 1
    return Depth.NULL_VALUE
  }
  static get NULL_VALUE () { return -1 }
}

class Edge extends GraphComponent {
  constructor () {
    super();
    this.pts = null;
    this._env = null;
    this.eiList = new EdgeIntersectionList(this);
    this._name = null;
    this._mce = null;
    this._isIsolated = true;
    this._depth = new Depth();
    this._depthDelta = 0;
    if (arguments.length === 1) {
      const pts = arguments[0];
      Edge.call(this, pts, null);
    } else if (arguments.length === 2) {
      const pts = arguments[0];
      const label = arguments[1];
      this.pts = pts;
      this._label = label;
    }
  }
  getDepth () {
    return this._depth
  }
  getCollapsedEdge () {
    const newPts = new Array(2).fill(null);
    newPts[0] = this.pts[0];
    newPts[1] = this.pts[1];
    const newe = new Edge(newPts, Label.toLineLabel(this._label));
    return newe
  }
  isIsolated () {
    return this._isIsolated
  }
  getCoordinates () {
    return this.pts
  }
  setIsolated (isIsolated) {
    this._isIsolated = isIsolated;
  }
  setName (name) {
    this._name = name;
  }
  equals (o) {
    if (!(o instanceof Edge)) return false
    const e = o;
    if (this.pts.length !== e.pts.length) return false
    let isEqualForward = true;
    let isEqualReverse = true;
    let iRev = this.pts.length;
    for (let i = 0; i < this.pts.length; i++) {
      if (!this.pts[i].equals2D(e.pts[i])) {
        isEqualForward = false;
      }
      if (!this.pts[i].equals2D(e.pts[--iRev])) {
        isEqualReverse = false;
      }
      if (!isEqualForward && !isEqualReverse) return false
    }
    return true
  }
  getCoordinate () {
    if (arguments.length === 0) {
      if (this.pts.length > 0) return this.pts[0]
      return null
    } else if (arguments.length === 1) {
      const i = arguments[0];
      return this.pts[i]
    }
  }
  print (out) {
    out.print('edge ' + this._name + ': ');
    out.print('LINESTRING (');
    for (let i = 0; i < this.pts.length; i++) {
      if (i > 0) out.print(',');
      out.print(this.pts[i].x + ' ' + this.pts[i].y);
    }
    out.print(')  ' + this._label + ' ' + this._depthDelta);
  }
  computeIM (im) {
    Edge.updateIM(this._label, im);
  }
  isCollapsed () {
    if (!this._label.isArea()) return false
    if (this.pts.length !== 3) return false
    if (this.pts[0].equals(this.pts[2])) return true
    return false
  }
  isClosed () {
    return this.pts[0].equals(this.pts[this.pts.length - 1])
  }
  getMaximumSegmentIndex () {
    return this.pts.length - 1
  }
  getDepthDelta () {
    return this._depthDelta
  }
  getNumPoints () {
    return this.pts.length
  }
  printReverse (out) {
    out.print('edge ' + this._name + ': ');
    for (let i = this.pts.length - 1; i >= 0; i--) {
      out.print(this.pts[i] + ' ');
    }
    out.println('');
  }
  getMonotoneChainEdge () {
    if (this._mce === null) this._mce = new MonotoneChainEdge(this);
    return this._mce
  }
  getEnvelope () {
    if (this._env === null) {
      this._env = new Envelope();
      for (let i = 0; i < this.pts.length; i++) {
        this._env.expandToInclude(this.pts[i]);
      }
    }
    return this._env
  }
  addIntersection (li, segmentIndex, geomIndex, intIndex) {
    const intPt = new Coordinate(li.getIntersection(intIndex));
    let normalizedSegmentIndex = segmentIndex;
    let dist = li.getEdgeDistance(geomIndex, intIndex);
    const nextSegIndex = normalizedSegmentIndex + 1;
    if (nextSegIndex < this.pts.length) {
      const nextPt = this.pts[nextSegIndex];
      if (intPt.equals2D(nextPt)) {
        normalizedSegmentIndex = nextSegIndex;
        dist = 0.0;
      }
    }
    this.eiList.add(intPt, normalizedSegmentIndex, dist);
  }
  toString () {
    const buf = new StringBuffer();
    buf.append('edge ' + this._name + ': ');
    buf.append('LINESTRING (');
    for (let i = 0; i < this.pts.length; i++) {
      if (i > 0) buf.append(',');
      buf.append(this.pts[i].x + ' ' + this.pts[i].y);
    }
    buf.append(')  ' + this._label + ' ' + this._depthDelta);
    return buf.toString()
  }
  isPointwiseEqual (e) {
    if (this.pts.length !== e.pts.length) return false
    for (let i = 0; i < this.pts.length; i++) {
      if (!this.pts[i].equals2D(e.pts[i])) {
        return false
      }
    }
    return true
  }
  setDepthDelta (depthDelta) {
    this._depthDelta = depthDelta;
  }
  getEdgeIntersectionList () {
    return this.eiList
  }
  addIntersections (li, segmentIndex, geomIndex) {
    for (let i = 0; i < li.getIntersectionNum(); i++) {
      this.addIntersection(li, segmentIndex, geomIndex, i);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return Edge
  }
  static updateIM () {
    if (arguments.length === 2) {
      const label = arguments[0];
      const im = arguments[1];
      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
      if (label.isArea()) {
        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
      }
    } else return GraphComponent.prototype.updateIM.apply(this, arguments)
  }
}

class BufferBuilder {
  constructor (bufParams) {
    this._workingPrecisionModel = null;
    this._workingNoder = null;
    this._geomFact = null;
    this._graph = null;
    this._edgeList = new EdgeList();
    this._bufParams = bufParams || null;
  }
  setWorkingPrecisionModel (pm) {
    this._workingPrecisionModel = pm;
  }
  insertUniqueEdge (e) {
    const existingEdge = this._edgeList.findEqualEdge(e);
    if (existingEdge !== null) {
      const existingLabel = existingEdge.getLabel();
      let labelToMerge = e.getLabel();
      if (!existingEdge.isPointwiseEqual(e)) {
        labelToMerge = new Label(e.getLabel());
        labelToMerge.flip();
      }
      existingLabel.merge(labelToMerge);
      const mergeDelta = BufferBuilder.depthDelta(labelToMerge);
      const existingDelta = existingEdge.getDepthDelta();
      const newDelta = existingDelta + mergeDelta;
      existingEdge.setDepthDelta(newDelta);
    } else {
      this._edgeList.add(e);
      e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
    }
  }
  buildSubgraphs (subgraphList, polyBuilder) {
    const processedGraphs = new ArrayList();
    for (const i = subgraphList.iterator(); i.hasNext();) {
      const subgraph = i.next();
      const p = subgraph.getRightmostCoordinate();
      const locater = new SubgraphDepthLocater(processedGraphs);
      const outsideDepth = locater.getDepth(p);
      subgraph.computeDepth(outsideDepth);
      subgraph.findResultEdges();
      processedGraphs.add(subgraph);
      polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
    }
  }
  createSubgraphs (graph) {
    const subgraphList = new ArrayList();
    for (const i = graph.getNodes().iterator(); i.hasNext();) {
      const node = i.next();
      if (!node.isVisited()) {
        const subgraph = new BufferSubgraph();
        subgraph.create(node);
        subgraphList.add(subgraph);
      }
    }
    Collections.sort(subgraphList, Collections.reverseOrder());
    return subgraphList
  }
  createEmptyResultGeometry () {
    const emptyGeom = this._geomFact.createPolygon();
    return emptyGeom
  }
  getNoder (precisionModel) {
    if (this._workingNoder !== null) return this._workingNoder
    const noder = new MCIndexNoder();
    const li = new RobustLineIntersector();
    li.setPrecisionModel(precisionModel);
    noder.setSegmentIntersector(new IntersectionAdder(li));
    return noder
  }
  buffer (g, distance) {
    let precisionModel = this._workingPrecisionModel;
    if (precisionModel === null) precisionModel = g.getPrecisionModel();
    this._geomFact = g.getFactory();
    const curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
    const curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);
    const bufferSegStrList = curveSetBuilder.getCurves();
    if (bufferSegStrList.size() <= 0) {
      return this.createEmptyResultGeometry()
    }
    this.computeNodedEdges(bufferSegStrList, precisionModel);
    this._graph = new PlanarGraph(new OverlayNodeFactory());
    this._graph.addEdges(this._edgeList.getEdges());
    const subgraphList = this.createSubgraphs(this._graph);
    const polyBuilder = new PolygonBuilder(this._geomFact);
    this.buildSubgraphs(subgraphList, polyBuilder);
    const resultPolyList = polyBuilder.getPolygons();
    if (resultPolyList.size() <= 0) {
      return this.createEmptyResultGeometry()
    }
    const resultGeom = this._geomFact.buildGeometry(resultPolyList);
    return resultGeom
  }
  computeNodedEdges (bufferSegStrList, precisionModel) {
    const noder = this.getNoder(precisionModel);
    noder.computeNodes(bufferSegStrList);
    const nodedSegStrings = noder.getNodedSubstrings();
    for (const i = nodedSegStrings.iterator(); i.hasNext();) {
      const segStr = i.next();
      const pts = segStr.getCoordinates();
      if (pts.length === 2 && pts[0].equals2D(pts[1])) continue
      const oldLabel = segStr.getData();
      const edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));
      this.insertUniqueEdge(edge);
    }
  }
  setNoder (noder) {
    this._workingNoder = noder;
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return BufferBuilder
  }
  static depthDelta (label) {
    const lLoc = label.getLocation(0, Position.LEFT);
    const rLoc = label.getLocation(0, Position.RIGHT);
    if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1; else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1
    return 0
  }
  static convertSegStrings (it) {
    const fact = new GeometryFactory();
    const lines = new ArrayList();
    while (it.hasNext()) {
      const ss = it.next();
      const line = fact.createLineString(ss.getCoordinates());
      lines.add(line);
    }
    return fact.buildGeometry(lines)
  }
}

class ScaledNoder {
  constructor () {
    this._noder = null;
    this._scaleFactor = null;
    this._offsetX = null;
    this._offsetY = null;
    this._isScaled = false;
    if (arguments.length === 2) {
      const noder = arguments[0];
      const scaleFactor = arguments[1];
      this._noder = noder;
      this._scaleFactor = scaleFactor;
      this._offsetX = 0.0;
      this._offsetY = 0.0;
      this._isScaled = !this.isIntegerPrecision();
    } else if (arguments.length === 4) {
      const noder = arguments[0];
      const scaleFactor = arguments[1];
      const offsetX = arguments[2];
      const offsetY = arguments[3];
      this._noder = noder;
      this._scaleFactor = scaleFactor;
      this._offsetX = offsetX;
      this._offsetY = offsetY;
      this._isScaled = !this.isIntegerPrecision();
    }
  }
  rescale () {
    if (hasInterface(arguments[0], Collection)) {
      const segStrings = arguments[0];
      for (const i = segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        this.rescale(ss.getCoordinates());
      }
    } else if (arguments[0] instanceof Array) {
      const pts = arguments[0];
      // let p0 = null
      // let p1 = null
      // if (pts.length === 2) {
      //   p0 = new Coordinate(pts[0])
      //   p1 = new Coordinate(pts[1])
      // }
      for (let i = 0; i < pts.length; i++) {
        pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;
        pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;
      }
      if (pts.length === 2 && pts[0].equals2D(pts[1])) {
        System.out.println(pts);
      }
    }
  }
  scale () {
    if (hasInterface(arguments[0], Collection)) {
      const segStrings = arguments[0];
      const nodedSegmentStrings = new ArrayList();
      for (const i = segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));
      }
      return nodedSegmentStrings
    } else if (arguments[0] instanceof Array) {
      const pts = arguments[0];
      const roundPts = new Array(pts.length).fill(null);
      for (let i = 0; i < pts.length; i++) {
        roundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);
      }
      const roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
      return roundPtsNoDup
    }
  }
  isIntegerPrecision () {
    return this._scaleFactor === 1.0
  }
  getNodedSubstrings () {
    const splitSS = this._noder.getNodedSubstrings();
    if (this._isScaled) this.rescale(splitSS);
    return splitSS
  }
  computeNodes (inputSegStrings) {
    let intSegStrings = inputSegStrings;
    if (this._isScaled) intSegStrings = this.scale(inputSegStrings);
    this._noder.computeNodes(intSegStrings);
  }
  interfaces_ () {
    return [Noder]
  }
  getClass () {
    return ScaledNoder
  }
}

class NodingValidator {
  constructor () {
    this._li = new RobustLineIntersector();
    this._segStrings = null;
    const segStrings = arguments[0];
    this._segStrings = segStrings;
  }
  checkEndPtVertexIntersections () {
    if (arguments.length === 0) {
      for (const i = this._segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        const pts = ss.getCoordinates();
        this.checkEndPtVertexIntersections(pts[0], this._segStrings);
        this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);
      }
    } else if (arguments.length === 2) {
      const testPt = arguments[0];
      const segStrings = arguments[1];
      for (const i = segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        const pts = ss.getCoordinates();
        for (let j = 1; j < pts.length - 1; j++) {
          if (pts[j].equals(testPt)) throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt)
        }
      }
    }
  }
  checkInteriorIntersections () {
    if (arguments.length === 0) {
      for (const i = this._segStrings.iterator(); i.hasNext();) {
        const ss0 = i.next();
        for (const j = this._segStrings.iterator(); j.hasNext();) {
          const ss1 = j.next();
          this.checkInteriorIntersections(ss0, ss1);
        }
      }
    } else if (arguments.length === 2) {
      const ss0 = arguments[0];
      const ss1 = arguments[1];
      const pts0 = ss0.getCoordinates();
      const pts1 = ss1.getCoordinates();
      for (let i0 = 0; i0 < pts0.length - 1; i0++) {
        for (let i1 = 0; i1 < pts1.length - 1; i1++) {
          this.checkInteriorIntersections(ss0, i0, ss1, i1);
        }
      }
    } else if (arguments.length === 4) {
      const e0 = arguments[0];
      const segIndex0 = arguments[1];
      const e1 = arguments[2];
      const segIndex1 = arguments[3];
      if (e0 === e1 && segIndex0 === segIndex1) return null
      const p00 = e0.getCoordinates()[segIndex0];
      const p01 = e0.getCoordinates()[segIndex0 + 1];
      const p10 = e1.getCoordinates()[segIndex1];
      const p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
          throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)
        }
      }
    }
  }
  checkValid () {
    this.checkEndPtVertexIntersections();
    this.checkInteriorIntersections();
    this.checkCollapses();
  }
  checkCollapses () {
    if (arguments.length === 0) {
      for (const i = this._segStrings.iterator(); i.hasNext();) {
        const ss = i.next();
        this.checkCollapses(ss);
      }
    } else if (arguments.length === 1) {
      const ss = arguments[0];
      const pts = ss.getCoordinates();
      for (let i = 0; i < pts.length - 2; i++) {
        this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);
      }
    }
  }
  hasInteriorIntersection (li, p0, p1) {
    for (let i = 0; i < li.getIntersectionNum(); i++) {
      const intPt = li.getIntersection(i);
      if (!(intPt.equals(p0) || intPt.equals(p1))) return true
    }
    return false
  }
  checkCollapse (p0, p1, p2) {
    if (p0.equals(p2)) throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2]))
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return NodingValidator
  }
  static get fact () { return new GeometryFactory() }
}

class HotPixel {
  constructor () {
    this._li = null;
    this._pt = null;
    this._originalPt = null;
    this._ptScaled = null;
    this._p0Scaled = null;
    this._p1Scaled = null;
    this._scaleFactor = null;
    this._minx = null;
    this._maxx = null;
    this._miny = null;
    this._maxy = null;
    this._corner = new Array(4).fill(null);
    this._safeEnv = null;
    const pt = arguments[0];
    const scaleFactor = arguments[1];
    const li = arguments[2];
    this._originalPt = pt;
    this._pt = pt;
    this._scaleFactor = scaleFactor;
    this._li = li;
    if (scaleFactor <= 0) throw new IllegalArgumentException('Scale factor must be non-zero')
    if (scaleFactor !== 1.0) {
      this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
      this._p0Scaled = new Coordinate();
      this._p1Scaled = new Coordinate();
    }
    this.initCorners(this._pt);
  }
  intersectsScaled (p0, p1) {
    const segMinx = Math.min(p0.x, p1.x);
    const segMaxx = Math.max(p0.x, p1.x);
    const segMiny = Math.min(p0.y, p1.y);
    const segMaxy = Math.max(p0.y, p1.y);
    const isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
    if (isOutsidePixelEnv) return false
    const intersects = this.intersectsToleranceSquare(p0, p1);
    Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');
    return intersects
  }
  initCorners (pt) {
    const tolerance = 0.5;
    this._minx = pt.x - tolerance;
    this._maxx = pt.x + tolerance;
    this._miny = pt.y - tolerance;
    this._maxy = pt.y + tolerance;
    this._corner[0] = new Coordinate(this._maxx, this._maxy);
    this._corner[1] = new Coordinate(this._minx, this._maxy);
    this._corner[2] = new Coordinate(this._minx, this._miny);
    this._corner[3] = new Coordinate(this._maxx, this._miny);
  }
  intersects (p0, p1) {
    if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1)
    this.copyScaled(p0, this._p0Scaled);
    this.copyScaled(p1, this._p1Scaled);
    return this.intersectsScaled(this._p0Scaled, this._p1Scaled)
  }
  scale (val) {
    return Math.round(val * this._scaleFactor)
  }
  getCoordinate () {
    return this._originalPt
  }
  copyScaled (p, pScaled) {
    pScaled.x = this.scale(p.x);
    pScaled.y = this.scale(p.y);
  }
  getSafeEnvelope () {
    if (this._safeEnv === null) {
      const safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
      this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
    }
    return this._safeEnv
  }
  intersectsPixelClosure (p0, p1) {
    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
    if (this._li.hasIntersection()) return true
    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
    if (this._li.hasIntersection()) return true
    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
    if (this._li.hasIntersection()) return true
    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
    if (this._li.hasIntersection()) return true
    return false
  }
  intersectsToleranceSquare (p0, p1) {
    let intersectsLeft = false;
    let intersectsBottom = false;
    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
    if (this._li.isProper()) return true
    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
    if (this._li.isProper()) return true
    if (this._li.hasIntersection()) intersectsLeft = true;
    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
    if (this._li.isProper()) return true
    if (this._li.hasIntersection()) intersectsBottom = true;
    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
    if (this._li.isProper()) return true
    if (intersectsLeft && intersectsBottom) return true
    if (p0.equals(this._pt)) return true
    if (p1.equals(this._pt)) return true
    return false
  }
  addSnappedNode (segStr, segIndex) {
    const p0 = segStr.getCoordinate(segIndex);
    const p1 = segStr.getCoordinate(segIndex + 1);
    if (this.intersects(p0, p1)) {
      segStr.addIntersection(this.getCoordinate(), segIndex);
      return true
    }
    return false
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return HotPixel
  }
  static get SAFE_ENV_EXPANSION_FACTOR () { return 0.75 }
}

class MonotoneChainSelectAction {
  constructor () {
    this.tempEnv1 = new Envelope();
    this.selectedSegment = new LineSegment();
  }
  select () {
    if (arguments.length === 1) {
      // const seg = arguments[0]
    } else if (arguments.length === 2) {
      const mc = arguments[0];
      const startIndex = arguments[1];
      mc.getLineSegment(startIndex, this.selectedSegment);
      this.select(this.selectedSegment);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MonotoneChainSelectAction
  }
}

class MCIndexPointSnapper {
  constructor () {
    this._index = null;
    const index = arguments[0];
    this._index = index;
  }
  snap () {
    if (arguments.length === 1) {
      const hotPixel = arguments[0];
      return this.snap(hotPixel, null, -1)
    } else if (arguments.length === 3) {
      const hotPixel = arguments[0];
      const parentEdge = arguments[1];
      const hotPixelVertexIndex = arguments[2];
      const pixelEnv = hotPixel.getSafeEnvelope();
      const hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);
      this._index.query(pixelEnv, {
        interfaces_: function () {
          return [ItemVisitor]
        },
        visitItem: function (item) {
          const testChain = item;
          testChain.select(pixelEnv, hotPixelSnapAction);
        }
      });
      return hotPixelSnapAction.isNodeAdded()
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MCIndexPointSnapper
  }
  static get HotPixelSnapAction () { return HotPixelSnapAction }
}

class HotPixelSnapAction extends MonotoneChainSelectAction {
  constructor () {
    super();
    this._hotPixel = null;
    this._parentEdge = null;
    this._hotPixelVertexIndex = null;
    this._isNodeAdded = false;
    const hotPixel = arguments[0];
    const parentEdge = arguments[1];
    const hotPixelVertexIndex = arguments[2];
    this._hotPixel = hotPixel;
    this._parentEdge = parentEdge;
    this._hotPixelVertexIndex = hotPixelVertexIndex;
  }
  isNodeAdded () {
    return this._isNodeAdded
  }
  select () {
    if (arguments.length === 2) {
      const mc = arguments[0];
      const startIndex = arguments[1];
      const ss = mc.getContext();
      if (this._parentEdge !== null) {
        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null
      }
      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
    } else return MonotoneChainSelectAction.prototype.select.apply(this, arguments)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return HotPixelSnapAction
  }
}

class InteriorIntersectionFinderAdder {
  constructor () {
    this._li = null;
    this._interiorIntersections = null;
    const li = arguments[0];
    this._li = li;
    this._interiorIntersections = new ArrayList();
  }
  processIntersections (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1 && segIndex0 === segIndex1) return null
    const p00 = e0.getCoordinates()[segIndex0];
    const p01 = e0.getCoordinates()[segIndex0 + 1];
    const p10 = e1.getCoordinates()[segIndex1];
    const p11 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p00, p01, p10, p11);
    if (this._li.hasIntersection()) {
      if (this._li.isInteriorIntersection()) {
        for (let intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
          this._interiorIntersections.add(this._li.getIntersection(intIndex));
        }
        e0.addIntersections(this._li, segIndex0, 0);
        e1.addIntersections(this._li, segIndex1, 1);
      }
    }
  }
  isDone () {
    return false
  }
  getInteriorIntersections () {
    return this._interiorIntersections
  }
  interfaces_ () {
    return [SegmentIntersector]
  }
  getClass () {
    return InteriorIntersectionFinderAdder
  }
}

class MCIndexSnapRounder {
  constructor () {
    this._pm = null;
    this._li = null;
    this._scaleFactor = null;
    this._noder = null;
    this._pointSnapper = null;
    this._nodedSegStrings = null;
    let pm = arguments[0];
    this._pm = pm;
    this._li = new RobustLineIntersector();
    this._li.setPrecisionModel(pm);
    this._scaleFactor = pm.getScale();
  }
  checkCorrectness (inputSegmentStrings) {
    var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
    var nv = new NodingValidator(resultSegStrings);
    try {
      nv.checkValid();
    } catch (ex) {
      if (ex instanceof Exception) {
        ex.printStackTrace();
      } else throw ex
    } finally {}
  }
  getNodedSubstrings () {
    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)
  }
  snapRound (segStrings, li) {
    var intersections = this.findInteriorIntersections(segStrings, li);
    this.computeIntersectionSnaps(intersections);
    this.computeVertexSnaps(segStrings);
  }
  findInteriorIntersections (segStrings, li) {
    var intFinderAdder = new InteriorIntersectionFinderAdder(li);
    this._noder.setSegmentIntersector(intFinderAdder);
    this._noder.computeNodes(segStrings);
    return intFinderAdder.getInteriorIntersections()
  }
  computeVertexSnaps () {
    if (hasInterface(arguments[0], Collection)) {
      let edges = arguments[0];
      for (var i0 = edges.iterator(); i0.hasNext();) {
        var edge0 = i0.next();
        this.computeVertexSnaps(edge0);
      }
    } else if (arguments[0] instanceof NodedSegmentString) {
      let e = arguments[0];
      var pts0 = e.getCoordinates();
      for (var i = 0; i < pts0.length; i++) {
        var hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);
        var isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);
        if (isNodeAdded) {
          e.addIntersection(pts0[i], i);
        }
      }
    }
  }
  computeNodes (inputSegmentStrings) {
    this._nodedSegStrings = inputSegmentStrings;
    this._noder = new MCIndexNoder();
    this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
    this.snapRound(inputSegmentStrings, this._li);
  }
  computeIntersectionSnaps (snapPts) {
    for (var it = snapPts.iterator(); it.hasNext();) {
      var snapPt = it.next();
      var hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);
      this._pointSnapper.snap(hotPixel);
    }
  }
  interfaces_ () {
    return [Noder]
  }
  getClass () {
    return MCIndexSnapRounder
  }
}

class BufferOp {
  constructor () {
    this._argGeom = null;
    this._distance = null;
    this._bufParams = new BufferParameters();
    this._resultGeometry = null;
    this._saveException = null;
    if (arguments.length === 1) {
      const g = arguments[0];
      this._argGeom = g;
    } else if (arguments.length === 2) {
      const g = arguments[0];
      const bufParams = arguments[1];
      this._argGeom = g;
      this._bufParams = bufParams;
    }
  }
  bufferFixedPrecision (fixedPM) {
    const noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());
    const bufBuilder = new BufferBuilder(this._bufParams);
    bufBuilder.setWorkingPrecisionModel(fixedPM);
    bufBuilder.setNoder(noder);
    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
  }
  bufferReducedPrecision () {
    if (arguments.length === 0) {
      for (let precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
        try {
          this.bufferReducedPrecision(precDigits);
        } catch (ex) {
          if (ex instanceof TopologyException) {
            this._saveException = ex;
          } else throw ex
        } finally {}
        if (this._resultGeometry !== null) return null
      }
      throw this._saveException
    } else if (arguments.length === 1) {
      const precisionDigits = arguments[0];
      const sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
      const fixedPM = new PrecisionModel(sizeBasedScaleFactor);
      this.bufferFixedPrecision(fixedPM);
    }
  }
  computeGeometry () {
    this.bufferOriginalPrecision();
    if (this._resultGeometry !== null) return null
    const argPM = this._argGeom.getFactory().getPrecisionModel();
    if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM); else this.bufferReducedPrecision();
  }
  setQuadrantSegments (quadrantSegments) {
    this._bufParams.setQuadrantSegments(quadrantSegments);
  }
  bufferOriginalPrecision () {
    try {
      const bufBuilder = new BufferBuilder(this._bufParams);
      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
    } catch (ex) {
      if (ex instanceof RuntimeException) {
        this._saveException = ex;
      } else throw ex
    } finally {}
  }
  getResultGeometry (distance) {
    this._distance = distance;
    this.computeGeometry();
    return this._resultGeometry
  }
  setEndCapStyle (endCapStyle) {
    this._bufParams.setEndCapStyle(endCapStyle);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return BufferOp
  }
  static bufferOp () {
    if (arguments.length === 2) {
      const g = arguments[0];
      const distance = arguments[1];
      const gBuf = new BufferOp(g);
      const geomBuf = gBuf.getResultGeometry(distance);
      return geomBuf
    } else if (arguments.length === 3) {
      if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
        const g = arguments[0];
        const distance = arguments[1];
        const quadrantSegments = arguments[2];
        const bufOp = new BufferOp(g);
        bufOp.setQuadrantSegments(quadrantSegments);
        const geomBuf = bufOp.getResultGeometry(distance);
        return geomBuf
      } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {
        const g = arguments[0];
        const distance = arguments[1];
        const params = arguments[2];
        const bufOp = new BufferOp(g, params);
        const geomBuf = bufOp.getResultGeometry(distance);
        return geomBuf
      }
    } else if (arguments.length === 4) {
      const g = arguments[0];
      const distance = arguments[1];
      const quadrantSegments = arguments[2];
      const endCapStyle = arguments[3];
      const bufOp = new BufferOp(g);
      bufOp.setQuadrantSegments(quadrantSegments);
      bufOp.setEndCapStyle(endCapStyle);
      const geomBuf = bufOp.getResultGeometry(distance);
      return geomBuf
    }
  }
  static precisionScaleFactor (g, distance, maxPrecisionDigits) {
    const env = g.getEnvelopeInternal();
    const envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
    const expandByDistance = distance > 0.0 ? distance : 0.0;
    const bufEnvMax = envMax + 2 * expandByDistance;
    const bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
    const minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
    const scaleFactor = Math.pow(10.0, minUnitLog10);
    return scaleFactor
  }
  static get CAP_ROUND () { return BufferParameters.CAP_ROUND }
  static get CAP_BUTT () { return BufferParameters.CAP_FLAT }
  static get CAP_FLAT () { return BufferParameters.CAP_FLAT }
  static get CAP_SQUARE () { return BufferParameters.CAP_SQUARE }
  static get MAX_PRECISION_DIGITS () { return 12 }
}

class LinearComponentExtracter {
  constructor () {
    this._lines = null;
    this._isForcedToLineString = false;
    if (arguments.length === 1) {
      const lines = arguments[0];
      this._lines = lines;
    } else if (arguments.length === 2) {
      const lines = arguments[0];
      const isForcedToLineString = arguments[1];
      this._lines = lines;
      this._isForcedToLineString = isForcedToLineString;
    }
  }
  filter (geom) {
    if (this._isForcedToLineString && geom instanceof LinearRing) {
      var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
      this._lines.add(line);
      return null
    }
    if (geom instanceof LineString) this._lines.add(geom);
  }
  setForceToLineString (isForcedToLineString) {
    this._isForcedToLineString = isForcedToLineString;
  }
  interfaces_ () {
    return [GeometryComponentFilter]
  }
  getClass () {
    return LinearComponentExtracter
  }
  static getGeometry () {
    if (arguments.length === 1) {
      const geom = arguments[0];
      return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom))
    } else if (arguments.length === 2) {
      const geom = arguments[0];
      const forceToLineString = arguments[1];
      return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString))
    }
  }
  static getLines () {
    if (arguments.length === 1) {
      const geom = arguments[0];
      return LinearComponentExtracter.getLines(geom, false)
    } else if (arguments.length === 2) {
      if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
        const geoms = arguments[0];
        const lines = arguments[1];
        for (var i = geoms.iterator(); i.hasNext();) {
          var g = i.next();
          LinearComponentExtracter.getLines(g, lines);
        }
        return lines
      } else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {
        const geom = arguments[0];
        const forceToLineString = arguments[1];
        var lines = new ArrayList();
        geom.apply(new LinearComponentExtracter(lines, forceToLineString));
        return lines
      } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
        const geom = arguments[0];
        const lines = arguments[1];
        if (geom instanceof LineString) {
          lines.add(geom);
        } else {
          geom.apply(new LinearComponentExtracter(lines));
        }
        return lines
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {
        const geoms = arguments[0];
        const lines = arguments[1];
        const forceToLineString = arguments[2];
        for (let i = geoms.iterator(); i.hasNext();) {
          const g = i.next();
          LinearComponentExtracter.getLines(g, lines, forceToLineString);
        }
        return lines
      } else if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {
        const geom = arguments[0];
        const lines = arguments[1];
        const forceToLineString = arguments[2];
        geom.apply(new LinearComponentExtracter(lines, forceToLineString));
        return lines
      }
    }
  }
}

class PointLocator {
  constructor () {
    this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
    this._isIn = null;
    this._numBoundaries = null;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      let boundaryRule = arguments[0];
      if (boundaryRule === null) throw new IllegalArgumentException('Rule must be non-null')
      this._boundaryRule = boundaryRule;
    }
  }
  locateInternal () {
    if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {
      const p = arguments[0];
      const poly = arguments[1];
      if (poly.isEmpty()) return Location.EXTERIOR
      const shell = poly.getExteriorRing();
      const shellLoc = this.locateInPolygonRing(p, shell);
      if (shellLoc === Location.EXTERIOR) return Location.EXTERIOR
      if (shellLoc === Location.BOUNDARY) return Location.BOUNDARY
      for (let i = 0; i < poly.getNumInteriorRing(); i++) {
        const hole = poly.getInteriorRingN(i);
        const holeLoc = this.locateInPolygonRing(p, hole);
        if (holeLoc === Location.INTERIOR) return Location.EXTERIOR
        if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY
      }
      return Location.INTERIOR
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {
      const p = arguments[0];
      const l = arguments[1];
      if (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR
      const pt = l.getCoordinates();
      if (!l.isClosed()) {
        if (p.equals(pt[0]) || p.equals(pt[pt.length - 1])) {
          return Location.BOUNDARY
        }
      }
      if (CGAlgorithms.isOnLine(p, pt)) return Location.INTERIOR
      return Location.EXTERIOR
    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {
      const p = arguments[0];
      const pt = arguments[1];
      const ptCoord = pt.getCoordinate();
      if (ptCoord.equals2D(p)) return Location.INTERIOR
      return Location.EXTERIOR
    }
  }
  locateInPolygonRing (p, ring) {
    if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR
    return CGAlgorithms.locatePointInRing(p, ring.getCoordinates())
  }
  intersects (p, geom) {
    return this.locate(p, geom) !== Location.EXTERIOR
  }
  updateLocationInfo (loc) {
    if (loc === Location.INTERIOR) this._isIn = true;
    if (loc === Location.BOUNDARY) this._numBoundaries++;
  }
  computeLocation (p, geom) {
    if (geom instanceof Point) {
      this.updateLocationInfo(this.locateInternal(p, geom));
    }
    if (geom instanceof LineString) {
      this.updateLocationInfo(this.locateInternal(p, geom));
    } else if (geom instanceof Polygon) {
      this.updateLocationInfo(this.locateInternal(p, geom));
    } else if (geom instanceof MultiLineString) {
      const ml = geom;
      for (let i = 0; i < ml.getNumGeometries(); i++) {
        const l = ml.getGeometryN(i);
        this.updateLocationInfo(this.locateInternal(p, l));
      }
    } else if (geom instanceof MultiPolygon) {
      const mpoly = geom;
      for (let i = 0; i < mpoly.getNumGeometries(); i++) {
        const poly = mpoly.getGeometryN(i);
        this.updateLocationInfo(this.locateInternal(p, poly));
      }
    } else if (geom instanceof GeometryCollection) {
      const geomi = new GeometryCollectionIterator(geom);
      while (geomi.hasNext()) {
        const g2 = geomi.next();
        if (g2 !== geom) this.computeLocation(p, g2);
      }
    }
  }
  locate (p, geom) {
    if (geom.isEmpty()) return Location.EXTERIOR
    if (geom instanceof LineString) {
      return this.locateInternal(p, geom)
    } else if (geom instanceof Polygon) {
      return this.locateInternal(p, geom)
    }
    this._isIn = false;
    this._numBoundaries = 0;
    this.computeLocation(p, geom);
    if (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY
    if (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR
    return Location.EXTERIOR
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return PointLocator
  }
}

// operation.buffer

class BasicSegmentString {
  constructor () {
    this._pts = null;
    this._data = null;
    const pts = arguments[0];
    const data = arguments[1];
    this._pts = pts;
    this._data = data;
  }
  getCoordinates () {
    return this._pts
  }
  size () {
    return this._pts.length
  }
  getCoordinate (i) {
    return this._pts[i]
  }
  isClosed () {
    return this._pts[0].equals(this._pts[this._pts.length - 1])
  }
  getSegmentOctant (index) {
    if (index === this._pts.length - 1) return -1
    return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1))
  }
  setData (data) {
    this._data = data;
  }
  getData () {
    return this._data
  }
  toString () {
    return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))
  }
  interfaces_ () {
    return [SegmentString]
  }
  getClass () {
    return BasicSegmentString
  }
}

class InteriorIntersectionFinder {
  constructor () {
    this._findAllIntersections = false;
    this._isCheckEndSegmentsOnly = false;
    this._li = null;
    this._interiorIntersection = null;
    this._intSegments = null;
    this._intersections = new ArrayList();
    this._intersectionCount = 0;
    this._keepIntersections = true;
    const li = arguments[0];
    this._li = li;
    this._interiorIntersection = null;
  }
  getInteriorIntersection () {
    return this._interiorIntersection
  }
  setCheckEndSegmentsOnly (isCheckEndSegmentsOnly) {
    this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
  }
  getIntersectionSegments () {
    return this._intSegments
  }
  count () {
    return this._intersectionCount
  }
  getIntersections () {
    return this._intersections
  }
  setFindAllIntersections (findAllIntersections) {
    this._findAllIntersections = findAllIntersections;
  }
  setKeepIntersections (keepIntersections) {
    this._keepIntersections = keepIntersections;
  }
  processIntersections (e0, segIndex0, e1, segIndex1) {
    if (!this._findAllIntersections && this.hasIntersection()) return null
    if (e0 === e1 && segIndex0 === segIndex1) return null
    if (this._isCheckEndSegmentsOnly) {
      const isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
      if (!isEndSegPresent) return null
    }
    const p00 = e0.getCoordinates()[segIndex0];
    const p01 = e0.getCoordinates()[segIndex0 + 1];
    const p10 = e1.getCoordinates()[segIndex1];
    const p11 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p00, p01, p10, p11);
    if (this._li.hasIntersection()) {
      if (this._li.isInteriorIntersection()) {
        this._intSegments = new Array(4).fill(null);
        this._intSegments[0] = p00;
        this._intSegments[1] = p01;
        this._intSegments[2] = p10;
        this._intSegments[3] = p11;
        this._interiorIntersection = this._li.getIntersection(0);
        if (this._keepIntersections) this._intersections.add(this._interiorIntersection);
        this._intersectionCount++;
      }
    }
  }
  isEndSegment (segStr, index) {
    if (index === 0) return true
    if (index >= segStr.size() - 2) return true
    return false
  }
  hasIntersection () {
    return this._interiorIntersection !== null
  }
  isDone () {
    if (this._findAllIntersections) return false
    return this._interiorIntersection !== null
  }
  interfaces_ () {
    return [SegmentIntersector]
  }
  getClass () {
    return InteriorIntersectionFinder
  }
  static createAllIntersectionsFinder (li) {
    const finder = new InteriorIntersectionFinder(li);
    finder.setFindAllIntersections(true);
    return finder
  }
  static createAnyIntersectionFinder (li) {
    return new InteriorIntersectionFinder(li)
  }
  static createIntersectionCounter (li) {
    const finder = new InteriorIntersectionFinder(li);
    finder.setFindAllIntersections(true);
    finder.setKeepIntersections(false);
    return finder
  }
}

class FastNodingValidator {
  constructor () {
    this._li = new RobustLineIntersector();
    this._segStrings = null;
    this._findAllIntersections = false;
    this._segInt = null;
    this._isValid = true;
    const segStrings = arguments[0];
    this._segStrings = segStrings;
  }
  execute () {
    if (this._segInt !== null) return null
    this.checkInteriorIntersections();
  }
  getIntersections () {
    return this._segInt.getIntersections()
  }
  isValid () {
    this.execute();
    return this._isValid
  }
  setFindAllIntersections (findAllIntersections) {
    this._findAllIntersections = findAllIntersections;
  }
  checkInteriorIntersections () {
    this._isValid = true;
    this._segInt = new InteriorIntersectionFinder(this._li);
    this._segInt.setFindAllIntersections(this._findAllIntersections);
    const noder = new MCIndexNoder();
    noder.setSegmentIntersector(this._segInt);
    noder.computeNodes(this._segStrings);
    if (this._segInt.hasIntersection()) {
      this._isValid = false;
      return null
    }
  }
  checkValid () {
    this.execute();
    if (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection())
  }
  getErrorMessage () {
    if (this._isValid) return 'no intersections found'
    const intSegs = this._segInt.getIntersectionSegments();
    return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3])
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return FastNodingValidator
  }
  static computeIntersections (segStrings) {
    const nv = new FastNodingValidator(segStrings);
    nv.setFindAllIntersections(true);
    nv.isValid();
    return nv.getIntersections()
  }
}

class EdgeNodingValidator {
  constructor () {
    this._nv = null;
    let edges = arguments[0];
    this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));
  }
  checkValid () {
    this._nv.checkValid();
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return EdgeNodingValidator
  }
  static toSegmentStrings (edges) {
    const segStrings = new ArrayList();
    for (const i = edges.iterator(); i.hasNext();) {
      const e = i.next();
      segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
    }
    return segStrings
  }
  static checkValid (edges) {
    const validator = new EdgeNodingValidator(edges);
    validator.checkValid();
  }
}

class GeometryCollectionMapper {
  constructor (mapOp) {
    this._mapOp = mapOp;
  }
  map (gc) {
    var mapped = new ArrayList();
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      var g = this._mapOp.map(gc.getGeometryN(i));
      if (!g.isEmpty()) mapped.add(g);
    }
    return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped))
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryCollectionMapper
  }
  static map (gc, op) {
    var mapper = new GeometryCollectionMapper(op);
    return mapper.map(gc)
  }
}

class LineBuilder {
  constructor () {
    this._op = null;
    this._geometryFactory = null;
    this._ptLocator = null;
    this._lineEdgesList = new ArrayList();
    this._resultLineList = new ArrayList();
    const op = arguments[0];
    const geometryFactory = arguments[1];
    const ptLocator = arguments[2];
    this._op = op;
    this._geometryFactory = geometryFactory;
    this._ptLocator = ptLocator;
  }
  collectLines (opCode) {
    for (const it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
      const de = it.next();
      this.collectLineEdge(de, opCode, this._lineEdgesList);
      this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);
    }
  }
  labelIsolatedLine (e, targetIndex) {
    const loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
    e.getLabel().setLocation(targetIndex, loc);
  }
  build (opCode) {
    this.findCoveredLineEdges();
    this.collectLines(opCode);
    this.buildLines(opCode);
    return this._resultLineList
  }
  collectLineEdge (de, opCode, edges) {
    const label = de.getLabel();
    const e = de.getEdge();
    if (de.isLineEdge()) {
      if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {
        edges.add(e);
        de.setVisitedEdge(true);
      }
    }
  }
  findCoveredLineEdges () {
    for (const nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().findCoveredLineEdges();
    }
    for (const it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
      const de = it.next();
      const e = de.getEdge();
      if (de.isLineEdge() && !e.isCoveredSet()) {
        const isCovered = this._op.isCoveredByA(de.getCoordinate());
        e.setCovered(isCovered);
      }
    }
  }
  labelIsolatedLines (edgesList) {
    for (const it = edgesList.iterator(); it.hasNext();) {
      const e = it.next();
      const label = e.getLabel();
      if (e.isIsolated()) {
        if (label.isNull(0)) this.labelIsolatedLine(e, 0); else this.labelIsolatedLine(e, 1);
      }
    }
  }
  buildLines (opCode) {
    for (const it = this._lineEdgesList.iterator(); it.hasNext();) {
      const e = it.next();
      // const label = e.getLabel()
      const line = this._geometryFactory.createLineString(e.getCoordinates());
      this._resultLineList.add(line);
      e.setInResult(true);
    }
  }
  collectBoundaryTouchEdge (de, opCode, edges) {
    const label = de.getLabel();
    if (de.isLineEdge()) return null
    if (de.isVisited()) return null
    if (de.isInteriorAreaEdge()) return null
    if (de.getEdge().isInResult()) return null
    Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
    if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
      edges.add(de.getEdge());
      de.setVisitedEdge(true);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return LineBuilder
  }
}

class PointBuilder {
  constructor () {
    this._op = null;
    this._geometryFactory = null;
    this._resultPointList = new ArrayList();
    const op = arguments[0];
    const geometryFactory = arguments[1];
    // const ptLocator = arguments[2]
    this._op = op;
    this._geometryFactory = geometryFactory;
  }
  filterCoveredNodeToPoint (n) {
    const coord = n.getCoordinate();
    if (!this._op.isCoveredByLA(coord)) {
      const pt = this._geometryFactory.createPoint(coord);
      this._resultPointList.add(pt);
    }
  }
  extractNonCoveredResultNodes (opCode) {
    for (const nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
      const n = nodeit.next();
      if (n.isInResult()) continue
      if (n.isIncidentEdgeInResult()) continue
      if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
        const label = n.getLabel();
        if (OverlayOp.isResultOfOp(label, opCode)) {
          this.filterCoveredNodeToPoint(n);
        }
      }
    }
  }
  build (opCode) {
    this.extractNonCoveredResultNodes(opCode);
    return this._resultPointList
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return PointBuilder
  }
}

class GeometryTransformer {
  constructor () {
    this._inputGeom = null;
    this._factory = null;
    this._pruneEmptyGeometry = true;
    this._preserveGeometryCollectionType = true;
    this._preserveCollections = false;
    this._preserveType = false;
  }
  transformPoint (geom, parent) {
    return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom))
  }
  transformPolygon (geom, parent) {
    let isAllValidLinearRings = true;
    const shell = this.transformLinearRing(geom.getExteriorRing(), geom);
    if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;
    const holes = new ArrayList();
    for (let i = 0; i < geom.getNumInteriorRing(); i++) {
      const hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
      if (hole === null || hole.isEmpty()) {
        continue
      }
      if (!(hole instanceof LinearRing)) isAllValidLinearRings = false;
      holes.add(hole);
    }
    if (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([])); else {
      const components = new ArrayList();
      if (shell !== null) components.add(shell);
      components.addAll(holes);
      return this._factory.buildGeometry(components)
    }
  }
  createCoordinateSequence (coords) {
    return this._factory.getCoordinateSequenceFactory().create(coords)
  }
  getInputGeometry () {
    return this._inputGeom
  }
  transformMultiLineString (geom, parent) {
    const transGeomList = new ArrayList();
    for (let i = 0; i < geom.getNumGeometries(); i++) {
      const transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
      if (transformGeom === null) continue
      if (transformGeom.isEmpty()) continue
      transGeomList.add(transformGeom);
    }
    return this._factory.buildGeometry(transGeomList)
  }
  transformCoordinates (coords, parent) {
    return this.copy(coords)
  }
  transformLineString (geom, parent) {
    return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom))
  }
  transformMultiPoint (geom, parent) {
    const transGeomList = new ArrayList();
    for (let i = 0; i < geom.getNumGeometries(); i++) {
      const transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
      if (transformGeom === null) continue
      if (transformGeom.isEmpty()) continue
      transGeomList.add(transformGeom);
    }
    return this._factory.buildGeometry(transGeomList)
  }
  transformMultiPolygon (geom, parent) {
    const transGeomList = new ArrayList();
    for (let i = 0; i < geom.getNumGeometries(); i++) {
      const transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
      if (transformGeom === null) continue
      if (transformGeom.isEmpty()) continue
      transGeomList.add(transformGeom);
    }
    return this._factory.buildGeometry(transGeomList)
  }
  copy (seq) {
    return seq.copy()
  }
  transformGeometryCollection (geom, parent) {
    const transGeomList = new ArrayList();
    for (let i = 0; i < geom.getNumGeometries(); i++) {
      const transformGeom = this.transform(geom.getGeometryN(i));
      if (transformGeom === null) continue
      if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue
      transGeomList.add(transformGeom);
    }
    if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList))
    return this._factory.buildGeometry(transGeomList)
  }
  transform (inputGeom) {
    this._inputGeom = inputGeom;
    this._factory = inputGeom.getFactory();
    if (inputGeom instanceof Point) return this.transformPoint(inputGeom, null)
    if (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null)
    if (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null)
    if (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null)
    if (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null)
    if (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null)
    if (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null)
    if (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null)
    throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getClass().getName())
  }
  transformLinearRing (geom, parent) {
    const seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
    if (seq === null) return this._factory.createLinearRing(null)
    const seqSize = seq.size();
    if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq)
    return this._factory.createLinearRing(seq)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryTransformer
  }
}

class LineStringSnapper {
  constructor () {
    this._snapTolerance = 0.0;
    this._srcPts = null;
    this._seg = new LineSegment();
    this._allowSnappingToSourceVertices = false;
    this._isClosed = false;
    if (arguments[0] instanceof LineString && typeof arguments[1] === 'number') {
      const srcLine = arguments[0];
      const snapTolerance = arguments[1];
      LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);
    } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {
      const srcPts = arguments[0];
      const snapTolerance = arguments[1];
      this._srcPts = srcPts;
      this._isClosed = LineStringSnapper.isClosed(srcPts);
      this._snapTolerance = snapTolerance;
    }
  }
  snapVertices (srcCoords, snapPts) {
    var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
    for (var i = 0; i < end; i++) {
      var srcPt = srcCoords.get(i);
      var snapVert = this.findSnapForVertex(srcPt, snapPts);
      if (snapVert !== null) {
        srcCoords.set(i, new Coordinate(snapVert));
        if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));
      }
    }
  }
  findSnapForVertex (pt, snapPts) {
    for (var i = 0; i < snapPts.length; i++) {
      if (pt.equals2D(snapPts[i])) return null
      if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i]
    }
    return null
  }
  snapTo (snapPts) {
    var coordList = new CoordinateList(this._srcPts);
    this.snapVertices(coordList, snapPts);
    this.snapSegments(coordList, snapPts);
    var newPts = coordList.toCoordinateArray();
    return newPts
  }
  snapSegments (srcCoords, snapPts) {
    if (snapPts.length === 0) return null
    var distinctPtCount = snapPts.length;
    if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;
    for (var i = 0; i < distinctPtCount; i++) {
      var snapPt = snapPts[i];
      var index = this.findSegmentIndexToSnap(snapPt, srcCoords);
      if (index >= 0) {
        srcCoords.add(index + 1, new Coordinate(snapPt), false);
      }
    }
  }
  findSegmentIndexToSnap (snapPt, srcCoords) {
    var minDist = Double.MAX_VALUE;
    var snapIndex = -1;
    for (var i = 0; i < srcCoords.size() - 1; i++) {
      this._seg.p0 = srcCoords.get(i);
      this._seg.p1 = srcCoords.get(i + 1);
      if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {
        if (this._allowSnappingToSourceVertices) continue; else return -1
      }
      var dist = this._seg.distance(snapPt);
      if (dist < this._snapTolerance && dist < minDist) {
        minDist = dist;
        snapIndex = i;
      }
    }
    return snapIndex
  }
  setAllowSnappingToSourceVertices (allowSnappingToSourceVertices) {
    this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return LineStringSnapper
  }
  static isClosed (pts) {
    if (pts.length <= 1) return false
    return pts[0].equals2D(pts[pts.length - 1])
  }
}

class GeometrySnapper {
  constructor (srcGeom) {
    this._srcGeom = srcGeom || null;
  }
  snapTo (snapGeom, snapTolerance) {
    var snapPts = this.extractTargetCoordinates(snapGeom);
    var snapTrans = new SnapTransformer(snapTolerance, snapPts);
    return snapTrans.transform(this._srcGeom)
  }
  snapToSelf (snapTolerance, cleanResult) {
    var snapPts = this.extractTargetCoordinates(this._srcGeom);
    var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
    var snappedGeom = snapTrans.transform(this._srcGeom);
    var result = snappedGeom;
    if (cleanResult && hasInterface(result, Polygonal)) {
      result = snappedGeom.buffer(0);
    }
    return result
  }
  computeSnapTolerance (ringPts) {
    var minSegLen = this.computeMinimumSegmentLength(ringPts);
    var snapTol = minSegLen / 10;
    return snapTol
  }
  extractTargetCoordinates (g) {
    var ptSet = new TreeSet();
    var pts = g.getCoordinates();
    for (var i = 0; i < pts.length; i++) {
      ptSet.add(pts[i]);
    }
    return ptSet.toArray(new Array(0).fill(null))
  }
  computeMinimumSegmentLength (pts) {
    var minSegLen = Double.MAX_VALUE;
    for (var i = 0; i < pts.length - 1; i++) {
      var segLen = pts[i].distance(pts[i + 1]);
      if (segLen < minSegLen) minSegLen = segLen;
    }
    return minSegLen
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometrySnapper
  }
  static snap (g0, g1, snapTolerance) {
    var snapGeom = new Array(2).fill(null);
    var snapper0 = new GeometrySnapper(g0);
    snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
    var snapper1 = new GeometrySnapper(g1);
    snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
    return snapGeom
  }
  static computeOverlaySnapTolerance () {
    if (arguments.length === 1) {
      const g = arguments[0];
      let snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
      const pm = g.getPrecisionModel();
      if (pm.getType() === PrecisionModel.FIXED) {
        const fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
        if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;
      }
      return snapTolerance
    } else if (arguments.length === 2) {
      const g0 = arguments[0];
      const g1 = arguments[1];
      return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1))
    }
  }
  static computeSizeBasedSnapTolerance (g) {
    var env = g.getEnvelopeInternal();
    var minDimension = Math.min(env.getHeight(), env.getWidth());
    var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
    return snapTol
  }
  static snapToSelf (geom, snapTolerance, cleanResult) {
    var snapper0 = new GeometrySnapper(geom);
    return snapper0.snapToSelf(snapTolerance, cleanResult)
  }
  static get SNAP_PRECISION_FACTOR () { return 1e-9 }
}

class SnapTransformer extends GeometryTransformer {
  constructor (snapTolerance, snapPts, isSelfSnap) {
    super();
    this._snapTolerance = snapTolerance || null;
    this._snapPts = snapPts || null;
    this._isSelfSnap = (isSelfSnap !== undefined) ? isSelfSnap : false;
  }
  snapLine (srcPts, snapPts) {
    var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
    snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
    return snapper.snapTo(snapPts)
  }
  transformCoordinates (coords, parent) {
    var srcPts = coords.toCoordinateArray();
    var newPts = this.snapLine(srcPts, this._snapPts);
    return this._factory.getCoordinateSequenceFactory().create(newPts)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SnapTransformer
  }
}

class CommonBits {
  constructor () {
    this._isFirst = true;
    this._commonMantissaBitsCount = 53;
    this._commonBits = 0;
    this._commonSignExp = null;
  }
  getCommon () {
    return Double.longBitsToDouble(this._commonBits)
  }
  add (num) {
    const numBits = Double.doubleToLongBits(num);
    if (this._isFirst) {
      this._commonBits = numBits;
      this._commonSignExp = CommonBits.signExpBits(this._commonBits);
      this._isFirst = false;
      return null
    }
    const numSignExp = CommonBits.signExpBits(numBits);
    if (numSignExp !== this._commonSignExp) {
      this._commonBits = 0;
      return null
    }
    this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
    this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
  }
  toString () {
    if (arguments.length === 1) {
      let bits = arguments[0];
      const x = Double.longBitsToDouble(bits);
      const numStr = Double.toBinaryString(bits);
      const padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;
      const bitStr = padStr.substring(padStr.length - 64);
      const str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';
      return str
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return CommonBits
  }
  static getBit (bits, i) {
    const mask = 1 << i;
    return (bits & mask) !== 0 ? 1 : 0
  }
  static signExpBits (num) {
    return num >> 52
  }
  static zeroLowerBits (bits, nBits) {
    const invMask = (1 << nBits) - 1;
    const mask = ~invMask;
    const zeroed = bits & mask;
    return zeroed
  }
  static numCommonMostSigMantissaBits (num1, num2) {
    let count = 0;
    for (let i = 52; i >= 0; i--) {
      if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count
      count++;
    }
    return 52
  }
}

class CommonBitsRemover {
  constructor () {
    this._commonCoord = null;
    this._ccFilter = new CommonCoordinateFilter();
  }
  addCommonBits (geom) {
    const trans = new Translater(this._commonCoord);
    geom.apply(trans);
    geom.geometryChanged();
  }
  removeCommonBits (geom) {
    if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom
    const invCoord = new Coordinate(this._commonCoord);
    invCoord.x = -invCoord.x;
    invCoord.y = -invCoord.y;
    const trans = new Translater(invCoord);
    geom.apply(trans);
    geom.geometryChanged();
    return geom
  }
  getCommonCoordinate () {
    return this._commonCoord
  }
  add (geom) {
    geom.apply(this._ccFilter);
    this._commonCoord = this._ccFilter.getCommonCoordinate();
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return CommonBitsRemover
  }
  static get CommonCoordinateFilter () { return CommonCoordinateFilter }
  static get Translater () { return Translater }
}

class CommonCoordinateFilter {
  constructor () {
    this._commonBitsX = new CommonBits();
    this._commonBitsY = new CommonBits();
  }
  filter (coord) {
    this._commonBitsX.add(coord.x);
    this._commonBitsY.add(coord.y);
  }
  getCommonCoordinate () {
    return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
  }
  interfaces_ () {
    return [CoordinateFilter]
  }
  getClass () {
    return CommonCoordinateFilter
  }
}

class Translater {
  constructor () {
    this.trans = null;
    let trans = arguments[0];
    this.trans = trans;
  }
  filter (seq, i) {
    const xp = seq.getOrdinate(i, 0) + this.trans.x;
    const yp = seq.getOrdinate(i, 1) + this.trans.y;
    seq.setOrdinate(i, 0, xp);
    seq.setOrdinate(i, 1, yp);
  }
  isDone () {
    return false
  }
  isGeometryChanged () {
    return true
  }
  interfaces_ () {
    return [CoordinateSequenceFilter]
  }
  getClass () {
    return Translater
  }
}

class SnapOverlayOp {
  constructor (g1, g2) {
    this._geom = new Array(2).fill(null);
    this._snapTolerance = null;
    this._cbr = null;
    this._geom[0] = g1;
    this._geom[1] = g2;
    this.computeSnapTolerance();
  }
  selfSnap (geom) {
    var snapper0 = new GeometrySnapper(geom);
    var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
    return snapGeom
  }
  removeCommonBits (geom) {
    this._cbr = new CommonBitsRemover();
    this._cbr.add(geom[0]);
    this._cbr.add(geom[1]);
    var remGeom = new Array(2).fill(null);
    remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
    remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
    return remGeom
  }
  prepareResult (geom) {
    this._cbr.addCommonBits(geom);
    return geom
  }
  getResultGeometry (opCode) {
    var prepGeom = this.snap(this._geom);
    var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
    return this.prepareResult(result)
  }
  checkValid (g) {
    if (!g.isValid()) {
      System.out.println('Snapped geometry is invalid');
    }
  }
  computeSnapTolerance () {
    this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
  }
  snap (geom) {
    var remGeom = this.removeCommonBits(geom);
    var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
    return snapGeom
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SnapOverlayOp
  }
  static overlayOp (g0, g1, opCode) {
    var op = new SnapOverlayOp(g0, g1);
    return op.getResultGeometry(opCode)
  }
  static union (g0, g1) {
    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)
  }
  static intersection (g0, g1) {
    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)
  }
  static symDifference (g0, g1) {
    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)
  }
  static difference (g0, g1) {
    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)
  }
}

class SnapIfNeededOverlayOp {
  constructor (g1, g2) {
    this._geom = new Array(2).fill(null);
    this._geom[0] = g1;
    this._geom[1] = g2;
  }
  getResultGeometry (opCode) {
    var result = null;
    var isSuccess = false;
    var savedException = null;
    try {
      result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
      var isValid = true;
      if (isValid) isSuccess = true;
    } catch (ex) {
      if (ex instanceof RuntimeException) {
        savedException = ex;
      } else throw ex
    } finally {}
    if (!isSuccess) {
      try {
        result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
      } catch (ex) {
        if (ex instanceof RuntimeException) {
          throw savedException
        } else throw ex
      } finally {}
    }
    return result
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SnapIfNeededOverlayOp
  }
  static overlayOp (g0, g1, opCode) {
    var op = new SnapIfNeededOverlayOp(g0, g1);
    return op.getResultGeometry(opCode)
  }
  static union (g0, g1) {
    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)
  }
  static intersection (g0, g1) {
    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)
  }
  static symDifference (g0, g1) {
    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)
  }
  static difference (g0, g1) {
    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)
  }
}

class MonotoneChain$1 {
  constructor () {
    this.mce = null;
    this.chainIndex = null;
    const mce = arguments[0];
    const chainIndex = arguments[1];
    this.mce = mce;
    this.chainIndex = chainIndex;
  }
  computeIntersections (mc, si) {
    this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return MonotoneChain$1
  }
}

class SweepLineEvent {
  constructor () {
    this._label = null;
    this._xValue = null;
    this._eventType = null;
    this._insertEvent = null;
    this._deleteEventIndex = null;
    this._obj = null;
    if (arguments.length === 2) {
      const x = arguments[0];
      const insertEvent = arguments[1];
      this._eventType = SweepLineEvent.DELETE;
      this._xValue = x;
      this._insertEvent = insertEvent;
    } else if (arguments.length === 3) {
      const label = arguments[0];
      const x = arguments[1];
      const obj = arguments[2];
      this._eventType = SweepLineEvent.INSERT;
      this._label = label;
      this._xValue = x;
      this._obj = obj;
    }
  }
  isDelete () {
    return this._eventType === SweepLineEvent.DELETE
  }
  setDeleteEventIndex (deleteEventIndex) {
    this._deleteEventIndex = deleteEventIndex;
  }
  getObject () {
    return this._obj
  }
  compareTo (o) {
    var pe = o;
    if (this._xValue < pe._xValue) return -1
    if (this._xValue > pe._xValue) return 1
    if (this._eventType < pe._eventType) return -1
    if (this._eventType > pe._eventType) return 1
    return 0
  }
  getInsertEvent () {
    return this._insertEvent
  }
  isInsert () {
    return this._eventType === SweepLineEvent.INSERT
  }
  isSameLabel (ev) {
    if (this._label === null) return false
    return this._label === ev._label
  }
  getDeleteEventIndex () {
    return this._deleteEventIndex
  }
  interfaces_ () {
    return [Comparable]
  }
  getClass () {
    return SweepLineEvent
  }
  static get INSERT () { return 1 }
  static get DELETE () { return 2 }
}

class EdgeSetIntersector {
  interfaces_ () {
    return []
  }
  getClass () {
    return EdgeSetIntersector
  }
}

class SegmentIntersector$1 {
  constructor () {
    this._hasIntersection = false;
    this._hasProper = false;
    this._hasProperInterior = false;
    this._properIntersectionPoint = null;
    this._li = null;
    this._includeProper = null;
    this._recordIsolated = null;
    this._isSelfIntersection = null;
    this._numIntersections = 0;
    this.numTests = 0;
    this._bdyNodes = null;
    this._isDone = false;
    this._isDoneWhenProperInt = false;
    const li = arguments[0];
    const includeProper = arguments[1];
    const recordIsolated = arguments[2];
    this._li = li;
    this._includeProper = includeProper;
    this._recordIsolated = recordIsolated;
  }
  isTrivialIntersection (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1) {
      if (this._li.getIntersectionNum() === 1) {
        if (SegmentIntersector$1.isAdjacentSegments(segIndex0, segIndex1)) return true
        if (e0.isClosed()) {
          var maxSegIndex = e0.getNumPoints() - 1;
          if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
              (segIndex1 === 0 && segIndex0 === maxSegIndex)) {
            return true
          }
        }
      }
    }
    return false
  }
  getProperIntersectionPoint () {
    return this._properIntersectionPoint
  }
  setIsDoneIfProperInt (isDoneWhenProperInt) {
    this._isDoneWhenProperInt = isDoneWhenProperInt;
  }
  hasProperInteriorIntersection () {
    return this._hasProperInterior
  }
  isBoundaryPointInternal (li, bdyNodes) {
    for (var i = bdyNodes.iterator(); i.hasNext();) {
      var node = i.next();
      var pt = node.getCoordinate();
      if (li.isIntersection(pt)) return true
    }
    return false
  }
  hasProperIntersection () {
    return this._hasProper
  }
  hasIntersection () {
    return this._hasIntersection
  }
  isDone () {
    return this._isDone
  }
  isBoundaryPoint (li, bdyNodes) {
    if (bdyNodes === null) return false
    if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true
    if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true
    return false
  }
  setBoundaryNodes (bdyNodes0, bdyNodes1) {
    this._bdyNodes = new Array(2).fill(null);
    this._bdyNodes[0] = bdyNodes0;
    this._bdyNodes[1] = bdyNodes1;
  }
  addIntersections (e0, segIndex0, e1, segIndex1) {
    if (e0 === e1 && segIndex0 === segIndex1) return null
    this.numTests++;
    var p00 = e0.getCoordinates()[segIndex0];
    var p01 = e0.getCoordinates()[segIndex0 + 1];
    var p10 = e1.getCoordinates()[segIndex1];
    var p11 = e1.getCoordinates()[segIndex1 + 1];
    this._li.computeIntersection(p00, p01, p10, p11);
    if (this._li.hasIntersection()) {
      if (this._recordIsolated) {
        e0.setIsolated(false);
        e1.setIsolated(false);
      }
      this._numIntersections++;
      if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
        this._hasIntersection = true;
        if (this._includeProper || !this._li.isProper()) {
          e0.addIntersections(this._li, segIndex0, 0);
          e1.addIntersections(this._li, segIndex1, 1);
        }
        if (this._li.isProper()) {
          this._properIntersectionPoint = this._li.getIntersection(0).copy();
          this._hasProper = true;
          if (this._isDoneWhenProperInt) {
            this._isDone = true;
          }
          if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;
        }
      }
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SegmentIntersector$1
  }
  static isAdjacentSegments (i1, i2) {
    return Math.abs(i1 - i2) === 1
  }
}

class SimpleMCSweepLineIntersector extends EdgeSetIntersector {
  constructor () {
    super();
    this.events = new ArrayList();
    this.nOverlaps = null;
  }
  prepareEvents () {
    Collections.sort(this.events);
    for (let i = 0; i < this.events.size(); i++) {
      const ev = this.events.get(i);
      if (ev.isDelete()) {
        ev.getInsertEvent().setDeleteEventIndex(i);
      }
    }
  }
  computeIntersections () {
    if (arguments.length === 1) {
      let si = arguments[0];
      this.nOverlaps = 0;
      this.prepareEvents();
      for (let i = 0; i < this.events.size(); i++) {
        const ev = this.events.get(i);
        if (ev.isInsert()) {
          this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
        }
        if (si.isDone()) {
          break
        }
      }
    } else if (arguments.length === 3) {
      if (arguments[2] instanceof SegmentIntersector$1 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {
        const edges0 = arguments[0];
        const edges1 = arguments[1];
        const si = arguments[2];
        this.addEdges(edges0, edges0);
        this.addEdges(edges1, edges1);
        this.computeIntersections(si);
      } else if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$1)) {
        const edges = arguments[0];
        const si = arguments[1];
        const testAllSegments = arguments[2];
        if (testAllSegments) this.addEdges(edges, null); else this.addEdges(edges);
        this.computeIntersections(si);
      }
    }
  }
  addEdge (edge, edgeSet) {
    const mce = edge.getMonotoneChainEdge();
    const startIndex = mce.getStartIndexes();
    for (let i = 0; i < startIndex.length - 1; i++) {
      const mc = new MonotoneChain$1(mce, i);
      const insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
      this.events.add(insertEvent);
      this.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
    }
  }
  processOverlaps (start, end, ev0, si) {
    const mc0 = ev0.getObject();
    for (let i = start; i < end; i++) {
      const ev1 = this.events.get(i);
      if (ev1.isInsert()) {
        const mc1 = ev1.getObject();
        if (!ev0.isSameLabel(ev1)) {
          mc0.computeIntersections(mc1, si);
          this.nOverlaps++;
        }
      }
    }
  }
  addEdges () {
    if (arguments.length === 1) {
      let edges = arguments[0];
      for (const i = edges.iterator(); i.hasNext();) {
        const edge = i.next();
        this.addEdge(edge, edge);
      }
    } else if (arguments.length === 2) {
      const edges = arguments[0];
      const edgeSet = arguments[1];
      for (const i = edges.iterator(); i.hasNext();) {
        const edge = i.next();
        this.addEdge(edge, edgeSet);
      }
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SimpleMCSweepLineIntersector
  }
}

class IntervalRTreeNode {
  constructor () {
    this._min = Double.POSITIVE_INFINITY;
    this._max = Double.NEGATIVE_INFINITY;
  }
  getMin () {
    return this._min
  }
  intersects (queryMin, queryMax) {
    if (this._min > queryMax || this._max < queryMin) return false
    return true
  }
  getMax () {
    return this._max
  }
  toString () {
    return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0))
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return IntervalRTreeNode
  }
  static get NodeComparator () { return NodeComparator }
}

class NodeComparator {
  compare (o1, o2) {
    var n1 = o1;
    var n2 = o2;
    var mid1 = (n1._min + n1._max) / 2;
    var mid2 = (n2._min + n2._max) / 2;
    if (mid1 < mid2) return -1
    if (mid1 > mid2) return 1
    return 0
  }
  interfaces_ () {
    return [Comparator]
  }
  getClass () {
    return NodeComparator
  }
}

class IntervalRTreeLeafNode extends IntervalRTreeNode {
  constructor () {
    super();
    this._item = null;
    const min = arguments[0];
    const max = arguments[1];
    const item = arguments[2];
    this._min = min;
    this._max = max;
    this._item = item;
  }
  query (queryMin, queryMax, visitor) {
    if (!this.intersects(queryMin, queryMax)) return null
    visitor.visitItem(this._item);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return IntervalRTreeLeafNode
  }
}

class IntervalRTreeBranchNode extends IntervalRTreeNode {
  constructor () {
    super();
    this._node1 = null;
    this._node2 = null;
    const n1 = arguments[0];
    const n2 = arguments[1];
    this._node1 = n1;
    this._node2 = n2;
    this.buildExtent(this._node1, this._node2);
  }
  buildExtent (n1, n2) {
    this._min = Math.min(n1._min, n2._min);
    this._max = Math.max(n1._max, n2._max);
  }
  query (queryMin, queryMax, visitor) {
    if (!this.intersects(queryMin, queryMax)) {
      return null
    }
    if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);
    if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return IntervalRTreeBranchNode
  }
}

class SortedPackedIntervalRTree {
  constructor () {
    this._leaves = new ArrayList();
    this._root = null;
    this._level = 0;
  }
  buildTree () {
    Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
    var src = this._leaves;
    var temp = null;
    var dest = new ArrayList();
    while (true) {
      this.buildLevel(src, dest);
      if (dest.size() === 1) return dest.get(0)
      temp = src;
      src = dest;
      dest = temp;
    }
  }
  insert (min, max, item) {
    if (this._root !== null) throw new Error('Index cannot be added to once it has been queried')
    this._leaves.add(new IntervalRTreeLeafNode(min, max, item));
  }
  query (min, max, visitor) {
    this.init();
    this._root.query(min, max, visitor);
  }
  buildRoot () {
    if (this._root !== null) return null
    this._root = this.buildTree();
  }
  printNode (node) {
    System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
  }
  init () {
    if (this._root !== null) return null
    this.buildRoot();
  }
  buildLevel (src, dest) {
    this._level++;
    dest.clear();
    for (var i = 0; i < src.size(); i += 2) {
      var n1 = src.get(i);
      var n2 = i + 1 < src.size() ? src.get(i) : null;
      if (n2 === null) {
        dest.add(n1);
      } else {
        var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));
        dest.add(node);
      }
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return SortedPackedIntervalRTree
  }
}

class ArrayListVisitor {
  constructor () {
    this._items = new ArrayList();
  }
  visitItem (item) {
    this._items.add(item);
  }
  getItems () {
    return this._items
  }
  interfaces_ () {
    return [ItemVisitor]
  }
  getClass () {
    return ArrayListVisitor
  }
}

class IndexedPointInAreaLocator {
  constructor () {
    this._index = null;
    const g = arguments[0];
    if (!hasInterface(g, Polygonal)) throw new IllegalArgumentException('Argument must be Polygonal')
    this._index = new IntervalIndexedGeometry(g);
  }
  locate (p) {
    var rcc = new RayCrossingCounter(p);
    var visitor = new SegmentVisitor(rcc);
    this._index.query(p.y, p.y, visitor);
    return rcc.getLocation()
  }
  interfaces_ () {
    return [PointOnGeometryLocator]
  }
  getClass () {
    return IndexedPointInAreaLocator
  }
  static get SegmentVisitor () { return SegmentVisitor }
  static get IntervalIndexedGeometry () { return IntervalIndexedGeometry }
}

class SegmentVisitor {
  constructor () {
    this._counter = null;
    const counter = arguments[0];
    this._counter = counter;
  }
  visitItem (item) {
    var seg = item;
    this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
  }
  interfaces_ () {
    return [ItemVisitor]
  }
  getClass () {
    return SegmentVisitor
  }
}

class IntervalIndexedGeometry {
  constructor () {
    this._index = new SortedPackedIntervalRTree();
    const geom = arguments[0];
    this.init(geom);
  }
  init (geom) {
    var lines = LinearComponentExtracter.getLines(geom);
    for (var i = lines.iterator(); i.hasNext();) {
      var line = i.next();
      var pts = line.getCoordinates();
      this.addLine(pts);
    }
  }
  addLine (pts) {
    for (var i = 1; i < pts.length; i++) {
      var seg = new LineSegment(pts[i - 1], pts[i]);
      var min = Math.min(seg.p0.y, seg.p1.y);
      var max = Math.max(seg.p0.y, seg.p1.y);
      this._index.insert(min, max, seg);
    }
  }
  query () {
    if (arguments.length === 2) {
      const min = arguments[0];
      const max = arguments[1];
      var visitor = new ArrayListVisitor();
      this._index.query(min, max, visitor);
      return visitor.getItems()
    } else if (arguments.length === 3) {
      const min = arguments[0];
      const max = arguments[1];
      const visitor = arguments[2];
      this._index.query(min, max, visitor);
    }
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return IntervalIndexedGeometry
  }
}

class GeometryGraph extends PlanarGraph {
  constructor () {
    super();
    this._parentGeom = null;
    this._lineEdgeMap = new HashMap();
    this._boundaryNodeRule = null;
    this._useBoundaryDeterminationRule = true;
    this._argIndex = null;
    this._boundaryNodes = null;
    this._hasTooFewPoints = false;
    this._invalidPoint = null;
    this._areaPtLocator = null;
    this._ptLocator = new PointLocator();
    if (arguments.length === 2) {
      const argIndex = arguments[0];
      const parentGeom = arguments[1];
      const boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
      this._argIndex = argIndex;
      this._parentGeom = parentGeom;
      this._boundaryNodeRule = boundaryNodeRule;
      if (parentGeom !== null) {
        this.add(parentGeom);
      }
    } else if (arguments.length === 3) {
      const argIndex = arguments[0];
      const parentGeom = arguments[1];
      const boundaryNodeRule = arguments[2];
      this._argIndex = argIndex;
      this._parentGeom = parentGeom;
      this._boundaryNodeRule = boundaryNodeRule;
      if (parentGeom !== null) {
        this.add(parentGeom);
      }
    }
  }
  insertBoundaryPoint (argIndex, coord) {
    const n = this._nodes.addNode(coord);
    const lbl = n.getLabel();
    let boundaryCount = 1;
    let loc = Location.NONE;
    loc = lbl.getLocation(argIndex, Position.ON);
    if (loc === Location.BOUNDARY) boundaryCount++;
    const newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
    lbl.setLocation(argIndex, newLoc);
  }
  computeSelfNodes () {
    if (arguments.length === 2) {
      const li = arguments[0];
      const computeRingSelfNodes = arguments[1];
      return this.computeSelfNodes(li, computeRingSelfNodes, false)
    } else if (arguments.length === 3) {
      const li = arguments[0];
      const computeRingSelfNodes = arguments[1];
      const isDoneIfProperInt = arguments[2];
      const si = new SegmentIntersector$1(li, true, false);
      si.setIsDoneIfProperInt(isDoneIfProperInt);
      const esi = this.createEdgeSetIntersector();
      const isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;
      const computeAllSegments = computeRingSelfNodes || !isRings;
      esi.computeIntersections(this._edges, si, computeAllSegments);
      this.addSelfIntersectionNodes(this._argIndex);
      return si
    }
  }
  computeSplitEdges (edgelist) {
    for (const i = this._edges.iterator(); i.hasNext();) {
      const e = i.next();
      e.eiList.addSplitEdges(edgelist);
    }
  }
  computeEdgeIntersections (g, li, includeProper) {
    const si = new SegmentIntersector$1(li, includeProper, true);
    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
    const esi = this.createEdgeSetIntersector();
    esi.computeIntersections(this._edges, g._edges, si);
    return si
  }
  getGeometry () {
    return this._parentGeom
  }
  getBoundaryNodeRule () {
    return this._boundaryNodeRule
  }
  hasTooFewPoints () {
    return this._hasTooFewPoints
  }
  addPoint () {
    if (arguments[0] instanceof Point) {
      let p = arguments[0];
      const coord = p.getCoordinate();
      this.insertPoint(this._argIndex, coord, Location.INTERIOR);
    } else if (arguments[0] instanceof Coordinate) {
      let pt = arguments[0];
      this.insertPoint(this._argIndex, pt, Location.INTERIOR);
    }
  }
  addPolygon (p) {
    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
    for (let i = 0; i < p.getNumInteriorRing(); i++) {
      const hole = p.getInteriorRingN(i);
      this.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
    }
  }
  addEdge (e) {
    this.insertEdge(e);
    const coord = e.getCoordinates();
    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
    this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
  }
  addLineString (line) {
    const coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
    if (coord.length < 2) {
      this._hasTooFewPoints = true;
      this._invalidPoint = coord[0];
      return null
    }
    const e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));
    this._lineEdgeMap.put(line, e);
    this.insertEdge(e);
    Assert.isTrue(coord.length >= 2, 'found LineString with single point');
    this.insertBoundaryPoint(this._argIndex, coord[0]);
    this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
  }
  getInvalidPoint () {
    return this._invalidPoint
  }
  getBoundaryPoints () {
    const coll = this.getBoundaryNodes();
    const pts = new Array(coll.size()).fill(null);
    let i = 0;
    for (const it = coll.iterator(); it.hasNext();) {
      const node = it.next();
      pts[i++] = node.getCoordinate().copy();
    }
    return pts
  }
  getBoundaryNodes () {
    if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
    return this._boundaryNodes
  }
  addSelfIntersectionNode (argIndex, coord, loc) {
    if (this.isBoundaryNode(argIndex, coord)) return null
    if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord); else this.insertPoint(argIndex, coord, loc);
  }
  addPolygonRing (lr, cwLeft, cwRight) {
    if (lr.isEmpty()) return null
    const coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
    if (coord.length < 4) {
      this._hasTooFewPoints = true;
      this._invalidPoint = coord[0];
      return null
    }
    let left = cwLeft;
    let right = cwRight;
    if (CGAlgorithms.isCCW(coord)) {
      left = cwRight;
      right = cwLeft;
    }
    const e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
    this._lineEdgeMap.put(lr, e);
    this.insertEdge(e);
    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
  }
  insertPoint (argIndex, coord, onLocation) {
    const n = this._nodes.addNode(coord);
    const lbl = n.getLabel();
    if (lbl === null) {
      n._label = new Label(argIndex, onLocation);
    } else lbl.setLocation(argIndex, onLocation);
  }
  createEdgeSetIntersector () {
    return new SimpleMCSweepLineIntersector()
  }
  addSelfIntersectionNodes (argIndex) {
    for (const i = this._edges.iterator(); i.hasNext();) {
      const e = i.next();
      const eLoc = e.getLabel().getLocation(argIndex);
      for (const eiIt = e.eiList.iterator(); eiIt.hasNext();) {
        const ei = eiIt.next();
        this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
      }
    }
  }
  add () {
    if (arguments.length === 1) {
      let g = arguments[0];
      if (g.isEmpty()) return null
      if (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;
      if (g instanceof Polygon) this.addPolygon(g);
      else if (g instanceof LineString) this.addLineString(g);
      else if (g instanceof Point) this.addPoint(g);
      else if (g instanceof MultiPoint) this.addCollection(g);
      else if (g instanceof MultiLineString) this.addCollection(g);
      else if (g instanceof MultiPolygon) this.addCollection(g);
      else if (g instanceof GeometryCollection) this.addCollection(g);
      else throw new Error(g.getClass().getName())
    } else return PlanarGraph.prototype.add.apply(this, arguments)
  }
  addCollection (gc) {
    for (let i = 0; i < gc.getNumGeometries(); i++) {
      const g = gc.getGeometryN(i);
      this.add(g);
    }
  }
  locate (pt) {
    if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
      if (this._areaPtLocator === null) {
        this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
      }
      return this._areaPtLocator.locate(pt)
    }
    return this._ptLocator.locate(pt, this._parentGeom)
  }
  findEdge () {
    if (arguments.length === 1) {
      let line = arguments[0];
      return this._lineEdgeMap.get(line)
    } else return PlanarGraph.prototype.findEdge.apply(this, arguments)
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryGraph
  }
  static determineBoundary (boundaryNodeRule, boundaryCount) {
    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR
  }
}

class GeometryGraphOp {
  constructor () {
    this._li = new RobustLineIntersector();
    this._resultPrecisionModel = null;
    this._arg = null;
    if (arguments.length === 1) {
      const g0 = arguments[0];
      this.setComputationPrecision(g0.getPrecisionModel());
      this._arg = new Array(1).fill(null);
      this._arg[0] = new GeometryGraph(0, g0);
    } else if (arguments.length === 2) {
      const g0 = arguments[0];
      const g1 = arguments[1];
      const boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
      if (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());
      this._arg = new Array(2).fill(null);
      this._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);
      this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
    } else if (arguments.length === 3) {
      const g0 = arguments[0];
      const g1 = arguments[1];
      const boundaryNodeRule = arguments[2];
      if (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());
      this._arg = new Array(2).fill(null);
      this._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);
      this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
    }
  }
  getArgGeometry (i) {
    return this._arg[i].getGeometry()
  }
  setComputationPrecision (pm) {
    this._resultPrecisionModel = pm;
    this._li.setPrecisionModel(this._resultPrecisionModel);
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryGraphOp
  }
}

// operation.geometrygraph

class GeometryMapper {
  interfaces_ () {
    return []
  }
  getClass () {
    return GeometryMapper
  }
  static map () {
    if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {
      const geom = arguments[0];
      const op = arguments[1];
      const mapped = new ArrayList();
      for (let i = 0; i < geom.getNumGeometries(); i++) {
        const g = op.map(geom.getGeometryN(i));
        if (g !== null) mapped.add(g);
      }
      return geom.getFactory().buildGeometry(mapped)
    } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {
      const geoms = arguments[0];
      const op = arguments[1];
      const mapped = new ArrayList();
      for (const i = geoms.iterator(); i.hasNext();) {
        const g = i.next();
        const gr = op.map(g);
        if (gr !== null) mapped.add(gr);
      }
      return mapped
    }
  }
  static MapOp () {}
}

class OverlayOp extends GeometryGraphOp {
  constructor () {
    const g0 = arguments[0];
    const g1 = arguments[1];
    super(g0, g1);
    this._ptLocator = new PointLocator();
    this._geomFact = null;
    this._resultGeom = null;
    this._graph = null;
    this._edgeList = new EdgeList();
    this._resultPolyList = new ArrayList();
    this._resultLineList = new ArrayList();
    this._resultPointList = new ArrayList();
    this._graph = new PlanarGraph(new OverlayNodeFactory());
    this._geomFact = g0.getFactory();
  }
  insertUniqueEdge (e) {
    const existingEdge = this._edgeList.findEqualEdge(e);
    if (existingEdge !== null) {
      const existingLabel = existingEdge.getLabel();
      let labelToMerge = e.getLabel();
      if (!existingEdge.isPointwiseEqual(e)) {
        labelToMerge = new Label(e.getLabel());
        labelToMerge.flip();
      }
      const depth = existingEdge.getDepth();
      if (depth.isNull()) {
        depth.add(existingLabel);
      }
      depth.add(labelToMerge);
      existingLabel.merge(labelToMerge);
    } else {
      this._edgeList.add(e);
    }
  }
  getGraph () {
    return this._graph
  }
  cancelDuplicateResultEdges () {
    for (const it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
      const de = it.next();
      const sym = de.getSym();
      if (de.isInResult() && sym.isInResult()) {
        de.setInResult(false);
        sym.setInResult(false);
      }
    }
  }
  isCoveredByLA (coord) {
    if (this.isCovered(coord, this._resultLineList)) return true
    if (this.isCovered(coord, this._resultPolyList)) return true
    return false
  }
  computeGeometry (resultPointList, resultLineList, resultPolyList, opcode) {
    const geomList = new ArrayList();
    geomList.addAll(resultPointList);
    geomList.addAll(resultLineList);
    geomList.addAll(resultPolyList);
    if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact)
    return this._geomFact.buildGeometry(geomList)
  }
  mergeSymLabels () {
    for (const nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().mergeSymLabels();
    }
  }
  isCovered (coord, geomList) {
    for (const it = geomList.iterator(); it.hasNext();) {
      const geom = it.next();
      const loc = this._ptLocator.locate(coord, geom);
      if (loc !== Location.EXTERIOR) return true
    }
    return false
  }
  replaceCollapsedEdges () {
    const newEdges = new ArrayList();
    for (const it = this._edgeList.iterator(); it.hasNext();) {
      const e = it.next();
      if (e.isCollapsed()) {
        it.remove();
        newEdges.add(e.getCollapsedEdge());
      }
    }
    this._edgeList.addAll(newEdges);
  }
  updateNodeLabelling () {
    for (const nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      const lbl = node.getEdges().getLabel();
      node.getLabel().merge(lbl);
    }
  }
  getResultGeometry (overlayOpCode) {
    this.computeOverlay(overlayOpCode);
    return this._resultGeom
  }
  insertUniqueEdges (edges) {
    for (let i = edges.iterator(); i.hasNext();) {
      const e = i.next();
      this.insertUniqueEdge(e);
    }
  }
  computeOverlay (opCode) {
    this.copyPoints(0);
    this.copyPoints(1);
    this._arg[0].computeSelfNodes(this._li, false);
    this._arg[1].computeSelfNodes(this._li, false);
    this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
    const baseSplitEdges = new ArrayList();
    this._arg[0].computeSplitEdges(baseSplitEdges);
    this._arg[1].computeSplitEdges(baseSplitEdges);
    // const splitEdges = baseSplitEdges
    this.insertUniqueEdges(baseSplitEdges);
    this.computeLabelsFromDepths();
    this.replaceCollapsedEdges();
    EdgeNodingValidator.checkValid(this._edgeList.getEdges());
    this._graph.addEdges(this._edgeList.getEdges());
    this.computeLabelling();
    this.labelIncompleteNodes();
    this.findResultAreaEdges(opCode);
    this.cancelDuplicateResultEdges();
    const polyBuilder = new PolygonBuilder(this._geomFact);
    polyBuilder.add(this._graph);
    this._resultPolyList = polyBuilder.getPolygons();
    const lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
    this._resultLineList = lineBuilder.build(opCode);
    const pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
    this._resultPointList = pointBuilder.build(opCode);
    this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
  }
  labelIncompleteNode (n, targetIndex) {
    const loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
    n.getLabel().setLocation(targetIndex, loc);
  }
  copyPoints (argIndex) {
    for (let i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {
      const graphNode = i.next();
      const newNode = this._graph.addNode(graphNode.getCoordinate());
      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
    }
  }
  findResultAreaEdges (opCode) {
    for (const it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
      const de = it.next();
      const label = de.getLabel();
      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
        de.setInResult(true);
      }
    }
  }
  computeLabelsFromDepths () {
    for (const it = this._edgeList.iterator(); it.hasNext();) {
      const e = it.next();
      const lbl = e.getLabel();
      const depth = e.getDepth();
      if (!depth.isNull()) {
        depth.normalize();
        for (let i = 0; i < 2; i++) {
          if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
            if (depth.getDelta(i) === 0) {
              lbl.toLine(i);
            } else {
              Assert.isTrue(!depth.isNull(i, Position.LEFT), 'depth of LEFT side has not been initialized');
              lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));
              Assert.isTrue(!depth.isNull(i, Position.RIGHT), 'depth of RIGHT side has not been initialized');
              lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));
            }
          }
        }
      }
    }
  }
  computeLabelling () {
    for (const nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
      const node = nodeit.next();
      node.getEdges().computeLabelling(this._arg);
    }
    this.mergeSymLabels();
    this.updateNodeLabelling();
  }
  labelIncompleteNodes () {
    // let nodeCount = 0
    for (const ni = this._graph.getNodes().iterator(); ni.hasNext();) {
      const n = ni.next();
      const label = n.getLabel();
      if (n.isIsolated()) {
        // nodeCount++
        if (label.isNull(0)) this.labelIncompleteNode(n, 0); else this.labelIncompleteNode(n, 1);
      }
      n.getEdges().updateLabelling(label);
    }
  }
  isCoveredByA (coord) {
    if (this.isCovered(coord, this._resultPolyList)) return true
    return false
  }
  interfaces_ () {
    return []
  }
  getClass () {
    return OverlayOp
  }
}
OverlayOp.overlayOp = function (geom0, geom1, opCode) {
  const gov = new OverlayOp(geom0, geom1);
  const geomOv = gov.getResultGeometry(opCode);
  return geomOv
};
OverlayOp.intersection = function (g, other) {
  if (g.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory())
  if (g.isGeometryCollection()) {
    const g2 = other;
    return GeometryCollectionMapper.map(g, {
      interfaces_: function () {
        return [GeometryMapper.MapOp]
      },
      map: function (g) {
        return g.intersection(g2)
      }
    })
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION)
};
OverlayOp.symDifference = function (g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory())
    if (g.isEmpty()) return other.copy()
    if (other.isEmpty()) return g.copy()
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE)
};
OverlayOp.resultDimension = function (opCode, g0, g1) {
  const dim0 = g0.getDimension();
  const dim1 = g1.getDimension();
  let resultDimension = -1;
  switch (opCode) {
    case OverlayOp.INTERSECTION:
      resultDimension = Math.min(dim0, dim1);
      break
    case OverlayOp.UNION:
      resultDimension = Math.max(dim0, dim1);
      break
    case OverlayOp.DIFFERENCE:
      resultDimension = dim0;
      break
    case OverlayOp.SYMDIFFERENCE:
      resultDimension = Math.max(dim0, dim1);
      break
    default:
  }
  return resultDimension
};
OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {
  let result = null;
  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
    case -1:
      result = geomFact.createGeometryCollection(new Array(0).fill(null));
      break
    case 0:
      result = geomFact.createPoint();
      break
    case 1:
      result = geomFact.createLineString();
      break
    case 2:
      result = geomFact.createPolygon();
      break
    default:
  }
  return result
};
OverlayOp.difference = function (g, other) {
  if (g.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory())
  if (other.isEmpty()) return g.copy()
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE)
};
OverlayOp.isResultOfOp = function () {
  if (arguments.length === 2) {
    const label = arguments[0];
    const opCode = arguments[1];
    const loc0 = label.getLocation(0);
    const loc1 = label.getLocation(1);
    return OverlayOp.isResultOfOp(loc0, loc1, opCode)
  } else if (arguments.length === 3) {
    let loc0 = arguments[0];
    let loc1 = arguments[1];
    const overlayOpCode = arguments[2];
    if (loc0 === Location.BOUNDARY) loc0 = Location.INTERIOR;
    if (loc1 === Location.BOUNDARY) loc1 = Location.INTERIOR;
    switch (overlayOpCode) {
      case OverlayOp.INTERSECTION:
        return loc0 === Location.INTERIOR && loc1 === Location.INTERIOR
      case OverlayOp.UNION:
        return loc0 === Location.INTERIOR || loc1 === Location.INTERIOR
      case OverlayOp.DIFFERENCE:
        return loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR
      case OverlayOp.SYMDIFFERENCE:
        return (loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR) || (loc0 !== Location.INTERIOR && loc1 === Location.INTERIOR)
      default:
    }
    return false
  }
};
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;

// operation.overlay

class UnionOp {
  interfaces_ () {
    return []
  }
  getClass () {
    return UnionOp
  }
  static union (g, other) {
    if (g.isEmpty() || other.isEmpty()) {
      if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory())
      if (g.isEmpty()) return other.copy()
      if (other.isEmpty()) return g.copy()
    }
    g.checkNotGeometryCollection(g);
    g.checkNotGeometryCollection(other);
    return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION)
  }
}

// operation.union

// operation

/**
 * Polyfill for IE support
 */

export { GeoJSONReader, GeoJSONWriter, OverlayOp, UnionOp, BufferOp };
