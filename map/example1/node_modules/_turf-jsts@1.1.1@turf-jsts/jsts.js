'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* Polyfill service v3.13.0
 * For detailed credits and licence information see http://github.com/financial-times/polyfill-service
 *
 * - Array.prototype.fill, License: CC0 */

if (!('fill' in Array.prototype)) {
  Object.defineProperty(Array.prototype, 'fill', {
    configurable: true,
    value: function fill(value) {
      if (this === undefined || this === null) {
        throw new TypeError(this + ' is not an object');
      }

      var arrayLike = Object(this);

      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;

      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;

      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);

      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;

      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);

      while (relativeStart < relativeEnd) {
        arrayLike[relativeStart] = value;

        ++relativeStart;
      }

      return arrayLike;
    },
    writable: true
  });
}

/**
 * Polyfill for IE support
 */
Number.isFinite = Number.isFinite || function (value) {
  return typeof value === 'number' && isFinite(value);
};

Number.isInteger = Number.isInteger || function (val) {
  return typeof val === 'number' && isFinite(val) && Math.floor(val) === val;
};

Number.parseFloat = Number.parseFloat || parseFloat;

Number.isNaN = Number.isNaN || function (value) {
  return value !== value; // eslint-disable-line
};

/**
 * Polyfill for IE support
 */
Math.trunc = Math.trunc || function (x) {
  return x < 0 ? Math.ceil(x) : Math.floor(x);
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var NumberUtil = function () {
  function NumberUtil() {
    classCallCheck(this, NumberUtil);
  }

  createClass(NumberUtil, [{
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return NumberUtil;
    }
  }, {
    key: "equalsWithTolerance",
    value: function equalsWithTolerance(x1, x2, tolerance) {
      return Math.abs(x1 - x2) <= tolerance;
    }
  }]);
  return NumberUtil;
}();

var IllegalArgumentException = function IllegalArgumentException() {
  classCallCheck(this, IllegalArgumentException);
};

var Double = function () {
  function Double() {
    classCallCheck(this, Double);
  }

  createClass(Double, null, [{
    key: "isNaN",
    value: function isNaN(n) {
      return Number.isNaN(n);
    }
  }, {
    key: "doubleToLongBits",
    value: function doubleToLongBits(n) {
      return n;
    }
  }, {
    key: "longBitsToDouble",
    value: function longBitsToDouble(n) {
      return n;
    }
  }, {
    key: "isInfinite",
    value: function isInfinite(n) {
      return !Number.isFinite(n);
    }
  }, {
    key: "MAX_VALUE",
    get: function get$$1() {
      return Number.MAX_VALUE;
    }
  }]);
  return Double;
}();

var Comparable = function Comparable() {
  classCallCheck(this, Comparable);
};

var Clonable = function Clonable() {
  classCallCheck(this, Clonable);
};

var Comparator = function Comparator() {
  classCallCheck(this, Comparator);
};

function Serializable() {}

// import Assert from '../util/Assert'

var Coordinate = function () {
  function Coordinate() {
    classCallCheck(this, Coordinate);

    this.x = null;
    this.y = null;
    this.z = null;
    if (arguments.length === 0) {
      this.x = 0.0;
      this.y = 0.0;
      this.z = Coordinate.NULL_ORDINATE;
    } else if (arguments.length === 1) {
      var c = arguments[0];
      this.x = c.x;
      this.y = c.y;
      this.z = c.z;
    } else if (arguments.length === 2) {
      this.x = arguments[0];
      this.y = arguments[1];
      this.z = Coordinate.NULL_ORDINATE;
    } else if (arguments.length === 3) {
      this.x = arguments[0];
      this.y = arguments[1];
      this.z = arguments[2];
    }
  }

  createClass(Coordinate, [{
    key: 'setOrdinate',
    value: function setOrdinate(ordinateIndex, value) {
      switch (ordinateIndex) {
        case Coordinate.X:
          this.x = value;
          break;
        case Coordinate.Y:
          this.y = value;
          break;
        case Coordinate.Z:
          this.z = value;
          break;
        default:
          throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);
      }
    }
  }, {
    key: 'equals2D',
    value: function equals2D() {
      if (arguments.length === 1) {
        var other = arguments[0];
        if (this.x !== other.x) {
          return false;
        }
        if (this.y !== other.y) {
          return false;
        }
        return true;
      } else if (arguments.length === 2) {
        var c = arguments[0];
        var tolerance = arguments[1];
        if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
          return false;
        }
        if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
          return false;
        }
        return true;
      }
    }
  }, {
    key: 'getOrdinate',
    value: function getOrdinate(ordinateIndex) {
      switch (ordinateIndex) {
        case Coordinate.X:
          return this.x;
        case Coordinate.Y:
          return this.y;
        case Coordinate.Z:
          return this.z;
        default:
      }
      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);
    }
  }, {
    key: 'equals3D',
    value: function equals3D(other) {
      return this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z)) && Double.isNaN(other.z);
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      if (!(other instanceof Coordinate)) {
        return false;
      }
      return this.equals2D(other);
    }
  }, {
    key: 'equalInZ',
    value: function equalInZ(c, tolerance) {
      return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var other = o;
      if (this.x < other.x) return -1;
      if (this.x > other.x) return 1;
      if (this.y < other.y) return -1;
      if (this.y > other.y) return 1;
      return 0;
    }
  }, {
    key: 'clone',
    value: function clone() {
      // try {
      //   var coord = null
      //   return coord
      // } catch (e) {
      //   if (e instanceof CloneNotSupportedException) {
      //     Assert.shouldNeverReachHere("this shouldn't happen because this class is Cloneable")
      //     return null
      //   } else throw e
      // } finally {}
    }
  }, {
    key: 'copy',
    value: function copy() {
      return new Coordinate(this);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
    }
  }, {
    key: 'distance3D',
    value: function distance3D(c) {
      var dx = this.x - c.x;
      var dy = this.y - c.y;
      var dz = this.z - c.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
  }, {
    key: 'distance',
    value: function distance(c) {
      var dx = this.x - c.x;
      var dy = this.y - c.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }, {
    key: 'hashCode',
    value: function hashCode() {
      var result = 17;
      result = 37 * result + Coordinate.hashCode(this.x);
      result = 37 * result + Coordinate.hashCode(this.y);
      return result;
    }
  }, {
    key: 'setCoordinate',
    value: function setCoordinate(other) {
      this.x = other.x;
      this.y = other.y;
      this.z = other.z;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable, Clonable, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Coordinate;
    }
  }], [{
    key: 'hashCode',
    value: function hashCode() {
      if (arguments.length === 1) {
        var x = arguments[0];
        var f = Double.doubleToLongBits(x);
        return Math.trunc((f ^ f) >>> 32);
      }
    }
  }, {
    key: 'DimensionalComparator',
    get: function get$$1() {
      return DimensionalComparator;
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return 6683108902428366910;
    }
  }, {
    key: 'NULL_ORDINATE',
    get: function get$$1() {
      return Double.NaN;
    }
  }, {
    key: 'X',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'Y',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'Z',
    get: function get$$1() {
      return 2;
    }
  }]);
  return Coordinate;
}();

var DimensionalComparator = function () {
  function DimensionalComparator(dimensionsToTest) {
    classCallCheck(this, DimensionalComparator);

    this._dimensionsToTest = 2;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      var _dimensionsToTest = arguments[0];
      if (_dimensionsToTest !== 2 && _dimensionsToTest !== 3) throw new IllegalArgumentException('only 2 or 3 dimensions may be specified');
      this._dimensionsToTest = _dimensionsToTest;
    }
  }

  createClass(DimensionalComparator, [{
    key: 'compare',
    value: function compare(o1, o2) {
      var c1 = o1;
      var c2 = o2;
      var compX = DimensionalComparator.compare(c1.x, c2.x);
      if (compX !== 0) return compX;
      var compY = DimensionalComparator.compare(c1.y, c2.y);
      if (compY !== 0) return compY;
      if (this._dimensionsToTest <= 2) return 0;
      var compZ = DimensionalComparator.compare(c1.z, c2.z);
      return compZ;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparator];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DimensionalComparator;
    }
  }], [{
    key: 'compare',
    value: function compare(a, b) {
      if (a < b) return -1;
      if (a > b) return 1;
      if (Double.isNaN(a)) {
        if (Double.isNaN(b)) return 0;
        return -1;
      }
      if (Double.isNaN(b)) return 1;
      return 0;
    }
  }]);
  return DimensionalComparator;
}();

// import hasInterface from '../../../../hasInterface'
// import CoordinateSequence from './CoordinateSequence'

var CoordinateSequenceFactory = function () {
  function CoordinateSequenceFactory() {
    classCallCheck(this, CoordinateSequenceFactory);
  }

  createClass(CoordinateSequenceFactory, [{
    key: "create",
    value: function create() {
      // if (arguments.length === 1) {
      //   if (arguments[0] instanceof Array) {
      //     let coordinates = arguments[0]
      //   } else if (hasInterface(arguments[0], CoordinateSequence)) {
      //     let coordSeq = arguments[0]
      //   }
      // } else if (arguments.length === 2) {
      //   let size = arguments[0]
      //   let dimension = arguments[1]
      // }
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return CoordinateSequenceFactory;
    }
  }]);
  return CoordinateSequenceFactory;
}();

var Location = function () {
  function Location() {
    classCallCheck(this, Location);
  }

  createClass(Location, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Location;
    }
  }], [{
    key: 'toLocationSymbol',
    value: function toLocationSymbol(locationValue) {
      switch (locationValue) {
        case Location.EXTERIOR:
          return 'e';
        case Location.BOUNDARY:
          return 'b';
        case Location.INTERIOR:
          return 'i';
        case Location.NONE:
          return '-';
        default:
      }
      throw new IllegalArgumentException('Unknown location value: ' + locationValue);
    }
  }, {
    key: 'INTERIOR',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'BOUNDARY',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'EXTERIOR',
    get: function get$$1() {
      return 2;
    }
  }, {
    key: 'NONE',
    get: function get$$1() {
      return -1;
    }
  }]);
  return Location;
}();

var hasInterface = function (o, i) {
  return o.interfaces_ && o.interfaces_().indexOf(i) > -1;
};

var MathUtil = function () {
  function MathUtil() {
    classCallCheck(this, MathUtil);
  }

  createClass(MathUtil, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MathUtil;
    }
  }], [{
    key: 'log10',
    value: function log10(x) {
      var ln = Math.log(x);
      if (Double.isInfinite(ln)) return ln;
      if (Double.isNaN(ln)) return ln;
      return ln / MathUtil.LOG_10;
    }
  }, {
    key: 'min',
    value: function min(v1, v2, v3, v4) {
      var min = v1;
      if (v2 < min) min = v2;
      if (v3 < min) min = v3;
      if (v4 < min) min = v4;
      return min;
    }
  }, {
    key: 'clamp',
    value: function clamp() {
      if (typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
        var x = arguments[0];
        var min = arguments[1];
        var max = arguments[2];
        if (x < min) return min;
        if (x > max) return max;
        return x;
      } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
        var _x = arguments[0];
        var _min = arguments[1];
        var _max = arguments[2];
        if (_x < _min) return _min;
        if (_x > _max) return _max;
        return _x;
      }
    }
  }, {
    key: 'wrap',
    value: function wrap(index, max) {
      if (index < 0) {
        return max - -index % max;
      }
      return index % max;
    }
  }, {
    key: 'max',
    value: function max() {
      if (arguments.length === 3) {
        var v1 = arguments[0];
        var v2 = arguments[1];
        var v3 = arguments[2];
        var max = v1;
        if (v2 > max) max = v2;
        if (v3 > max) max = v3;
        return max;
      } else if (arguments.length === 4) {
        var _v = arguments[0];
        var _v2 = arguments[1];
        var _v3 = arguments[2];
        var v4 = arguments[3];
        var _max2 = _v;
        if (_v2 > _max2) _max2 = _v2;
        if (_v3 > _max2) _max2 = _v3;
        if (v4 > _max2) _max2 = v4;
        return _max2;
      }
    }
  }, {
    key: 'average',
    value: function average(x1, x2) {
      return (x1 + x2) / 2.0;
    }
  }, {
    key: 'LOG_10',
    get: function get$$1() {
      return Math.log(10);
    }
  }]);
  return MathUtil;
}();

var StringBuffer = function () {
  function StringBuffer(str) {
    classCallCheck(this, StringBuffer);

    this.str = str;
  }

  createClass(StringBuffer, [{
    key: "append",
    value: function append(e) {
      this.str += e;
    }
  }, {
    key: "setCharAt",
    value: function setCharAt(i, c) {
      this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
    }
  }, {
    key: "toString",
    value: function toString(e) {
      return this.str;
    }
  }]);
  return StringBuffer;
}();

var Integer = function () {
  function Integer(value) {
    classCallCheck(this, Integer);

    this.value = value;
  }

  createClass(Integer, [{
    key: "intValue",
    value: function intValue() {
      return this.value;
    }
  }, {
    key: "compareTo",
    value: function compareTo(o) {
      if (this.value < o) return -1;
      if (this.value > o) return 1;
      return 0;
    }
  }], [{
    key: "isNaN",
    value: function isNaN(n) {
      return Number.isNaN(n);
    }
  }]);
  return Integer;
}();

var Character = function () {
  function Character() {
    classCallCheck(this, Character);
  }

  createClass(Character, null, [{
    key: "isWhitespace",
    value: function isWhitespace(c) {
      return c <= 32 && c >= 0 || c === 127;
    }
  }, {
    key: "toUpperCase",
    value: function toUpperCase(c) {
      return c.toUpperCase();
    }
  }]);
  return Character;
}();

var DD = function () {
  function DD() {
    classCallCheck(this, DD);

    this._hi = 0.0;
    this._lo = 0.0;
    if (arguments.length === 0) {
      this.init(0.0);
    } else if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        var x = arguments[0];
        this.init(x);
      } else if (arguments[0] instanceof DD) {
        var dd = arguments[0];
        this.init(dd);
      } else if (typeof arguments[0] === 'string') {
        var str = arguments[0];
        DD.call(this, DD.parse(str));
      }
    } else if (arguments.length === 2) {
      var hi = arguments[0];
      var lo = arguments[1];
      this.init(hi, lo);
    }
  }

  createClass(DD, [{
    key: 'le',
    value: function le(y) {
      return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo;
    }
  }, {
    key: 'extractSignificantDigits',
    value: function extractSignificantDigits(insertDecimalPoint, magnitude) {
      var y = this.abs();
      var mag = DD.magnitude(y._hi);
      var scale = DD.TEN.pow(mag);
      y = y.divide(scale);
      if (y.gt(DD.TEN)) {
        y = y.divide(DD.TEN);
        mag += 1;
      } else if (y.lt(DD.ONE)) {
        y = y.multiply(DD.TEN);
        mag -= 1;
      }
      var decimalPointPos = mag + 1;
      var buf = new StringBuffer();
      var numDigits = DD.MAX_PRINT_DIGITS - 1;
      for (var i = 0; i <= numDigits; i++) {
        if (insertDecimalPoint && i === decimalPointPos) {
          buf.append('.');
        }
        var digit = Math.trunc(y._hi);
        if (digit < 0) {
          break;
        }
        var rebiasBy10 = false;
        var digitChar = 0;
        if (digit > 9) {
          rebiasBy10 = true;
          digitChar = '9';
        } else {
          digitChar = '0' + digit;
        }
        buf.append(digitChar);
        y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
        if (rebiasBy10) y.selfAdd(DD.TEN);
        var continueExtractingDigits = true;
        var remMag = DD.magnitude(y._hi);
        if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;
        if (!continueExtractingDigits) break;
      }
      magnitude[0] = mag;
      return buf.toString();
    }
  }, {
    key: 'sqr',
    value: function sqr() {
      return this.multiply(this);
    }
  }, {
    key: 'doubleValue',
    value: function doubleValue() {
      return this._hi + this._lo;
    }
  }, {
    key: 'subtract',
    value: function subtract() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        return this.add(y.negate());
      } else if (typeof arguments[0] === 'number') {
        var _y = arguments[0];
        return this.add(-_y);
      }
    }
  }, {
    key: 'equals',
    value: function equals() {
      if (arguments.length === 1) {
        var y = arguments[0];
        return this._hi === y._hi && this._lo === y._lo;
      }
    }
  }, {
    key: 'isZero',
    value: function isZero() {
      return this._hi === 0.0 && this._lo === 0.0;
    }
  }, {
    key: 'selfSubtract',
    value: function selfSubtract() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        if (this.isNaN()) return this;
        return this.selfAdd(-y._hi, -y._lo);
      } else if (typeof arguments[0] === 'number') {
        var _y2 = arguments[0];
        if (this.isNaN()) return this;
        return this.selfAdd(-_y2, 0.0);
      }
    }
  }, {
    key: 'getSpecialNumberString',
    value: function getSpecialNumberString() {
      if (this.isZero()) return '0.0';
      if (this.isNaN()) return 'NaN ';
      return null;
    }
  }, {
    key: 'min',
    value: function min(x) {
      if (this.le(x)) {
        return this;
      } else {
        return x;
      }
    }
  }, {
    key: 'selfDivide',
    value: function selfDivide() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof DD) {
          var y = arguments[0];
          return this.selfDivide(y._hi, y._lo);
        } else if (typeof arguments[0] === 'number') {
          var _y3 = arguments[0];
          return this.selfDivide(_y3, 0.0);
        }
      } else if (arguments.length === 2) {
        var yhi = arguments[0];
        var ylo = arguments[1];
        var hc = null;
        var tc = null;
        var hy = null;
        var ty = null;
        var C = null;
        var c = null;
        var U = null;
        var u = null;
        C = this._hi / yhi;
        c = DD.SPLIT * C;
        hc = c - C;
        u = DD.SPLIT * yhi;
        hc = c - hc;
        tc = C - hc;
        hy = u - yhi;
        U = C * yhi;
        hy = u - hy;
        ty = yhi - hy;
        u = hc * hy - U + hc * ty + tc * hy + tc * ty;
        c = (this._hi - U - u + this._lo - C * ylo) / yhi;
        u = C + c;
        this._hi = u;
        this._lo = C - u + c;
        return this;
      }
    }
  }, {
    key: 'dump',
    value: function dump() {
      return 'DD<' + this._hi + ', ' + this._lo + '>';
    }
  }, {
    key: 'divide',
    value: function divide() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        var hc = null;
        var tc = null;
        var hy = null;
        var ty = null;
        var C = null;
        var c = null;
        var U = null;
        var u = null;
        C = this._hi / y._hi;
        c = DD.SPLIT * C;
        hc = c - C;
        u = DD.SPLIT * y._hi;
        hc = c - hc;
        tc = C - hc;
        hy = u - y._hi;
        U = C * y._hi;
        hy = u - hy;
        ty = y._hi - hy;
        u = hc * hy - U + hc * ty + tc * hy + tc * ty;
        c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
        u = C + c;
        var zhi = u;
        var zlo = C - u + c;
        return new DD(zhi, zlo);
      } else if (typeof arguments[0] === 'number') {
        var _y4 = arguments[0];
        if (Double.isNaN(_y4)) return DD.createNaN();
        return DD.copy(this).selfDivide(_y4, 0.0);
      }
    }
  }, {
    key: 'ge',
    value: function ge(y) {
      return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo;
    }
  }, {
    key: 'pow',
    value: function pow(exp) {
      if (exp === 0.0) return DD.valueOf(1.0);
      var r = new DD(this);
      var s = DD.valueOf(1.0);
      var n = Math.abs(exp);
      if (n > 1) {
        while (n > 0) {
          if (n % 2 === 1) {
            s.selfMultiply(r);
          }
          n /= 2;
          if (n > 0) r = r.sqr();
        }
      } else {
        s = r;
      }
      if (exp < 0) return s.reciprocal();
      return s;
    }
  }, {
    key: 'ceil',
    value: function ceil() {
      if (this.isNaN()) return DD.NaN;
      var fhi = Math.ceil(this._hi);
      var flo = 0.0;
      if (fhi === this._hi) {
        flo = Math.ceil(this._lo);
      }
      return new DD(fhi, flo);
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var other = o;
      if (this._hi < other._hi) return -1;
      if (this._hi > other._hi) return 1;
      if (this._lo < other._lo) return -1;
      if (this._lo > other._lo) return 1;
      return 0;
    }
  }, {
    key: 'rint',
    value: function rint() {
      if (this.isNaN()) return this;
      var plus5 = this.add(0.5);
      return plus5.floor();
    }
  }, {
    key: 'setValue',
    value: function setValue() {
      if (arguments[0] instanceof DD) {
        var value = arguments[0];
        this.init(value);
        return this;
      } else if (typeof arguments[0] === 'number') {
        var _value = arguments[0];
        this.init(_value);
        return this;
      }
    }
  }, {
    key: 'max',
    value: function max(x) {
      if (this.ge(x)) {
        return this;
      } else {
        return x;
      }
    }
  }, {
    key: 'sqrt',
    value: function sqrt() {
      if (this.isZero()) return DD.valueOf(0.0);
      if (this.isNegative()) {
        return DD.NaN;
      }
      var x = 1.0 / Math.sqrt(this._hi);
      var ax = this._hi * x;
      var axdd = DD.valueOf(ax);
      var diffSq = this.subtract(axdd.sqr());
      var d2 = diffSq._hi * (x * 0.5);
      return axdd.add(d2);
    }
  }, {
    key: 'selfAdd',
    value: function selfAdd() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof DD) {
          var y = arguments[0];
          return this.selfAdd(y._hi, y._lo);
        } else if (typeof arguments[0] === 'number') {
          var _y5 = arguments[0];
          var H = null;
          var h = null;
          var S = null;
          var s = null;
          var e = null;
          var f = null;
          S = this._hi + _y5;
          e = S - this._hi;
          s = S - e;
          s = _y5 - e + (this._hi - s);
          f = s + this._lo;
          H = S + f;
          h = f + (S - H);
          this._hi = H + h;
          this._lo = h + (H - this._hi);
          return this;
        }
      } else if (arguments.length === 2) {
        var yhi = arguments[0];
        var ylo = arguments[1];
        var _H = null;
        var _h = null;
        var T = null;
        var t = null;
        var _S = null;
        var _s = null;
        var _e = null;
        var _f = null;
        _S = this._hi + yhi;
        T = this._lo + ylo;
        _e = _S - this._hi;
        _f = T - this._lo;
        _s = _S - _e;
        t = T - _f;
        _s = yhi - _e + (this._hi - _s);
        t = ylo - _f + (this._lo - t);
        _e = _s + T;
        _H = _S + _e;
        _h = _e + (_S - _H);
        _e = t + _h;
        var zhi = _H + _e;
        var zlo = _e + (_H - zhi);
        this._hi = zhi;
        this._lo = zlo;
        return this;
      }
    }
  }, {
    key: 'selfMultiply',
    value: function selfMultiply() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof DD) {
          var y = arguments[0];
          return this.selfMultiply(y._hi, y._lo);
        } else if (typeof arguments[0] === 'number') {
          var _y6 = arguments[0];
          return this.selfMultiply(_y6, 0.0);
        }
      } else if (arguments.length === 2) {
        var yhi = arguments[0];
        var ylo = arguments[1];
        var hx = null;
        var tx = null;
        var hy = null;
        var ty = null;
        var C = null;
        var c = null;
        C = DD.SPLIT * this._hi;
        hx = C - this._hi;
        c = DD.SPLIT * yhi;
        hx = C - hx;
        tx = this._hi - hx;
        hy = c - yhi;
        C = this._hi * yhi;
        hy = c - hy;
        ty = yhi - hy;
        c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
        var zhi = C + c;
        hx = C - zhi;
        var zlo = c + hx;
        this._hi = zhi;
        this._lo = zlo;
        return this;
      }
    }
  }, {
    key: 'selfSqr',
    value: function selfSqr() {
      return this.selfMultiply(this);
    }
  }, {
    key: 'floor',
    value: function floor() {
      if (this.isNaN()) return DD.NaN;
      var fhi = Math.floor(this._hi);
      var flo = 0.0;
      if (fhi === this._hi) {
        flo = Math.floor(this._lo);
      }
      return new DD(fhi, flo);
    }
  }, {
    key: 'negate',
    value: function negate() {
      if (this.isNaN()) return this;
      return new DD(-this._hi, -this._lo);
    }
  }, {
    key: 'clone',
    value: function clone() {
      // try {
      //   return null
      // } catch (ex) {
      //   if (ex instanceof CloneNotSupportedException) {
      //     return null
      //   } else throw ex
      // } finally {}
    }
  }, {
    key: 'multiply',
    value: function multiply() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        if (y.isNaN()) return DD.createNaN();
        return DD.copy(this).selfMultiply(y);
      } else if (typeof arguments[0] === 'number') {
        var _y7 = arguments[0];
        if (Double.isNaN(_y7)) return DD.createNaN();
        return DD.copy(this).selfMultiply(_y7, 0.0);
      }
    }
  }, {
    key: 'isNaN',
    value: function isNaN() {
      return Double.isNaN(this._hi);
    }
  }, {
    key: 'intValue',
    value: function intValue() {
      return Math.trunc(this._hi);
    }
  }, {
    key: 'toString',
    value: function toString() {
      var mag = DD.magnitude(this._hi);
      if (mag >= -3 && mag <= 20) return this.toStandardNotation();
      return this.toSciNotation();
    }
  }, {
    key: 'toStandardNotation',
    value: function toStandardNotation() {
      var specialStr = this.getSpecialNumberString();
      if (specialStr !== null) return specialStr;
      var magnitude = new Array(1).fill(null);
      var sigDigits = this.extractSignificantDigits(true, magnitude);
      var decimalPointPos = magnitude[0] + 1;
      var num = sigDigits;
      if (sigDigits.charAt(0) === '.') {
        num = '0' + sigDigits;
      } else if (decimalPointPos < 0) {
        num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
      } else if (sigDigits.indexOf('.') === -1) {
        var numZeroes = decimalPointPos - sigDigits.length;
        var zeroes = DD.stringOfChar('0', numZeroes);
        num = sigDigits + zeroes + '.0';
      }
      if (this.isNegative()) return '-' + num;
      return num;
    }
  }, {
    key: 'reciprocal',
    value: function reciprocal() {
      var hc = null;
      var tc = null;
      var hy = null;
      var ty = null;
      var C = null;
      var c = null;
      var U = null;
      var u = null;
      C = 1.0 / this._hi;
      c = DD.SPLIT * C;
      hc = c - C;
      u = DD.SPLIT * this._hi;
      hc = c - hc;
      tc = C - hc;
      hy = u - this._hi;
      U = C * this._hi;
      hy = u - hy;
      ty = this._hi - hy;
      u = hc * hy - U + hc * ty + tc * hy + tc * ty;
      c = (1.0 - U - u - C * this._lo) / this._hi;
      var zhi = C + c;
      var zlo = C - zhi + c;
      return new DD(zhi, zlo);
    }
  }, {
    key: 'toSciNotation',
    value: function toSciNotation() {
      if (this.isZero()) return DD.SCI_NOT_ZERO;
      var specialStr = this.getSpecialNumberString();
      if (specialStr !== null) return specialStr;
      var magnitude = new Array(1).fill(null);
      var digits = this.extractSignificantDigits(false, magnitude);
      var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
      if (digits.charAt(0) === '0') {
        throw new Error('Found leading zero: ' + digits);
      }
      var trailingDigits = '';
      if (digits.length > 1) trailingDigits = digits.substring(1);
      var digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;
      if (this.isNegative()) return '-' + digitsWithDecimal + expStr;
      return digitsWithDecimal + expStr;
    }
  }, {
    key: 'abs',
    value: function abs() {
      if (this.isNaN()) return DD.NaN;
      if (this.isNegative()) return this.negate();
      return new DD(this);
    }
  }, {
    key: 'isPositive',
    value: function isPositive() {
      return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0;
    }
  }, {
    key: 'lt',
    value: function lt(y) {
      return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo;
    }
  }, {
    key: 'add',
    value: function add() {
      if (arguments[0] instanceof DD) {
        var y = arguments[0];
        return DD.copy(this).selfAdd(y);
      } else if (typeof arguments[0] === 'number') {
        var _y8 = arguments[0];
        return DD.copy(this).selfAdd(_y8);
      }
    }
  }, {
    key: 'init',
    value: function init() {
      if (arguments.length === 1) {
        if (typeof arguments[0] === 'number') {
          var x = arguments[0];
          this._hi = x;
          this._lo = 0.0;
        } else if (arguments[0] instanceof DD) {
          var dd = arguments[0];
          this._hi = dd._hi;
          this._lo = dd._lo;
        }
      } else if (arguments.length === 2) {
        var hi = arguments[0];
        var lo = arguments[1];
        this._hi = hi;
        this._lo = lo;
      }
    }
  }, {
    key: 'gt',
    value: function gt(y) {
      return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo;
    }
  }, {
    key: 'isNegative',
    value: function isNegative() {
      return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0;
    }
  }, {
    key: 'trunc',
    value: function trunc() {
      if (this.isNaN()) return DD.NaN;
      if (this.isPositive()) return this.floor();else return this.ceil();
    }
  }, {
    key: 'signum',
    value: function signum() {
      if (this._hi > 0) return 1;
      if (this._hi < 0) return -1;
      if (this._lo > 0) return 1;
      if (this._lo < 0) return -1;
      return 0;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Serializable, Comparable, Clonable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DD;
    }
  }], [{
    key: 'sqr',
    value: function sqr(x) {
      return DD.valueOf(x).selfMultiply(x);
    }
  }, {
    key: 'valueOf',
    value: function valueOf() {
      if (typeof arguments[0] === 'string') {
        var str = arguments[0];
        return DD.parse(str);
      } else if (typeof arguments[0] === 'number') {
        var x = arguments[0];
        return new DD(x);
      }
    }
  }, {
    key: 'sqrt',
    value: function sqrt(x) {
      return DD.valueOf(x).sqrt();
    }
  }, {
    key: 'parse',
    value: function parse(str) {
      var i = 0;
      var strlen = str.length;
      while (Character.isWhitespace(str.charAt(i))) {
        i++;
      }var isNegative = false;
      if (i < strlen) {
        var signCh = str.charAt(i);
        if (signCh === '-' || signCh === '+') {
          i++;
          if (signCh === '-') isNegative = true;
        }
      }
      var val = new DD();
      var numDigits = 0;
      var numBeforeDec = 0;
      var exp = 0;
      while (true) {
        if (i >= strlen) break;
        var ch = str.charAt(i);
        i++;
        if (Character.isDigit(ch)) {
          var d = ch - '0';
          val.selfMultiply(DD.TEN);
          val.selfAdd(d);
          numDigits++;
          continue;
        }
        if (ch === '.') {
          numBeforeDec = numDigits;
          continue;
        }
        if (ch === 'e' || ch === 'E') {
          var expStr = str.substring(i);
          try {
            exp = Integer.parseInt(expStr);
          } catch (ex) {
            if (ex instanceof Error) {
              throw new Error('Invalid exponent ' + expStr + ' in string ' + str);
            } else throw ex;
          } finally {}
          break;
        }
        throw new Error("Unexpected character '" + ch + "' at position " + i + ' in string ' + str);
      }
      var val2 = val;
      var numDecPlaces = numDigits - numBeforeDec - exp;
      if (numDecPlaces === 0) {
        val2 = val;
      } else if (numDecPlaces > 0) {
        var scale = DD.TEN.pow(numDecPlaces);
        val2 = val.divide(scale);
      } else if (numDecPlaces < 0) {
        var _scale = DD.TEN.pow(-numDecPlaces);
        val2 = val.multiply(_scale);
      }
      if (isNegative) {
        return val2.negate();
      }
      return val2;
    }
  }, {
    key: 'createNaN',
    value: function createNaN() {
      return new DD(Double.NaN, Double.NaN);
    }
  }, {
    key: 'copy',
    value: function copy(dd) {
      return new DD(dd);
    }
  }, {
    key: 'magnitude',
    value: function magnitude(x) {
      var xAbs = Math.abs(x);
      var xLog10 = Math.log(xAbs) / Math.log(10);
      var xMag = Math.trunc(Math.floor(xLog10));
      var xApprox = Math.pow(10, xMag);
      if (xApprox * 10 <= xAbs) xMag += 1;
      return xMag;
    }
  }, {
    key: 'stringOfChar',
    value: function stringOfChar(ch, len) {
      var buf = new StringBuffer();
      for (var i = 0; i < len; i++) {
        buf.append(ch);
      }
      return buf.toString();
    }
  }, {
    key: 'PI',
    get: function get$$1() {
      return new DD(3.141592653589793116e+00, 1.224646799147353207e-16);
    }
  }, {
    key: 'TWO_PI',
    get: function get$$1() {
      return new DD(6.283185307179586232e+00, 2.449293598294706414e-16);
    }
  }, {
    key: 'PI_2',
    get: function get$$1() {
      return new DD(1.570796326794896558e+00, 6.123233995736766036e-17);
    }
  }, {
    key: 'E',
    get: function get$$1() {
      return new DD(2.718281828459045091e+00, 1.445646891729250158e-16);
    }
  }, {
    key: 'NaN',
    get: function get$$1() {
      return new DD(Double.NaN, Double.NaN);
    }
  }, {
    key: 'EPS',
    get: function get$$1() {
      return 1.23259516440783e-32;
    }
  }, {
    key: 'SPLIT',
    get: function get$$1() {
      return 134217729.0;
    }
  }, {
    key: 'MAX_PRINT_DIGITS',
    get: function get$$1() {
      return 32;
    }
  }, {
    key: 'TEN',
    get: function get$$1() {
      return DD.valueOf(10.0);
    }
  }, {
    key: 'ONE',
    get: function get$$1() {
      return DD.valueOf(1.0);
    }
  }, {
    key: 'SCI_NOT_EXPONENT_CHAR',
    get: function get$$1() {
      return 'E';
    }
  }, {
    key: 'SCI_NOT_ZERO',
    get: function get$$1() {
      return '0.0E0';
    }
  }]);
  return DD;
}();

var CGAlgorithmsDD = function () {
  function CGAlgorithmsDD() {
    classCallCheck(this, CGAlgorithmsDD);
  }

  createClass(CGAlgorithmsDD, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CGAlgorithmsDD;
    }
  }], [{
    key: 'orientationIndex',
    value: function orientationIndex(p1, p2, q) {
      var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
      if (index <= 1) return index;
      var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
      var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
      var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
      var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
      return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
    }
  }, {
    key: 'signOfDet2x2',
    value: function signOfDet2x2(x1, y1, x2, y2) {
      var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
      return det.signum();
    }
  }, {
    key: 'intersection',
    value: function intersection(p1, p2, q1, q2) {
      var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
      var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
      var denom = denom1.subtract(denom2);
      var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
      var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
      var numx = numx1.subtract(numx2);
      var fracP = numx.selfDivide(denom).doubleValue();
      var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
      var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
      var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
      var numy = numy1.subtract(numy2);
      var fracQ = numy.selfDivide(denom).doubleValue();
      var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
      return new Coordinate(x, y);
    }
  }, {
    key: 'orientationIndexFilter',
    value: function orientationIndexFilter(pa, pb, pc) {
      var detsum = null;
      var detleft = (pa.x - pc.x) * (pb.y - pc.y);
      var detright = (pa.y - pc.y) * (pb.x - pc.x);
      var det = detleft - detright;
      if (detleft > 0.0) {
        if (detright <= 0.0) {
          return CGAlgorithmsDD.signum(det);
        } else {
          detsum = detleft + detright;
        }
      } else if (detleft < 0.0) {
        if (detright >= 0.0) {
          return CGAlgorithmsDD.signum(det);
        } else {
          detsum = -detleft - detright;
        }
      } else {
        return CGAlgorithmsDD.signum(det);
      }
      var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
      if (det >= errbound || -det >= errbound) {
        return CGAlgorithmsDD.signum(det);
      }
      return 2;
    }
  }, {
    key: 'signum',
    value: function signum(x) {
      if (x > 0) return 1;
      if (x < 0) return -1;
      return 0;
    }
  }, {
    key: 'DP_SAFE_EPSILON',
    get: function get$$1() {
      return 1e-15;
    }
  }]);
  return CGAlgorithmsDD;
}();

var CoordinateSequence = function () {
  function CoordinateSequence() {
    classCallCheck(this, CoordinateSequence);
  }

  createClass(CoordinateSequence, [{
    key: 'setOrdinate',
    value: function setOrdinate(index, ordinateIndex, value) {}
  }, {
    key: 'size',
    value: function size() {}
  }, {
    key: 'getOrdinate',
    value: function getOrdinate(index, ordinateIndex) {}
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {}
  }, {
    key: 'getCoordinateCopy',
    value: function getCoordinateCopy(i) {}
  }, {
    key: 'getDimension',
    value: function getDimension() {}
  }, {
    key: 'getX',
    value: function getX(index) {}
  }, {
    key: 'clone',
    value: function clone() {}
  }, {
    key: 'expandEnvelope',
    value: function expandEnvelope(env) {}
  }, {
    key: 'copy',
    value: function copy() {}
  }, {
    key: 'getY',
    value: function getY(index) {}
  }, {
    key: 'toCoordinateArray',
    value: function toCoordinateArray() {}
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Clonable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateSequence;
    }
  }], [{
    key: 'X',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'Y',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'Z',
    get: function get$$1() {
      return 2;
    }
  }, {
    key: 'M',
    get: function get$$1() {
      return 3;
    }
  }]);
  return CoordinateSequence;
}();

var Exception = function Exception() {
  classCallCheck(this, Exception);
};

var NotRepresentableException = function (_Exception) {
  inherits(NotRepresentableException, _Exception);

  function NotRepresentableException() {
    classCallCheck(this, NotRepresentableException);
    return possibleConstructorReturn(this, (NotRepresentableException.__proto__ || Object.getPrototypeOf(NotRepresentableException)).call(this, 'Projective point not representable on the Cartesian plane.'));
  }

  createClass(NotRepresentableException, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NotRepresentableException;
    }
  }]);
  return NotRepresentableException;
}(Exception);

var System = function () {
  function System() {
    classCallCheck(this, System);
  }

  createClass(System, null, [{
    key: 'arraycopy',
    value: function arraycopy(src, srcPos, dest, destPos, len) {
      var c = 0;
      for (var i = srcPos; i < srcPos + len; i++) {
        dest[destPos + c] = src[i];
        c++;
      }
    }
  }, {
    key: 'getProperty',
    value: function getProperty(name) {
      return {
        'line.separator': '\n'
      }[name];
    }
  }]);
  return System;
}();

var HCoordinate = function () {
  function HCoordinate() {
    classCallCheck(this, HCoordinate);

    this.x = null;
    this.y = null;
    this.w = null;
    if (arguments.length === 0) {
      this.x = 0.0;
      this.y = 0.0;
      this.w = 1.0;
    } else if (arguments.length === 1) {
      var p = arguments[0];
      this.x = p.x;
      this.y = p.y;
      this.w = 1.0;
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
        var _x = arguments[0];
        var _y = arguments[1];
        this.x = _x;
        this.y = _y;
        this.w = 1.0;
      } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
        var p1 = arguments[0];
        var p2 = arguments[1];
        this.x = p1.y * p2.w - p2.y * p1.w;
        this.y = p2.x * p1.w - p1.x * p2.w;
        this.w = p1.x * p2.y - p2.x * p1.y;
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
        var _p = arguments[0];
        var _p2 = arguments[1];
        this.x = _p.y - _p2.y;
        this.y = _p2.x - _p.x;
        this.w = _p.x * _p2.y - _p2.x * _p.y;
      }
    } else if (arguments.length === 3) {
      var _x2 = arguments[0];
      var _y2 = arguments[1];
      var _w = arguments[2];
      this.x = _x2;
      this.y = _y2;
      this.w = _w;
    } else if (arguments.length === 4) {
      var _p3 = arguments[0];
      var _p4 = arguments[1];
      var q1 = arguments[2];
      var q2 = arguments[3];
      var px = _p3.y - _p4.y;
      var py = _p4.x - _p3.x;
      var pw = _p3.x * _p4.y - _p4.x * _p3.y;
      var qx = q1.y - q2.y;
      var qy = q2.x - q1.x;
      var qw = q1.x * q2.y - q2.x * q1.y;
      this.x = py * qw - qy * pw;
      this.y = qx * pw - px * qw;
      this.w = px * qy - qx * py;
    }
  }

  createClass(HCoordinate, [{
    key: 'getY',
    value: function getY() {
      var a = this.y / this.w;
      if (Double.isNaN(a) || Double.isInfinite(a)) {
        throw new NotRepresentableException();
      }
      return a;
    }
  }, {
    key: 'getX',
    value: function getX() {
      var a = this.x / this.w;
      if (Double.isNaN(a) || Double.isInfinite(a)) {
        throw new NotRepresentableException();
      }
      return a;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      var p = new Coordinate();
      p.x = this.getX();
      p.y = this.getY();
      return p;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return HCoordinate;
    }
  }], [{
    key: 'intersection',
    value: function intersection(p1, p2, q1, q2) {
      var px = p1.y - p2.y;
      var py = p2.x - p1.x;
      var pw = p1.x * p2.y - p2.x * p1.y;
      var qx = q1.y - q2.y;
      var qy = q2.x - q1.x;
      var qw = q1.x * q2.y - q2.x * q1.y;
      var x = py * qw - qy * pw;
      var y = qx * pw - px * qw;
      var w = px * qy - qx * py;
      var xInt = x / w;
      var yInt = y / w;
      if (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) {
        throw new NotRepresentableException();
      }
      return new Coordinate(xInt, yInt);
    }
  }]);
  return HCoordinate;
}();

var Envelope = function () {
  function Envelope() {
    classCallCheck(this, Envelope);

    this._minx = null;
    this._maxx = null;
    this._miny = null;
    this._maxy = null;
    if (arguments.length === 0) {
      this.init();
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Coordinate) {
        var p = arguments[0];
        this.init(p.x, p.x, p.y, p.y);
      } else if (arguments[0] instanceof Envelope) {
        var env = arguments[0];
        this.init(env);
      }
    } else if (arguments.length === 2) {
      var p1 = arguments[0];
      var p2 = arguments[1];
      this.init(p1.x, p2.x, p1.y, p2.y);
    } else if (arguments.length === 4) {
      var x1 = arguments[0];
      var x2 = arguments[1];
      var y1 = arguments[2];
      var y2 = arguments[3];
      this.init(x1, x2, y1, y2);
    }
  }

  createClass(Envelope, [{
    key: 'getArea',
    value: function getArea() {
      return this.getWidth() * this.getHeight();
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      if (!(other instanceof Envelope)) {
        return false;
      }
      var otherEnvelope = other;
      if (this.isNull()) {
        return otherEnvelope.isNull();
      }
      return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
    }
  }, {
    key: 'intersection',
    value: function intersection(env) {
      if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();
      var intMinX = this._minx > env._minx ? this._minx : env._minx;
      var intMinY = this._miny > env._miny ? this._miny : env._miny;
      var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
      var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
      return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
    }
  }, {
    key: 'isNull',
    value: function isNull() {
      return this._maxx < this._minx;
    }
  }, {
    key: 'getMaxX',
    value: function getMaxX() {
      return this._maxx;
    }
  }, {
    key: 'covers',
    value: function covers() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          return this.covers(p.x, p.y);
        } else if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          if (this.isNull() || other.isNull()) {
            return false;
          }
          return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        if (this.isNull()) return false;
        return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;
      }
    }
  }, {
    key: 'intersects',
    value: function intersects() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          if (this.isNull() || other.isNull()) {
            return false;
          }
          return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
        } else if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          return this.intersects(p.x, p.y);
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        if (this.isNull()) return false;
        return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);
      }
    }
  }, {
    key: 'getMinY',
    value: function getMinY() {
      return this._miny;
    }
  }, {
    key: 'getMinX',
    value: function getMinX() {
      return this._minx;
    }
  }, {
    key: 'expandToInclude',
    value: function expandToInclude() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          this.expandToInclude(p.x, p.y);
        } else if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          if (other.isNull()) {
            return null;
          }
          if (this.isNull()) {
            this._minx = other.getMinX();
            this._maxx = other.getMaxX();
            this._miny = other.getMinY();
            this._maxy = other.getMaxY();
          } else {
            if (other._minx < this._minx) {
              this._minx = other._minx;
            }
            if (other._maxx > this._maxx) {
              this._maxx = other._maxx;
            }
            if (other._miny < this._miny) {
              this._miny = other._miny;
            }
            if (other._maxy > this._maxy) {
              this._maxy = other._maxy;
            }
          }
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        if (this.isNull()) {
          this._minx = x;
          this._maxx = x;
          this._miny = y;
          this._maxy = y;
        } else {
          if (x < this._minx) {
            this._minx = x;
          }
          if (x > this._maxx) {
            this._maxx = x;
          }
          if (y < this._miny) {
            this._miny = y;
          }
          if (y > this._maxy) {
            this._maxy = y;
          }
        }
      }
    }
  }, {
    key: 'minExtent',
    value: function minExtent() {
      if (this.isNull()) return 0.0;
      var w = this.getWidth();
      var h = this.getHeight();
      if (w < h) return w;
      return h;
    }
  }, {
    key: 'getWidth',
    value: function getWidth() {
      if (this.isNull()) {
        return 0;
      }
      return this._maxx - this._minx;
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var env = o;
      if (this.isNull()) {
        if (env.isNull()) return 0;
        return -1;
      } else {
        if (env.isNull()) return 1;
      }
      if (this._minx < env._minx) return -1;
      if (this._minx > env._minx) return 1;
      if (this._miny < env._miny) return -1;
      if (this._miny > env._miny) return 1;
      if (this._maxx < env._maxx) return -1;
      if (this._maxx > env._maxx) return 1;
      if (this._maxy < env._maxy) return -1;
      if (this._maxy > env._maxy) return 1;
      return 0;
    }
  }, {
    key: 'translate',
    value: function translate(transX, transY) {
      if (this.isNull()) {
        return null;
      }
      this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']';
    }
  }, {
    key: 'setToNull',
    value: function setToNull() {
      this._minx = 0;
      this._maxx = -1;
      this._miny = 0;
      this._maxy = -1;
    }
  }, {
    key: 'getHeight',
    value: function getHeight() {
      if (this.isNull()) {
        return 0;
      }
      return this._maxy - this._miny;
    }
  }, {
    key: 'maxExtent',
    value: function maxExtent() {
      if (this.isNull()) return 0.0;
      var w = this.getWidth();
      var h = this.getHeight();
      if (w > h) return w;
      return h;
    }
  }, {
    key: 'expandBy',
    value: function expandBy() {
      if (arguments.length === 1) {
        var distance = arguments[0];
        this.expandBy(distance, distance);
      } else if (arguments.length === 2) {
        var deltaX = arguments[0];
        var deltaY = arguments[1];
        if (this.isNull()) return null;
        this._minx -= deltaX;
        this._maxx += deltaX;
        this._miny -= deltaY;
        this._maxy += deltaY;
        if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();
      }
    }
  }, {
    key: 'contains',
    value: function contains() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Envelope) {
          var other = arguments[0];
          return this.covers(other);
        } else if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          return this.covers(p);
        }
      } else if (arguments.length === 2) {
        var x = arguments[0];
        var y = arguments[1];
        return this.covers(x, y);
      }
    }
  }, {
    key: 'centre',
    value: function centre() {
      if (this.isNull()) return null;
      return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);
    }
  }, {
    key: 'init',
    value: function init() {
      if (arguments.length === 0) {
        this.setToNull();
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var p = arguments[0];
          this.init(p.x, p.x, p.y, p.y);
        } else if (arguments[0] instanceof Envelope) {
          var env = arguments[0];
          this._minx = env._minx;
          this._maxx = env._maxx;
          this._miny = env._miny;
          this._maxy = env._maxy;
        }
      } else if (arguments.length === 2) {
        var p1 = arguments[0];
        var p2 = arguments[1];
        this.init(p1.x, p2.x, p1.y, p2.y);
      } else if (arguments.length === 4) {
        var x1 = arguments[0];
        var x2 = arguments[1];
        var y1 = arguments[2];
        var y2 = arguments[3];
        if (x1 < x2) {
          this._minx = x1;
          this._maxx = x2;
        } else {
          this._minx = x2;
          this._maxx = x1;
        }
        if (y1 < y2) {
          this._miny = y1;
          this._maxy = y2;
        } else {
          this._miny = y2;
          this._maxy = y1;
        }
      }
    }
  }, {
    key: 'getMaxY',
    value: function getMaxY() {
      return this._maxy;
    }
  }, {
    key: 'distance',
    value: function distance(env) {
      if (this.intersects(env)) return 0;
      var dx = 0.0;
      if (this._maxx < env._minx) dx = env._minx - this._maxx;else if (this._minx > env._maxx) dx = this._minx - env._maxx;
      var dy = 0.0;
      if (this._maxy < env._miny) dy = env._miny - this._maxy;else if (this._miny > env._maxy) dy = this._miny - env._maxy;
      if (dx === 0.0) return dy;
      if (dy === 0.0) return dx;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }, {
    key: 'hashCode',
    value: function hashCode() {
      var result = 17;
      result = 37 * result + Coordinate.hashCode(this._minx);
      result = 37 * result + Coordinate.hashCode(this._maxx);
      result = 37 * result + Coordinate.hashCode(this._miny);
      result = 37 * result + Coordinate.hashCode(this._maxy);
      return result;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Envelope;
    }
  }], [{
    key: 'intersects',
    value: function intersects() {
      if (arguments.length === 3) {
        var p1 = arguments[0];
        var p2 = arguments[1];
        var q = arguments[2];
        if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) {
          return true;
        }
        return false;
      } else if (arguments.length === 4) {
        var _p = arguments[0];
        var _p2 = arguments[1];
        var q1 = arguments[2];
        var q2 = arguments[3];
        var minq = Math.min(q1.x, q2.x);
        var maxq = Math.max(q1.x, q2.x);
        var minp = Math.min(_p.x, _p2.x);
        var maxp = Math.max(_p.x, _p2.x);
        if (minp > maxq) return false;
        if (maxp < minq) return false;
        minq = Math.min(q1.y, q2.y);
        maxq = Math.max(q1.y, q2.y);
        minp = Math.min(_p.y, _p2.y);
        maxp = Math.max(_p.y, _p2.y);
        if (minp > maxq) return false;
        if (maxp < minq) return false;
        return true;
      }
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return 5873921885273102420;
    }
  }]);
  return Envelope;
}();

var regExes = {
  'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  'emptyTypeStr': /^\s*(\w+)\s*EMPTY\s*$/,
  'spaces': /\s+/,
  'parenComma': /\)\s*,\s*\(/,
  'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
  'trimParens': /^\s*\(?(.*?)\)?\s*$/

  /**
   * Class for reading and writing Well-Known Text.
   *
   * NOTE: Adapted from OpenLayers 2.11 implementation.
   */

  /** Create a new parser for WKT
   *
   * @param {GeometryFactory} geometryFactory
   * @return An instance of WKTParser.
   * @constructor
   * @private
   */
};
var WKTParser = function () {
  function WKTParser(geometryFactory) {
    classCallCheck(this, WKTParser);

    this.geometryFactory = geometryFactory || new GeometryFactory();
  }
  /**
   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
   * and GEOMETRYCOLLECTION.
   *
   * @param {String} wkt A WKT string.
   * @return {Geometry} A geometry instance.
   * @private
   */


  createClass(WKTParser, [{
    key: 'read',
    value: function read(wkt) {
      var geometry, type, str;
      wkt = wkt.replace(/[\n\r]/g, ' ');
      var matches = regExes.typeStr.exec(wkt);
      if (wkt.search('EMPTY') !== -1) {
        matches = regExes.emptyTypeStr.exec(wkt);
        matches[2] = undefined;
      }
      if (matches) {
        type = matches[1].toLowerCase();
        str = matches[2];
        if (parse$1[type]) {
          geometry = parse$1[type].apply(this, [str]);
        }
      }

      if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt);

      return geometry;
    }

    /**
     * Serialize a geometry into a WKT string.
     *
     * @param {Geometry} geometry A feature or array of features.
     * @return {String} The WKT string representation of the input geometries.
     * @private
     */

  }, {
    key: 'write',
    value: function write(geometry) {
      return this.extractGeometry(geometry);
    }

    /**
     * Entry point to construct the WKT for a single Geometry object.
     *
     * @param {Geometry} geometry
     * @return {String} A WKT string of representing the geometry.
     * @private
     */

  }, {
    key: 'extractGeometry',
    value: function extractGeometry(geometry) {
      var type = geometry.getGeometryType().toLowerCase();
      if (!extract$1[type]) {
        return null;
      }
      var wktType = type.toUpperCase();
      var data;
      if (geometry.isEmpty()) {
        data = wktType + ' EMPTY';
      } else {
        data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';
      }
      return data;
    }
  }]);
  return WKTParser;
}();

var extract$1 = {
  coordinate: function coordinate(_coordinate) {
    return _coordinate.x + ' ' + _coordinate.y;
  },


  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point: function point(_point) {
    return extract$1.coordinate.call(this, _point._coordinates._coordinates[0]);
  },


  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint: function multipoint(_multipoint) {
    var array = [];
    for (var i = 0, len = _multipoint._geometries.length; i < len; ++i) {
      array.push('(' + extract$1.point.apply(this, [_multipoint._geometries[i]]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring: function linestring(_linestring) {
    var array = [];
    for (var i = 0, len = _linestring._points._coordinates.length; i < len; ++i) {
      array.push(extract$1.coordinate.apply(this, [_linestring._points._coordinates[i]]));
    }
    return array.join(',');
  },
  linearring: function linearring(_linearring) {
    var array = [];
    for (var i = 0, len = _linearring._points._coordinates.length; i < len; ++i) {
      array.push(extract$1.coordinate.apply(this, [_linearring._points._coordinates[i]]));
    }
    return array.join(',');
  },


  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring: function multilinestring(_multilinestring) {
    var array = [];
    for (var i = 0, len = _multilinestring._geometries.length; i < len; ++i) {
      array.push('(' + extract$1.linestring.apply(this, [_multilinestring._geometries[i]]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon: function polygon(_polygon) {
    var array = [];
    array.push('(' + extract$1.linestring.apply(this, [_polygon._shell]) + ')');
    for (var i = 0, len = _polygon._holes.length; i < len; ++i) {
      array.push('(' + extract$1.linestring.apply(this, [_polygon._holes[i]]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon: function multipolygon(_multipolygon) {
    var array = [];
    for (var i = 0, len = _multipolygon._geometries.length; i < len; ++i) {
      array.push('(' + extract$1.polygon.apply(this, [_multipolygon._geometries[i]]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection: function geometrycollection(collection) {
    var array = [];
    for (var i = 0, len = collection._geometries.length; i < len; ++i) {
      array.push(this.extractGeometry(collection._geometries[i]));
    }
    return array.join(',');
  }
};

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual parsing.
 * @private
 */
var parse$1 = {
  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point: function point(str) {
    if (str === undefined) {
      return this.geometryFactory.createPoint();
    }

    var coords = str.trim().split(regExes.spaces);
    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
  },


  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint: function multipoint(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPoint();
    }

    var point;
    var points = str.trim().split(',');
    var components = [];
    for (var i = 0, len = points.length; i < len; ++i) {
      point = points[i].replace(regExes.trimParens, '$1');
      components.push(parse$1.point.apply(this, [point]));
    }
    return this.geometryFactory.createMultiPoint(components);
  },


  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring: function linestring(str) {
    if (str === undefined) {
      return this.geometryFactory.createLineString();
    }

    var points = str.trim().split(',');
    var components = [];
    var coords;
    for (var i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLineString(components);
  },


  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring: function linearring(str) {
    if (str === undefined) {
      return this.geometryFactory.createLinearRing();
    }

    var points = str.trim().split(',');
    var components = [];
    var coords;
    for (var i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(regExes.spaces);
      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));
    }
    return this.geometryFactory.createLinearRing(components);
  },


  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring: function multilinestring(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiLineString();
    }

    var line;
    var lines = str.trim().split(regExes.parenComma);
    var components = [];
    for (var i = 0, len = lines.length; i < len; ++i) {
      line = lines[i].replace(regExes.trimParens, '$1');
      components.push(parse$1.linestring.apply(this, [line]));
    }
    return this.geometryFactory.createMultiLineString(components);
  },


  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon: function polygon(str) {
    if (str === undefined) {
      return this.geometryFactory.createPolygon();
    }

    var ring, linestring, linearring;
    var rings = str.trim().split(regExes.parenComma);
    var shell;
    var holes = [];
    for (var i = 0, len = rings.length; i < len; ++i) {
      ring = rings[i].replace(regExes.trimParens, '$1');
      linestring = parse$1.linestring.apply(this, [ring]);
      linearring = this.geometryFactory.createLinearRing(linestring._points);
      if (i === 0) {
        shell = linearring;
      } else {
        holes.push(linearring);
      }
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },


  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon: function multipolygon(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPolygon();
    }

    var polygon;
    var polygons = str.trim().split(regExes.doubleParenComma);
    var components = [];
    for (var i = 0, len = polygons.length; i < len; ++i) {
      polygon = polygons[i].replace(regExes.trimParens, '$1');
      components.push(parse$1.polygon.apply(this, [polygon]));
    }
    return this.geometryFactory.createMultiPolygon(components);
  },


  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection: function geometrycollection(str) {
    if (str === undefined) {
      return this.geometryFactory.createGeometryCollection();
    }

    // separate components of the collection with |
    str = str.replace(/,\s*([A-Za-z])/g, '|$1');
    var wktArray = str.trim().split('|');
    var components = [];
    for (var i = 0, len = wktArray.length; i < len; ++i) {
      components.push(this.read(wktArray[i]));
    }
    return this.geometryFactory.createGeometryCollection(components);
  }
};

/**
 * Writes the Well-Known Text representation of a {@link Geometry}. The
 * Well-Known Text format is defined in the <A
 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
 * Specification for SQL</A>.
 * <p>
 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 * <p>
 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
 * Under the spec, rings are output as <code>LINESTRING</code>s.
 */

/**
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */

var WKTWriter = function () {
  function WKTWriter(geometryFactory) {
    classCallCheck(this, WKTWriter);

    this.parser = new WKTParser(geometryFactory);
  }

  /**
   * Converts a <code>Geometry</code> to its Well-known Text representation.
   *
   * @param {Geometry} geometry a <code>Geometry</code> to process.
   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
   *         Features Specification).
   * @memberof WKTWriter
   */


  createClass(WKTWriter, [{
    key: 'write',
    value: function write(geometry) {
      return this.parser.write(geometry);
    }
    /**
     * Generates the WKT for a <tt>LINESTRING</tt> specified by two
     * {@link Coordinate}s.
     *
     * @param p0 the first coordinate.
     * @param p1 the second coordinate.
     *
     * @return the WKT.
     * @private
     */

  }], [{
    key: 'toLineString',
    value: function toLineString(p0, p1) {
      if (arguments.length !== 2) {
        throw new Error('Not implemented');
      }
      return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';
    }
  }]);
  return WKTWriter;
}();

var RuntimeException = function (_Error) {
  inherits(RuntimeException, _Error);

  function RuntimeException(message) {
    classCallCheck(this, RuntimeException);

    var _this = possibleConstructorReturn(this, (RuntimeException.__proto__ || Object.getPrototypeOf(RuntimeException)).call(this, message));

    _this.name = 'RuntimeException';
    _this.message = message;
    _this.stack = new Error().stack;
    return _this;
  }

  return RuntimeException;
}(Error);

var AssertionFailedException = function (_RuntimeException) {
  inherits(AssertionFailedException, _RuntimeException);

  function AssertionFailedException() {
    classCallCheck(this, AssertionFailedException);

    var _this = possibleConstructorReturn(this, (AssertionFailedException.__proto__ || Object.getPrototypeOf(AssertionFailedException)).call(this));

    if (arguments.length === 0) {
      RuntimeException.call(_this);
    } else if (arguments.length === 1) {
      var message = arguments[0];
      RuntimeException.call(_this, message);
    }
    return _this;
  }

  createClass(AssertionFailedException, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return AssertionFailedException;
    }
  }]);
  return AssertionFailedException;
}(RuntimeException);

var Assert = function () {
  function Assert() {
    classCallCheck(this, Assert);
  }

  createClass(Assert, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Assert;
    }
  }], [{
    key: 'shouldNeverReachHere',
    value: function shouldNeverReachHere() {
      if (arguments.length === 0) {
        Assert.shouldNeverReachHere(null);
      } else if (arguments.length === 1) {
        var message = arguments[0];
        throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''));
      }
    }
  }, {
    key: 'isTrue',
    value: function isTrue() {
      var assertion = void 0;
      var message = void 0;
      if (arguments.length === 1) {
        assertion = arguments[0];
        Assert.isTrue(assertion, null);
      } else if (arguments.length === 2) {
        assertion = arguments[0];
        message = arguments[1];
        if (!assertion) {
          if (message === null) {
            throw new AssertionFailedException();
          } else {
            throw new AssertionFailedException(message);
          }
        }
      }
    }
  }, {
    key: 'equals',
    value: function equals() {
      var expectedValue = void 0;
      var actualValue = void 0;
      var message = void 0;
      if (arguments.length === 2) {
        expectedValue = arguments[0];
        actualValue = arguments[1];
        Assert.equals(expectedValue, actualValue, null);
      } else if (arguments.length === 3) {
        expectedValue = arguments[0];
        actualValue = arguments[1];
        message = arguments[2];
        if (!actualValue.equals(expectedValue)) {
          throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''));
        }
      }
    }
  }]);
  return Assert;
}();

var LineIntersector = function () {
  function LineIntersector() {
    classCallCheck(this, LineIntersector);

    this._result = null;
    this._inputLines = Array(2).fill().map(function () {
      return Array(2);
    });
    this._intPt = new Array(2).fill(null);
    this._intLineIndex = null;
    this._isProper = null;
    this._pa = null;
    this._pb = null;
    this._precisionModel = null;
    this._intPt[0] = new Coordinate();
    this._intPt[1] = new Coordinate();
    this._pa = this._intPt[0];
    this._pb = this._intPt[1];
    this._result = 0;
  }

  createClass(LineIntersector, [{
    key: 'getIndexAlongSegment',
    value: function getIndexAlongSegment(segmentIndex, intIndex) {
      this.computeIntLineIndex();
      return this._intLineIndex[segmentIndex][intIndex];
    }
  }, {
    key: 'getTopologySummary',
    value: function getTopologySummary() {
      var catBuf = new StringBuffer();
      if (this.isEndPoint()) catBuf.append(' endpoint');
      if (this._isProper) catBuf.append(' proper');
      if (this.isCollinear()) catBuf.append(' collinear');
      return catBuf.toString();
    }
  }, {
    key: 'computeIntersection',
    value: function computeIntersection(p1, p2, p3, p4) {
      this._inputLines[0][0] = p1;
      this._inputLines[0][1] = p2;
      this._inputLines[1][0] = p3;
      this._inputLines[1][1] = p4;
      this._result = this.computeIntersect(p1, p2, p3, p4);
    }
  }, {
    key: 'getIntersectionNum',
    value: function getIntersectionNum() {
      return this._result;
    }
  }, {
    key: 'computeIntLineIndex',
    value: function computeIntLineIndex() {
      if (arguments.length === 0) {
        if (this._intLineIndex === null) {
          this._intLineIndex = Array(2).fill().map(function () {
            return Array(2);
          });
          this.computeIntLineIndex(0);
          this.computeIntLineIndex(1);
        }
      } else if (arguments.length === 1) {
        var segmentIndex = arguments[0];
        var dist0 = this.getEdgeDistance(segmentIndex, 0);
        var dist1 = this.getEdgeDistance(segmentIndex, 1);
        if (dist0 > dist1) {
          this._intLineIndex[segmentIndex][0] = 0;
          this._intLineIndex[segmentIndex][1] = 1;
        } else {
          this._intLineIndex[segmentIndex][0] = 1;
          this._intLineIndex[segmentIndex][1] = 0;
        }
      }
    }
  }, {
    key: 'isProper',
    value: function isProper() {
      return this.hasIntersection() && this._isProper;
    }
  }, {
    key: 'setPrecisionModel',
    value: function setPrecisionModel(precisionModel) {
      this._precisionModel = precisionModel;
    }
  }, {
    key: 'isInteriorIntersection',
    value: function isInteriorIntersection() {
      if (arguments.length === 0) {
        if (this.isInteriorIntersection(0)) return true;
        if (this.isInteriorIntersection(1)) return true;
        return false;
      } else if (arguments.length === 1) {
        var inputLineIndex = arguments[0];
        for (var i = 0; i < this._result; i++) {
          if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {
            return true;
          }
        }
        return false;
      }
    }
  }, {
    key: 'getIntersection',
    value: function getIntersection(intIndex) {
      return this._intPt[intIndex];
    }
  }, {
    key: 'isEndPoint',
    value: function isEndPoint() {
      return this.hasIntersection() && !this._isProper;
    }
  }, {
    key: 'hasIntersection',
    value: function hasIntersection() {
      return this._result !== LineIntersector.NO_INTERSECTION;
    }
  }, {
    key: 'getEdgeDistance',
    value: function getEdgeDistance(segmentIndex, intIndex) {
      var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
      return dist;
    }
  }, {
    key: 'isCollinear',
    value: function isCollinear() {
      return this._result === LineIntersector.COLLINEAR_INTERSECTION;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
    }
  }, {
    key: 'getEndpoint',
    value: function getEndpoint(segmentIndex, ptIndex) {
      return this._inputLines[segmentIndex][ptIndex];
    }
  }, {
    key: 'isIntersection',
    value: function isIntersection(pt) {
      for (var i = 0; i < this._result; i++) {
        if (this._intPt[i].equals2D(pt)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'getIntersectionAlongSegment',
    value: function getIntersectionAlongSegment(segmentIndex, intIndex) {
      this.computeIntLineIndex();
      return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return LineIntersector;
    }
  }], [{
    key: 'computeEdgeDistance',
    value: function computeEdgeDistance(p, p0, p1) {
      var dx = Math.abs(p1.x - p0.x);
      var dy = Math.abs(p1.y - p0.y);
      var dist = -1.0;
      if (p.equals(p0)) {
        dist = 0.0;
      } else if (p.equals(p1)) {
        if (dx > dy) dist = dx;else dist = dy;
      } else {
        var pdx = Math.abs(p.x - p0.x);
        var pdy = Math.abs(p.y - p0.y);
        if (dx > dy) dist = pdx;else dist = pdy;
        if (dist === 0.0 && !p.equals(p0)) {
          dist = Math.max(pdx, pdy);
        }
      }
      Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');
      return dist;
    }
  }, {
    key: 'nonRobustComputeEdgeDistance',
    value: function nonRobustComputeEdgeDistance(p, p1, p2) {
      var dx = p.x - p1.x;
      var dy = p.y - p1.y;
      var dist = Math.sqrt(dx * dx + dy * dy);
      Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');
      return dist;
    }
  }, {
    key: 'DONT_INTERSECT',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'DO_INTERSECT',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'COLLINEAR',
    get: function get$$1() {
      return 2;
    }
  }, {
    key: 'NO_INTERSECTION',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'POINT_INTERSECTION',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'COLLINEAR_INTERSECTION',
    get: function get$$1() {
      return 2;
    }
  }]);
  return LineIntersector;
}();

var RobustLineIntersector = function (_LineIntersector) {
  inherits(RobustLineIntersector, _LineIntersector);

  function RobustLineIntersector() {
    classCallCheck(this, RobustLineIntersector);
    return possibleConstructorReturn(this, (RobustLineIntersector.__proto__ || Object.getPrototypeOf(RobustLineIntersector)).apply(this, arguments));
  }

  createClass(RobustLineIntersector, [{
    key: 'isInSegmentEnvelopes',
    value: function isInSegmentEnvelopes(intPt) {
      var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
      var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
      return env0.contains(intPt) && env1.contains(intPt);
    }
  }, {
    key: 'computeIntersection',
    value: function computeIntersection() {
      if (arguments.length === 3) {
        var p = arguments[0];
        var p1 = arguments[1];
        var p2 = arguments[2];
        this._isProper = false;
        if (Envelope.intersects(p1, p2, p)) {
          if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {
            this._isProper = true;
            if (p.equals(p1) || p.equals(p2)) {
              this._isProper = false;
            }
            this._result = LineIntersector.POINT_INTERSECTION;
            return null;
          }
        }
        this._result = LineIntersector.NO_INTERSECTION;
      } else return LineIntersector.prototype.computeIntersection.apply(this, arguments);
    }
  }, {
    key: 'normalizeToMinimum',
    value: function normalizeToMinimum(n1, n2, n3, n4, normPt) {
      normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
      normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
      n1.x -= normPt.x;
      n1.y -= normPt.y;
      n2.x -= normPt.x;
      n2.y -= normPt.y;
      n3.x -= normPt.x;
      n3.y -= normPt.y;
      n4.x -= normPt.x;
      n4.y -= normPt.y;
    }
  }, {
    key: 'safeHCoordinateIntersection',
    value: function safeHCoordinateIntersection(p1, p2, q1, q2) {
      var intPt = null;
      try {
        intPt = HCoordinate.intersection(p1, p2, q1, q2);
      } catch (e) {
        if (e instanceof NotRepresentableException) {
          intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
        } else throw e;
      } finally {}
      return intPt;
    }
  }, {
    key: 'intersection',
    value: function intersection(p1, p2, q1, q2) {
      var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
      if (!this.isInSegmentEnvelopes(intPt)) {
        intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
      }
      if (this._precisionModel !== null) {
        this._precisionModel.makePrecise(intPt);
      }
      return intPt;
    }
  }, {
    key: 'smallestInAbsValue',
    value: function smallestInAbsValue(x1, x2, x3, x4) {
      var x = x1;
      var xabs = Math.abs(x);
      if (Math.abs(x2) < xabs) {
        x = x2;
        xabs = Math.abs(x2);
      }
      if (Math.abs(x3) < xabs) {
        x = x3;
        xabs = Math.abs(x3);
      }
      if (Math.abs(x4) < xabs) {
        x = x4;
      }
      return x;
    }
  }, {
    key: 'checkDD',
    value: function checkDD(p1, p2, q1, q2, intPt) {
      var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
      var isIn = this.isInSegmentEnvelopes(intPtDD);
      System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);
      if (intPt.distance(intPtDD) > 0.0001) {
        System.out.println('Distance = ' + intPt.distance(intPtDD));
      }
    }
  }, {
    key: 'intersectionWithNormalization',
    value: function intersectionWithNormalization(p1, p2, q1, q2) {
      var n1 = new Coordinate(p1);
      var n2 = new Coordinate(p2);
      var n3 = new Coordinate(q1);
      var n4 = new Coordinate(q2);
      var normPt = new Coordinate();
      this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
      var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
      intPt.x += normPt.x;
      intPt.y += normPt.y;
      return intPt;
    }
  }, {
    key: 'computeCollinearIntersection',
    value: function computeCollinearIntersection(p1, p2, q1, q2) {
      var p1q1p2 = Envelope.intersects(p1, p2, q1);
      var p1q2p2 = Envelope.intersects(p1, p2, q2);
      var q1p1q2 = Envelope.intersects(q1, q2, p1);
      var q1p2q2 = Envelope.intersects(q1, q2, p2);
      if (p1q1p2 && p1q2p2) {
        this._intPt[0] = q1;
        this._intPt[1] = q2;
        return LineIntersector.COLLINEAR_INTERSECTION;
      }
      if (q1p1q2 && q1p2q2) {
        this._intPt[0] = p1;
        this._intPt[1] = p2;
        return LineIntersector.COLLINEAR_INTERSECTION;
      }
      if (p1q1p2 && q1p1q2) {
        this._intPt[0] = q1;
        this._intPt[1] = p1;
        return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
      }
      if (p1q1p2 && q1p2q2) {
        this._intPt[0] = q1;
        this._intPt[1] = p2;
        return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
      }
      if (p1q2p2 && q1p1q2) {
        this._intPt[0] = q2;
        this._intPt[1] = p1;
        return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
      }
      if (p1q2p2 && q1p2q2) {
        this._intPt[0] = q2;
        this._intPt[1] = p2;
        return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
      }
      return LineIntersector.NO_INTERSECTION;
    }
  }, {
    key: 'normalizeToEnvCentre',
    value: function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {
      var minX0 = n00.x < n01.x ? n00.x : n01.x;
      var minY0 = n00.y < n01.y ? n00.y : n01.y;
      var maxX0 = n00.x > n01.x ? n00.x : n01.x;
      var maxY0 = n00.y > n01.y ? n00.y : n01.y;
      var minX1 = n10.x < n11.x ? n10.x : n11.x;
      var minY1 = n10.y < n11.y ? n10.y : n11.y;
      var maxX1 = n10.x > n11.x ? n10.x : n11.x;
      var maxY1 = n10.y > n11.y ? n10.y : n11.y;
      var intMinX = minX0 > minX1 ? minX0 : minX1;
      var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
      var intMinY = minY0 > minY1 ? minY0 : minY1;
      var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
      var intMidX = (intMinX + intMaxX) / 2.0;
      var intMidY = (intMinY + intMaxY) / 2.0;
      normPt.x = intMidX;
      normPt.y = intMidY;
      n00.x -= normPt.x;
      n00.y -= normPt.y;
      n01.x -= normPt.x;
      n01.y -= normPt.y;
      n10.x -= normPt.x;
      n10.y -= normPt.y;
      n11.x -= normPt.x;
      n11.y -= normPt.y;
    }
  }, {
    key: 'computeIntersect',
    value: function computeIntersect(p1, p2, q1, q2) {
      this._isProper = false;
      if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;
      var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
      var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);
      if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {
        return LineIntersector.NO_INTERSECTION;
      }
      var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
      var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);
      if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {
        return LineIntersector.NO_INTERSECTION;
      }
      var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
      if (collinear) {
        return this.computeCollinearIntersection(p1, p2, q1, q2);
      }
      if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
        this._isProper = false;
        if (p1.equals2D(q1) || p1.equals2D(q2)) {
          this._intPt[0] = p1;
        } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
          this._intPt[0] = p2;
        } else if (Pq1 === 0) {
          this._intPt[0] = new Coordinate(q1);
        } else if (Pq2 === 0) {
          this._intPt[0] = new Coordinate(q2);
        } else if (Qp1 === 0) {
          this._intPt[0] = new Coordinate(p1);
        } else if (Qp2 === 0) {
          this._intPt[0] = new Coordinate(p2);
        }
      } else {
        this._isProper = true;
        this._intPt[0] = this.intersection(p1, p2, q1, q2);
      }
      return LineIntersector.POINT_INTERSECTION;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return RobustLineIntersector;
    }
  }], [{
    key: 'nearestEndpoint',
    value: function nearestEndpoint(p1, p2, q1, q2) {
      var nearestPt = p1;
      var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);
      var dist = CGAlgorithms.distancePointLine(p2, q1, q2);
      if (dist < minDist) {
        minDist = dist;
        nearestPt = p2;
      }
      dist = CGAlgorithms.distancePointLine(q1, p1, p2);
      if (dist < minDist) {
        minDist = dist;
        nearestPt = q1;
      }
      dist = CGAlgorithms.distancePointLine(q2, p1, p2);
      if (dist < minDist) {
        minDist = dist;
        nearestPt = q2;
      }
      return nearestPt;
    }
  }]);
  return RobustLineIntersector;
}(LineIntersector);

var RobustDeterminant = function () {
  function RobustDeterminant() {
    classCallCheck(this, RobustDeterminant);
  }

  createClass(RobustDeterminant, [{
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return RobustDeterminant;
    }
  }], [{
    key: "orientationIndex",
    value: function orientationIndex(p1, p2, q) {
      var dx1 = p2.x - p1.x;
      var dy1 = p2.y - p1.y;
      var dx2 = q.x - p2.x;
      var dy2 = q.y - p2.y;
      return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
    }
  }, {
    key: "signOfDet2x2",
    value: function signOfDet2x2(x1, y1, x2, y2) {
      var sign = null;
      var swap = null;
      var k = null;
      sign = 1;
      if (x1 === 0.0 || y2 === 0.0) {
        if (y1 === 0.0 || x2 === 0.0) {
          return 0;
        } else if (y1 > 0) {
          if (x2 > 0) {
            return -sign;
          } else {
            return sign;
          }
        } else {
          if (x2 > 0) {
            return sign;
          } else {
            return -sign;
          }
        }
      }
      if (y1 === 0.0 || x2 === 0.0) {
        if (y2 > 0) {
          if (x1 > 0) {
            return sign;
          } else {
            return -sign;
          }
        } else {
          if (x1 > 0) {
            return -sign;
          } else {
            return sign;
          }
        }
      }
      if (y1 > 0.0) {
        if (y2 > 0.0) {
          if (y1 <= y2) {
            
          } else {
            sign = -sign;
            swap = x1;
            x1 = x2;
            x2 = swap;
            swap = y1;
            y1 = y2;
            y2 = swap;
          }
        } else {
          if (y1 <= -y2) {
            sign = -sign;
            x2 = -x2;
            y2 = -y2;
          } else {
            swap = x1;
            x1 = -x2;
            x2 = swap;
            swap = y1;
            y1 = -y2;
            y2 = swap;
          }
        }
      } else {
        if (y2 > 0.0) {
          if (-y1 <= y2) {
            sign = -sign;
            x1 = -x1;
            y1 = -y1;
          } else {
            swap = -x1;
            x1 = x2;
            x2 = swap;
            swap = -y1;
            y1 = y2;
            y2 = swap;
          }
        } else {
          if (y1 >= y2) {
            x1 = -x1;
            y1 = -y1;
            x2 = -x2;
            y2 = -y2;
          } else {
            sign = -sign;
            swap = -x1;
            x1 = -x2;
            x2 = swap;
            swap = -y1;
            y1 = -y2;
            y2 = swap;
          }
        }
      }
      if (x1 > 0.0) {
        if (x2 > 0.0) {
          if (x1 <= x2) {
            
          } else {
            return sign;
          }
        } else {
          return sign;
        }
      } else {
        if (x2 > 0.0) {
          return -sign;
        } else {
          if (x1 >= x2) {
            sign = -sign;
            x1 = -x1;
            x2 = -x2;
          } else {
            return -sign;
          }
        }
      }
      while (true) {
        k = Math.floor(x2 / x1);
        x2 = x2 - k * x1;
        y2 = y2 - k * y1;
        if (y2 < 0.0) {
          return -sign;
        }
        if (y2 > y1) {
          return sign;
        }
        if (x1 > x2 + x2) {
          if (y1 < y2 + y2) {
            return sign;
          }
        } else {
          if (y1 > y2 + y2) {
            return -sign;
          } else {
            x2 = x1 - x2;
            y2 = y1 - y2;
            sign = -sign;
          }
        }
        if (y2 === 0.0) {
          if (x2 === 0.0) {
            return 0;
          } else {
            return -sign;
          }
        }
        if (x2 === 0.0) {
          return sign;
        }
        k = Math.floor(x1 / x2);
        x1 = x1 - k * x2;
        y1 = y1 - k * y2;
        if (y1 < 0.0) {
          return sign;
        }
        if (y1 > y2) {
          return -sign;
        }
        if (x2 > x1 + x1) {
          if (y2 < y1 + y1) {
            return -sign;
          }
        } else {
          if (y2 > y1 + y1) {
            return sign;
          } else {
            x1 = x2 - x1;
            y1 = y2 - y1;
            sign = -sign;
          }
        }
        if (y1 === 0.0) {
          if (x1 === 0.0) {
            return 0;
          } else {
            return sign;
          }
        }
        if (x1 === 0.0) {
          return -sign;
        }
      }
    }
  }]);
  return RobustDeterminant;
}();

var RayCrossingCounter = function () {
  function RayCrossingCounter() {
    classCallCheck(this, RayCrossingCounter);

    this._p = null;
    this._crossingCount = 0;
    this._isPointOnSegment = false;
    var p = arguments[0];
    this._p = p;
  }

  createClass(RayCrossingCounter, [{
    key: 'countSegment',
    value: function countSegment(p1, p2) {
      if (p1.x < this._p.x && p2.x < this._p.x) return null;
      if (this._p.x === p2.x && this._p.y === p2.y) {
        this._isPointOnSegment = true;
        return null;
      }
      if (p1.y === this._p.y && p2.y === this._p.y) {
        var minx = p1.x;
        var maxx = p2.x;
        if (minx > maxx) {
          minx = p2.x;
          maxx = p1.x;
        }
        if (this._p.x >= minx && this._p.x <= maxx) {
          this._isPointOnSegment = true;
        }
        return null;
      }
      if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
        var x1 = p1.x - this._p.x;
        var y1 = p1.y - this._p.y;
        var x2 = p2.x - this._p.x;
        var y2 = p2.y - this._p.y;
        var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);
        if (xIntSign === 0.0) {
          this._isPointOnSegment = true;
          return null;
        }
        if (y2 < y1) xIntSign = -xIntSign;
        if (xIntSign > 0.0) {
          this._crossingCount++;
        }
      }
    }
  }, {
    key: 'isPointInPolygon',
    value: function isPointInPolygon() {
      return this.getLocation() !== Location.EXTERIOR;
    }
  }, {
    key: 'getLocation',
    value: function getLocation() {
      if (this._isPointOnSegment) return Location.BOUNDARY;
      if (this._crossingCount % 2 === 1) {
        return Location.INTERIOR;
      }
      return Location.EXTERIOR;
    }
  }, {
    key: 'isOnSegment',
    value: function isOnSegment() {
      return this._isPointOnSegment;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return RayCrossingCounter;
    }
  }], [{
    key: 'locatePointInRing',
    value: function locatePointInRing() {
      if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
        var p = arguments[0];
        var ring = arguments[1];
        var counter = new RayCrossingCounter(p);
        var p1 = new Coordinate();
        var p2 = new Coordinate();
        for (var i = 1; i < ring.size(); i++) {
          ring.getCoordinate(i, p1);
          ring.getCoordinate(i - 1, p2);
          counter.countSegment(p1, p2);
          if (counter.isOnSegment()) return counter.getLocation();
        }
        return counter.getLocation();
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
        var _p = arguments[0];
        var _ring = arguments[1];
        var _counter = new RayCrossingCounter(_p);
        for (var _i = 1; _i < _ring.length; _i++) {
          var _p2 = _ring[_i];
          var _p3 = _ring[_i - 1];
          _counter.countSegment(_p2, _p3);
          if (_counter.isOnSegment()) return _counter.getLocation();
        }
        return _counter.getLocation();
      }
    }
  }]);
  return RayCrossingCounter;
}();

var CGAlgorithms = function () {
  function CGAlgorithms() {
    classCallCheck(this, CGAlgorithms);
  }

  createClass(CGAlgorithms, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CGAlgorithms;
    }
  }], [{
    key: 'orientationIndex',
    value: function orientationIndex(p1, p2, q) {
      return CGAlgorithmsDD.orientationIndex(p1, p2, q);
    }
  }, {
    key: 'signedArea',
    value: function signedArea() {
      if (arguments[0] instanceof Array) {
        var ring = arguments[0];
        if (ring.length < 3) return 0.0;
        var sum = 0.0;
        var x0 = ring[0].x;
        for (var i = 1; i < ring.length - 1; i++) {
          var x = ring[i].x - x0;
          var y1 = ring[i + 1].y;
          var y2 = ring[i - 1].y;
          sum += x * (y2 - y1);
        }
        return sum / 2.0;
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        var _ring = arguments[0];
        var n = _ring.size();
        if (n < 3) return 0.0;
        var p0 = new Coordinate();
        var p1 = new Coordinate();
        var p2 = new Coordinate();
        _ring.getCoordinate(0, p1);
        _ring.getCoordinate(1, p2);
        var _x = p1.x;
        p2.x -= _x;
        var _sum = 0.0;
        for (var _i = 1; _i < n - 1; _i++) {
          p0.y = p1.y;
          p1.x = p2.x;
          p1.y = p2.y;
          _ring.getCoordinate(_i + 1, p2);
          p2.x -= _x;
          _sum += p1.x * (p0.y - p2.y);
        }
        return _sum / 2.0;
      }
    }
  }, {
    key: 'distanceLineLine',
    value: function distanceLineLine(A, B, C, D) {
      if (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);
      if (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);
      var noIntersection = false;
      if (!Envelope.intersects(A, B, C, D)) {
        noIntersection = true;
      } else {
        var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
        if (denom === 0) {
          noIntersection = true;
        } else {
          var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
          var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
          var s = sNum / denom;
          var r = rNumb / denom;
          if (r < 0 || r > 1 || s < 0 || s > 1) {
            noIntersection = true;
          }
        }
      }
      if (noIntersection) {
        return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));
      }
      return 0.0;
    }
  }, {
    key: 'isPointInRing',
    value: function isPointInRing(p, ring) {
      return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;
    }
  }, {
    key: 'computeLength',
    value: function computeLength(pts) {
      var n = pts.size();
      if (n <= 1) return 0.0;
      var len = 0.0;
      var p = new Coordinate();
      pts.getCoordinate(0, p);
      var x0 = p.x;
      var y0 = p.y;
      for (var i = 1; i < n; i++) {
        pts.getCoordinate(i, p);
        var x1 = p.x;
        var y1 = p.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        len += Math.sqrt(dx * dx + dy * dy);
        x0 = x1;
        y0 = y1;
      }
      return len;
    }
  }, {
    key: 'isCCW',
    value: function isCCW(ring) {
      var nPts = ring.length - 1;
      if (nPts < 3) throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined');
      var hiPt = ring[0];
      var hiIndex = 0;
      for (var i = 1; i <= nPts; i++) {
        var p = ring[i];
        if (p.y > hiPt.y) {
          hiPt = p;
          hiIndex = i;
        }
      }
      var iPrev = hiIndex;
      do {
        iPrev = iPrev - 1;
        if (iPrev < 0) iPrev = nPts;
      } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
      var iNext = hiIndex;
      do {
        iNext = (iNext + 1) % nPts;
      } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
      var prev = ring[iPrev];
      var next = ring[iNext];
      if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
      var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);
      var isCCW = false;
      if (disc === 0) {
        isCCW = prev.x > next.x;
      } else {
        isCCW = disc > 0;
      }
      return isCCW;
    }
  }, {
    key: 'locatePointInRing',
    value: function locatePointInRing(p, ring) {
      return RayCrossingCounter.locatePointInRing(p, ring);
    }
  }, {
    key: 'distancePointLinePerpendicular',
    value: function distancePointLinePerpendicular(p, A, B) {
      var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
      var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
      return Math.abs(s) * Math.sqrt(len2);
    }
  }, {
    key: 'computeOrientation',
    value: function computeOrientation(p1, p2, q) {
      return CGAlgorithms.orientationIndex(p1, p2, q);
    }
  }, {
    key: 'distancePointLine',
    value: function distancePointLine() {
      if (arguments.length === 2) {
        var p = arguments[0];
        var line = arguments[1];
        if (line.length === 0) throw new IllegalArgumentException('Line array must contain at least one vertex');
        var minDistance = p.distance(line[0]);
        for (var i = 0; i < line.length - 1; i++) {
          var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
          if (dist < minDistance) {
            minDistance = dist;
          }
        }
        return minDistance;
      } else if (arguments.length === 3) {
        var _p = arguments[0];
        var A = arguments[1];
        var B = arguments[2];
        if (A.x === B.x && A.y === B.y) return _p.distance(A);
        var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
        var r = ((_p.x - A.x) * (B.x - A.x) + (_p.y - A.y) * (B.y - A.y)) / len2;
        if (r <= 0.0) return _p.distance(A);
        if (r >= 1.0) return _p.distance(B);
        var s = ((A.y - _p.y) * (B.x - A.x) - (A.x - _p.x) * (B.y - A.y)) / len2;
        return Math.abs(s) * Math.sqrt(len2);
      }
    }
  }, {
    key: 'isOnLine',
    value: function isOnLine(p, pt) {
      var lineIntersector = new RobustLineIntersector();
      for (var i = 1; i < pt.length; i++) {
        var p0 = pt[i - 1];
        var p1 = pt[i];
        lineIntersector.computeIntersection(p, p0, p1);
        if (lineIntersector.hasIntersection()) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'CLOCKWISE',
    get: function get$$1() {
      return -1;
    }
  }, {
    key: 'RIGHT',
    get: function get$$1() {
      return CGAlgorithms.CLOCKWISE;
    }
  }, {
    key: 'COUNTERCLOCKWISE',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'LEFT',
    get: function get$$1() {
      return CGAlgorithms.COUNTERCLOCKWISE;
    }
  }, {
    key: 'COLLINEAR',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'STRAIGHT',
    get: function get$$1() {
      return CGAlgorithms.COLLINEAR;
    }
  }]);
  return CGAlgorithms;
}();

var GeometryComponentFilter = function () {
  function GeometryComponentFilter() {
    classCallCheck(this, GeometryComponentFilter);
  }

  createClass(GeometryComponentFilter, [{
    key: "filter",
    value: function filter(geom) {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return GeometryComponentFilter;
    }
  }]);
  return GeometryComponentFilter;
}();

var Geometry = function () {
  function Geometry() {
    classCallCheck(this, Geometry);

    var factory = arguments[0];

    this._envelope = null;
    this._factory = null;
    this._SRID = null;
    this._userData = null;
    this._factory = factory;
    this._SRID = factory.getSRID();
  }

  createClass(Geometry, [{
    key: 'isGeometryCollection',
    value: function isGeometryCollection() {
      return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;
    }
  }, {
    key: 'getFactory',
    value: function getFactory() {
      return this._factory;
    }
  }, {
    key: 'getGeometryN',
    value: function getGeometryN(n) {
      return this;
    }
  }, {
    key: 'getArea',
    value: function getArea() {
      return 0.0;
    }
  }, {
    key: 'isRectangle',
    value: function isRectangle() {
      return false;
    }
  }, {
    key: 'equals',
    value: function equals() {
      if (arguments[0] instanceof Geometry) {
        var _g = arguments[0];
        if (_g === null) return false;
        return this.equalsTopo(_g);
      } else if (arguments[0] instanceof Object) {
        var o = arguments[0];
        if (!(o instanceof Geometry)) return false;
        var g = o;
        return this.equalsExact(g);
      }
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact(other) {
      return this === other || this.equalsExact(other, 0);
    }
  }, {
    key: 'geometryChanged',
    value: function geometryChanged() {
      this.apply(Geometry.geometryChangedFilter);
    }
  }, {
    key: 'geometryChangedAction',
    value: function geometryChangedAction() {
      this._envelope = null;
    }
  }, {
    key: 'equalsNorm',
    value: function equalsNorm(g) {
      if (g === null) return false;
      return this.norm().equalsExact(g.norm());
    }
  }, {
    key: 'getLength',
    value: function getLength() {
      return 0.0;
    }
  }, {
    key: 'getNumGeometries',
    value: function getNumGeometries() {
      return 1;
    }
  }, {
    key: 'compareTo',
    value: function compareTo() {
      if (arguments.length === 1) {
        var o = arguments[0];
        var other = o;
        if (this.getSortIndex() !== other.getSortIndex()) {
          return this.getSortIndex() - other.getSortIndex();
        }
        if (this.isEmpty() && other.isEmpty()) {
          return 0;
        }
        if (this.isEmpty()) {
          return -1;
        }
        if (other.isEmpty()) {
          return 1;
        }
        return this.compareToSameClass(o);
      } else if (arguments.length === 2) {
        var _other = arguments[0];
        var comp = arguments[1];
        if (this.getSortIndex() !== _other.getSortIndex()) {
          return this.getSortIndex() - _other.getSortIndex();
        }
        if (this.isEmpty() && _other.isEmpty()) {
          return 0;
        }
        if (this.isEmpty()) {
          return -1;
        }
        if (_other.isEmpty()) {
          return 1;
        }
        return this.compareToSameClass(_other, comp);
      }
    }
  }, {
    key: 'getUserData',
    value: function getUserData() {
      return this._userData;
    }
  }, {
    key: 'getSRID',
    value: function getSRID() {
      return this._SRID;
    }
  }, {
    key: 'getEnvelope',
    value: function getEnvelope() {
      return this.getFactory().toGeometry(this.getEnvelopeInternal());
    }
  }, {
    key: 'checkNotGeometryCollection',
    value: function checkNotGeometryCollection(g) {
      if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {
        throw new IllegalArgumentException('This method does not support GeometryCollection arguments');
      }
    }
  }, {
    key: 'equal',
    value: function equal(a, b, tolerance) {
      if (tolerance === 0) {
        return a.equals(b);
      }
      return a.distance(b) <= tolerance;
    }
  }, {
    key: 'norm',
    value: function norm() {
      var copy = this.copy();
      copy.normalize();
      return copy;
    }
  }, {
    key: 'getPrecisionModel',
    value: function getPrecisionModel() {
      return this._factory.getPrecisionModel();
    }
  }, {
    key: 'getEnvelopeInternal',
    value: function getEnvelopeInternal() {
      if (this._envelope === null) {
        this._envelope = this.computeEnvelopeInternal();
      }
      return new Envelope(this._envelope);
    }
  }, {
    key: 'setSRID',
    value: function setSRID(SRID) {
      this._SRID = SRID;
    }
  }, {
    key: 'setUserData',
    value: function setUserData(userData) {
      this._userData = userData;
    }
  }, {
    key: 'compare',
    value: function compare(a, b) {
      var i = a.iterator();
      var j = b.iterator();
      while (i.hasNext() && j.hasNext()) {
        var aElement = i.next();
        var bElement = j.next();
        var comparison = aElement.compareTo(bElement);
        if (comparison !== 0) {
          return comparison;
        }
      }
      if (i.hasNext()) {
        return 1;
      }
      if (j.hasNext()) {
        return -1;
      }
      return 0;
    }
  }, {
    key: 'hashCode',
    value: function hashCode() {
      return this.getEnvelopeInternal().hashCode();
    }
  }, {
    key: 'isGeometryCollectionOrDerived',
    value: function isGeometryCollectionOrDerived() {
      if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {
        return true;
      }
      return false;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Clonable, Comparable, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Geometry;
    }
  }], [{
    key: 'hasNonEmptyElements',
    value: function hasNonEmptyElements(geometries) {
      for (var i = 0; i < geometries.length; i++) {
        if (!geometries[i].isEmpty()) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'hasNullElements',
    value: function hasNullElements(array) {
      for (var i = 0; i < array.length; i++) {
        if (array[i] === null) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return 8763622679187376702;
    }
  }, {
    key: 'SORTINDEX_POINT',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'SORTINDEX_MULTIPOINT',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'SORTINDEX_LINESTRING',
    get: function get$$1() {
      return 2;
    }
  }, {
    key: 'SORTINDEX_LINEARRING',
    get: function get$$1() {
      return 3;
    }
  }, {
    key: 'SORTINDEX_MULTILINESTRING',
    get: function get$$1() {
      return 4;
    }
  }, {
    key: 'SORTINDEX_POLYGON',
    get: function get$$1() {
      return 5;
    }
  }, {
    key: 'SORTINDEX_MULTIPOLYGON',
    get: function get$$1() {
      return 6;
    }
  }, {
    key: 'SORTINDEX_GEOMETRYCOLLECTION',
    get: function get$$1() {
      return 7;
    }
  }, {
    key: 'geometryChangedFilter',
    get: function get$$1() {
      return geometryChangedFilter;
    }
  }]);
  return Geometry;
}();

var geometryChangedFilter = function () {
  function geometryChangedFilter() {
    classCallCheck(this, geometryChangedFilter);
  }

  createClass(geometryChangedFilter, null, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryComponentFilter];
    }
  }, {
    key: 'filter',
    value: function filter(geom) {
      geom.geometryChangedAction();
    }
  }]);
  return geometryChangedFilter;
}();

var CoordinateFilter = function () {
  function CoordinateFilter() {
    classCallCheck(this, CoordinateFilter);
  }

  createClass(CoordinateFilter, [{
    key: "filter",
    value: function filter(coord) {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return CoordinateFilter;
    }
  }]);
  return CoordinateFilter;
}();

var BoundaryNodeRule = function () {
  function BoundaryNodeRule() {
    classCallCheck(this, BoundaryNodeRule);
  }

  createClass(BoundaryNodeRule, [{
    key: "isInBoundary",
    value: function isInBoundary(boundaryCount) {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return BoundaryNodeRule;
    }
  }], [{
    key: "Mod2BoundaryNodeRule",
    get: function get$$1() {
      return Mod2BoundaryNodeRule;
    }
  }, {
    key: "EndPointBoundaryNodeRule",
    get: function get$$1() {
      return EndPointBoundaryNodeRule;
    }
  }, {
    key: "MultiValentEndPointBoundaryNodeRule",
    get: function get$$1() {
      return MultiValentEndPointBoundaryNodeRule;
    }
  }, {
    key: "MonoValentEndPointBoundaryNodeRule",
    get: function get$$1() {
      return MonoValentEndPointBoundaryNodeRule;
    }
  }, {
    key: "MOD2_BOUNDARY_RULE",
    get: function get$$1() {
      return new Mod2BoundaryNodeRule();
    }
  }, {
    key: "ENDPOINT_BOUNDARY_RULE",
    get: function get$$1() {
      return new EndPointBoundaryNodeRule();
    }
  }, {
    key: "MULTIVALENT_ENDPOINT_BOUNDARY_RULE",
    get: function get$$1() {
      return new MultiValentEndPointBoundaryNodeRule();
    }
  }, {
    key: "MONOVALENT_ENDPOINT_BOUNDARY_RULE",
    get: function get$$1() {
      return new MonoValentEndPointBoundaryNodeRule();
    }
  }, {
    key: "OGC_SFS_BOUNDARY_RULE",
    get: function get$$1() {
      return BoundaryNodeRule.MOD2_BOUNDARY_RULE;
    }
  }]);
  return BoundaryNodeRule;
}();

var Mod2BoundaryNodeRule = function () {
  function Mod2BoundaryNodeRule() {
    classCallCheck(this, Mod2BoundaryNodeRule);
  }

  createClass(Mod2BoundaryNodeRule, [{
    key: "isInBoundary",
    value: function isInBoundary(boundaryCount) {
      return boundaryCount % 2 === 1;
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [BoundaryNodeRule];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return Mod2BoundaryNodeRule;
    }
  }]);
  return Mod2BoundaryNodeRule;
}();

var EndPointBoundaryNodeRule = function () {
  function EndPointBoundaryNodeRule() {
    classCallCheck(this, EndPointBoundaryNodeRule);
  }

  createClass(EndPointBoundaryNodeRule, [{
    key: "isInBoundary",
    value: function isInBoundary(boundaryCount) {
      return boundaryCount > 0;
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [BoundaryNodeRule];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return EndPointBoundaryNodeRule;
    }
  }]);
  return EndPointBoundaryNodeRule;
}();

var MultiValentEndPointBoundaryNodeRule = function () {
  function MultiValentEndPointBoundaryNodeRule() {
    classCallCheck(this, MultiValentEndPointBoundaryNodeRule);
  }

  createClass(MultiValentEndPointBoundaryNodeRule, [{
    key: "isInBoundary",
    value: function isInBoundary(boundaryCount) {
      return boundaryCount > 1;
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [BoundaryNodeRule];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return MultiValentEndPointBoundaryNodeRule;
    }
  }]);
  return MultiValentEndPointBoundaryNodeRule;
}();

var MonoValentEndPointBoundaryNodeRule = function () {
  function MonoValentEndPointBoundaryNodeRule() {
    classCallCheck(this, MonoValentEndPointBoundaryNodeRule);
  }

  createClass(MonoValentEndPointBoundaryNodeRule, [{
    key: "isInBoundary",
    value: function isInBoundary(boundaryCount) {
      return boundaryCount === 1;
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [BoundaryNodeRule];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return MonoValentEndPointBoundaryNodeRule;
    }
  }]);
  return MonoValentEndPointBoundaryNodeRule;
}();

// import Iterator from './Iterator'

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
 *
 * @constructor
 * @private
 */
var Collection = function () {
  function Collection() {
    classCallCheck(this, Collection);
  }

  createClass(Collection, [{
    key: "add",

    /**
     * Ensures that this collection contains the specified element (optional
     * operation).
     * @param {Object} e
     * @return {boolean}
     */
    value: function add() {}

    /**
     * Appends all of the elements in the specified collection to the end of this
     * list, in the order that they are returned by the specified collection's
     * iterator (optional operation).
     * @param {javascript.util.Collection} c
     * @return {boolean}
     */

  }, {
    key: "addAll",
    value: function addAll() {}

    /**
     * Returns true if this collection contains no elements.
     * @return {boolean}
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {}

    /**
     * Returns an iterator over the elements in this collection.
     * @return {javascript.util.Iterator}
     */

  }, {
    key: "iterator",
    value: function iterator() {}

    /**
     * Returns an iterator over the elements in this collection.
     * @return {number}
     */

  }, {
    key: "size",
    value: function size() {}

    /**
     * Returns an array containing all of the elements in this collection.
     * @return {Array}
     */

  }, {
    key: "toArray",
    value: function toArray$$1() {}

    /**
     * Removes a single instance of the specified element from this collection if it
     * is present. (optional)
     * @param {Object} e
     * @return {boolean}
     */

  }, {
    key: "remove",
    value: function remove() {}
  }]);
  return Collection;
}();

/**
 * @param {string} [message] Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
var IndexOutOfBoundsException = function (_Error) {
  inherits(IndexOutOfBoundsException, _Error);

  function IndexOutOfBoundsException(message) {
    classCallCheck(this, IndexOutOfBoundsException);

    var _this = possibleConstructorReturn(this, (IndexOutOfBoundsException.__proto__ || Object.getPrototypeOf(IndexOutOfBoundsException)).call(this));

    _this.message = message || '';
    return _this;
  }

  /**
   * @type {string}
   */


  createClass(IndexOutOfBoundsException, null, [{
    key: 'name',
    get: function get$$1() {
      return 'IndexOutOfBoundsException';
    }
  }]);
  return IndexOutOfBoundsException;
}(Error);

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
 * @constructor
 * @private
 */
var Iterator = function () {
  function Iterator() {
    classCallCheck(this, Iterator);
  }

  createClass(Iterator, [{
    key: "hasNext",

    /**
     * Returns true if the iteration has more elements.
     * @return {boolean}
     */
    value: function hasNext() {}

    /**
     * Returns the next element in the iteration.
     * @return {Object}
     */

  }, {
    key: "next",
    value: function next() {}

    /**
     * Removes from the underlying collection the last element returned by the
     * iterator (optional operation).
     */

  }, {
    key: "remove",
    value: function remove() {}
  }]);
  return Iterator;
}();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html
 *
 * @extends {javascript.util.Collection}
 * @constructor
 * @private
 */

var List = function (_Collection) {
  inherits(List, _Collection);

  function List() {
    classCallCheck(this, List);
    return possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).apply(this, arguments));
  }

  createClass(List, [{
    key: 'get',

    /**
     * Returns the element at the specified position in this list.
     * @param {number} index
     * @return {Object}
     */
    value: function get$$1() {}

    /**
     * Replaces the element at the specified position in this list with the
     * specified element (optional operation).
     * @param {number} index
     * @param {Object} e
     * @return {Object}
     */

  }, {
    key: 'set',
    value: function set$$1() {}

    /**
     * Returns true if this collection contains no elements.
     * @return {boolean}
     */

  }, {
    key: 'isEmpty',
    value: function isEmpty() {}
  }]);
  return List;
}(Collection);

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function NoSuchElementException(message) {
  this.message = message || '';
}
NoSuchElementException.prototype = new Error();

/**
 * @type {string}
 */
NoSuchElementException.prototype.name = 'NoSuchElementException';

// import OperationNotSupported from './OperationNotSupported'

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html
 *
 * @extends List
 * @private
 */

var ArrayList = function (_List) {
  inherits(ArrayList, _List);

  function ArrayList() {
    classCallCheck(this, ArrayList);

    var _this = possibleConstructorReturn(this, (ArrayList.__proto__ || Object.getPrototypeOf(ArrayList)).call(this));

    _this.array_ = [];

    if (arguments[0] instanceof Collection) {
      _this.addAll(arguments[0]);
    }
    return _this;
  }

  createClass(ArrayList, [{
    key: 'ensureCapacity',
    value: function ensureCapacity() {}
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [List, Collection];
    }

    /**
     * @override
     */

  }, {
    key: 'add',
    value: function add(e) {
      if (arguments.length === 1) {
        this.array_.push(e);
      } else {
        this.array_.splice(arguments[0], arguments[1]);
      }
      return true;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.array_ = [];
    }

    /**
     * @override
     */

  }, {
    key: 'addAll',
    value: function addAll(c) {
      for (var i = c.iterator(); i.hasNext();) {
        this.add(i.next());
      }
      return true;
    }

    /**
     * @override
     */

  }, {
    key: 'set',
    value: function set$$1(index, element) {
      var oldElement = this.array_[index];
      this.array_[index] = element;
      return oldElement;
    }

    /**
     * @override
     */

  }, {
    key: 'iterator',
    value: function iterator() {
      return new Iterator_(this);
    }

    /**
     * @override
     */

  }, {
    key: 'get',
    value: function get$$1(index) {
      if (index < 0 || index >= this.size()) {
        throw new IndexOutOfBoundsException();
      }

      return this.array_[index];
    }

    /**
     * @override
     */

  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.array_.length === 0;
    }

    /**
     * @override
     */

  }, {
    key: 'size',
    value: function size() {
      return this.array_.length;
    }

    /**
     * @override
     */

  }, {
    key: 'toArray',
    value: function toArray$$1() {
      var array = [];

      for (var i = 0, len = this.array_.length; i < len; i++) {
        array.push(this.array_[i]);
      }

      return array;
    }

    /**
     * @override
     */

  }, {
    key: 'remove',
    value: function remove(o) {
      var found = false;

      for (var i = 0, len = this.array_.length; i < len; i++) {
        if (this.array_[i] === o) {
          this.array_.splice(i, 1);
          found = true;
          break;
        }
      }

      return found;
    }
  }]);
  return ArrayList;
}(List);

var Iterator_ = function (_Iterator) {
  inherits(Iterator_, _Iterator);

  function Iterator_(arrayList) {
    classCallCheck(this, Iterator_);

    /**
     * @type {ArrayList}
     * @private
    */
    var _this2 = possibleConstructorReturn(this, (Iterator_.__proto__ || Object.getPrototypeOf(Iterator_)).call(this));

    _this2.arrayList_ = arrayList;
    /**
     * @type {number}
     * @private
    */
    _this2.position_ = 0;
    return _this2;
  }

  /**
   * @override
   */


  createClass(Iterator_, [{
    key: 'next',
    value: function next() {
      if (this.position_ === this.arrayList_.size()) {
        throw new NoSuchElementException();
      }
      return this.arrayList_.get(this.position_++);
    }

    /**
     * @override
     */

  }, {
    key: 'hasNext',
    value: function hasNext() {
      if (this.position_ < this.arrayList_.size()) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * TODO: should be in ListIterator
     * @override
     */

  }, {
    key: 'set',
    value: function set$$1(element) {
      return this.arrayList_.set(this.position_ - 1, element);
    }

    /**
     * @override
     */

  }, {
    key: 'remove',
    value: function remove() {
      this.arrayList_.remove(this.arrayList_.get(this.position_));
    }
  }]);
  return Iterator_;
}(Iterator);

var CoordinateList = function (_ArrayList) {
  inherits(CoordinateList, _ArrayList);

  function CoordinateList() {
    classCallCheck(this, CoordinateList);

    var _this = possibleConstructorReturn(this, (CoordinateList.__proto__ || Object.getPrototypeOf(CoordinateList)).call(this));

    if (arguments.length === 0) {} else if (arguments.length === 1) {
      var coord = arguments[0];
      _this.ensureCapacity(coord.length);
      _this.add(coord, true);
    } else if (arguments.length === 2) {
      var _coord = arguments[0];
      var allowRepeated = arguments[1];
      _this.ensureCapacity(_coord.length);
      _this.add(_coord, allowRepeated);
    }
    return _this;
  }

  createClass(CoordinateList, [{
    key: 'getCoordinate',
    value: function getCoordinate(i) {
      return this.get(i);
    }
  }, {
    key: 'addAll',
    value: function addAll() {
      if (arguments.length === 2) {
        var coll = arguments[0];
        var allowRepeated = arguments[1];
        var isChanged = false;
        for (var i = coll.iterator(); i.hasNext();) {
          this.add(i.next(), allowRepeated);
          isChanged = true;
        }
        return isChanged;
      } else return ArrayList.prototype.addAll.apply(this, arguments);
    }
  }, {
    key: 'clone',
    value: function clone() {
      var clone = ArrayList.prototype.clone.call(this);
      for (var i = 0; i < this.size(); i++) {
        clone.add(i, this.get(i).copy());
      }
      return clone;
    }
  }, {
    key: 'toCoordinateArray',
    value: function toCoordinateArray() {
      return this.toArray(CoordinateList.coordArrayType);
    }
  }, {
    key: 'add',
    value: function add() {
      if (arguments.length === 1) {
        var coord = arguments[0];
        ArrayList.prototype.add.call(this, coord);
      } else if (arguments.length === 2) {
        if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
          var _coord2 = arguments[0];
          var allowRepeated = arguments[1];
          this.add(_coord2, allowRepeated, true);
          return true;
        } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {
          var _coord3 = arguments[0];
          var _allowRepeated = arguments[1];
          if (!_allowRepeated) {
            if (this.size() >= 1) {
              var last = this.get(this.size() - 1);
              if (last.equals2D(_coord3)) return null;
            }
          }
          ArrayList.prototype.add.call(this, _coord3);
        } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {
          var obj = arguments[0];
          var _allowRepeated2 = arguments[1];
          this.add(obj, _allowRepeated2);
          return true;
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[2] === 'boolean' && arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
          var _coord4 = arguments[0];
          var _allowRepeated3 = arguments[1];
          var direction = arguments[2];
          if (direction) {
            for (var _i = 0; _i < _coord4.length; _i++) {
              this.add(_coord4[_i], _allowRepeated3);
            }
          } else {
            for (var _i2 = _coord4.length - 1; _i2 >= 0; _i2--) {
              this.add(_coord4[_i2], _allowRepeated3);
            }
          }
          return true;
        } else if (typeof arguments[2] === 'boolean' && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {
          var _i3 = arguments[0];
          var _coord5 = arguments[1];
          var _allowRepeated4 = arguments[2];
          if (!_allowRepeated4) {
            var size = this.size();
            if (size > 0) {
              if (_i3 > 0) {
                var prev = this.get(_i3 - 1);
                if (prev.equals2D(_coord5)) return null;
              }
              if (_i3 < size) {
                var next = this.get(_i3);
                if (next.equals2D(_coord5)) return null;
              }
            }
          }
          ArrayList.prototype.add.call(this, _i3, _coord5);
        }
      } else if (arguments.length === 4) {
        var _coord6 = arguments[0];
        var _allowRepeated5 = arguments[1];
        var start = arguments[2];
        var end = arguments[3];
        var inc = 1;
        if (start > end) inc = -1;
        for (var i = start; i !== end; i += inc) {
          this.add(_coord6[i], _allowRepeated5);
        }
        return true;
      }
    }
  }, {
    key: 'closeRing',
    value: function closeRing() {
      if (this.size() > 0) this.add(new Coordinate(this.get(0)), false);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateList;
    }
  }], [{
    key: 'coordArrayType',
    get: function get$$1() {
      return new Array(0).fill(null);
    }
  }]);
  return CoordinateList;
}(ArrayList);

var CoordinateArrays = function () {
  function CoordinateArrays() {
    classCallCheck(this, CoordinateArrays);
  }

  createClass(CoordinateArrays, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateArrays;
    }
  }], [{
    key: 'isRing',
    value: function isRing(pts) {
      if (pts.length < 4) return false;
      if (!pts[0].equals2D(pts[pts.length - 1])) return false;
      return true;
    }
  }, {
    key: 'ptNotInList',
    value: function ptNotInList(testPts, pts) {
      for (var i = 0; i < testPts.length; i++) {
        var testPt = testPts[i];
        if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;
      }
      return null;
    }
  }, {
    key: 'scroll',
    value: function scroll(coordinates, firstCoordinate) {
      var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
      if (i < 0) return null;
      var newCoordinates = new Array(coordinates.length).fill(null);
      System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
      System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
      System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
    }
  }, {
    key: 'equals',
    value: function equals() {
      if (arguments.length === 2) {
        var coord1 = arguments[0];
        var coord2 = arguments[1];
        if (coord1 === coord2) return true;
        if (coord1 === null || coord2 === null) return false;
        if (coord1.length !== coord2.length) return false;
        for (var i = 0; i < coord1.length; i++) {
          if (!coord1[i].equals(coord2[i])) return false;
        }
        return true;
      } else if (arguments.length === 3) {
        var _coord = arguments[0];
        var _coord2 = arguments[1];
        var coordinateComparator = arguments[2];
        if (_coord === _coord2) return true;
        if (_coord === null || _coord2 === null) return false;
        if (_coord.length !== _coord2.length) return false;
        for (var _i = 0; _i < _coord.length; _i++) {
          if (coordinateComparator.compare(_coord[_i], _coord2[_i]) !== 0) return false;
        }
        return true;
      }
    }
  }, {
    key: 'intersection',
    value: function intersection(coordinates, env) {
      var coordList = new CoordinateList();
      for (var i = 0; i < coordinates.length; i++) {
        if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);
      }
      return coordList.toCoordinateArray();
    }
  }, {
    key: 'hasRepeatedPoints',
    value: function hasRepeatedPoints(coord) {
      for (var i = 1; i < coord.length; i++) {
        if (coord[i - 1].equals(coord[i])) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'removeRepeatedPoints',
    value: function removeRepeatedPoints(coord) {
      if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;
      var coordList = new CoordinateList(coord, false);
      return coordList.toCoordinateArray();
    }
  }, {
    key: 'reverse',
    value: function reverse(coord) {
      var last = coord.length - 1;
      var mid = Math.trunc(last / 2);
      for (var i = 0; i <= mid; i++) {
        var tmp = coord[i];
        coord[i] = coord[last - i];
        coord[last - i] = tmp;
      }
    }
  }, {
    key: 'removeNull',
    value: function removeNull(coord) {
      var nonNull = 0;
      for (var i = 0; i < coord.length; i++) {
        if (coord[i] !== null) nonNull++;
      }
      var newCoord = new Array(nonNull).fill(null);
      if (nonNull === 0) return newCoord;
      var j = 0;
      for (var _i2 = 0; _i2 < coord.length; _i2++) {
        if (coord[_i2] !== null) newCoord[j++] = coord[_i2];
      }
      return newCoord;
    }
  }, {
    key: 'copyDeep',
    value: function copyDeep() {
      if (arguments.length === 1) {
        var coordinates = arguments[0];
        var copy = new Array(coordinates.length).fill(null);
        for (var i = 0; i < coordinates.length; i++) {
          copy[i] = new Coordinate(coordinates[i]);
        }
        return copy;
      } else if (arguments.length === 5) {
        var src = arguments[0];
        var srcStart = arguments[1];
        var dest = arguments[2];
        var destStart = arguments[3];
        var length = arguments[4];
        for (var _i3 = 0; _i3 < length; _i3++) {
          dest[destStart + _i3] = new Coordinate(src[srcStart + _i3]);
        }
      }
    }
  }, {
    key: 'isEqualReversed',
    value: function isEqualReversed(pts1, pts2) {
      for (var i = 0; i < pts1.length; i++) {
        var p1 = pts1[i];
        var p2 = pts2[pts1.length - i - 1];
        if (p1.compareTo(p2) !== 0) return false;
      }
      return true;
    }
  }, {
    key: 'envelope',
    value: function envelope(coordinates) {
      var env = new Envelope();
      for (var i = 0; i < coordinates.length; i++) {
        env.expandToInclude(coordinates[i]);
      }
      return env;
    }
  }, {
    key: 'toCoordinateArray',
    value: function toCoordinateArray(coordList) {
      return coordList.toArray(CoordinateArrays.coordArrayType);
    }
  }, {
    key: 'atLeastNCoordinatesOrNothing',
    value: function atLeastNCoordinatesOrNothing(n, c) {
      return c.length >= n ? c : [];
    }
  }, {
    key: 'indexOf',
    value: function indexOf(coordinate, coordinates) {
      for (var i = 0; i < coordinates.length; i++) {
        if (coordinate.equals(coordinates[i])) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: 'increasingDirection',
    value: function increasingDirection(pts) {
      for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
        var j = pts.length - 1 - i;
        var comp = pts[i].compareTo(pts[j]);
        if (comp !== 0) return comp;
      }
      return 1;
    }
  }, {
    key: 'compare',
    value: function compare(pts1, pts2) {
      var i = 0;
      while (i < pts1.length && i < pts2.length) {
        var compare = pts1[i].compareTo(pts2[i]);
        if (compare !== 0) return compare;
        i++;
      }
      if (i < pts2.length) return -1;
      if (i < pts1.length) return 1;
      return 0;
    }
  }, {
    key: 'minCoordinate',
    value: function minCoordinate(coordinates) {
      var minCoord = null;
      for (var i = 0; i < coordinates.length; i++) {
        if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
          minCoord = coordinates[i];
        }
      }
      return minCoord;
    }
  }, {
    key: 'extract',
    value: function extract(pts, start, end) {
      start = MathUtil.clamp(start, 0, pts.length);
      end = MathUtil.clamp(end, -1, pts.length);
      var npts = end - start + 1;
      if (end < 0) npts = 0;
      if (start >= pts.length) npts = 0;
      if (end < start) npts = 0;
      var extractPts = new Array(npts).fill(null);
      if (npts === 0) return extractPts;
      var iPts = 0;
      for (var i = start; i <= end; i++) {
        extractPts[iPts++] = pts[i];
      }
      return extractPts;
    }
  }, {
    key: 'ForwardComparator',
    get: function get$$1() {
      return ForwardComparator;
    }
  }, {
    key: 'BidirectionalComparator',
    get: function get$$1() {
      return BidirectionalComparator;
    }
  }, {
    key: 'coordArrayType',
    get: function get$$1() {
      return new Array(0).fill(null);
    }
  }]);
  return CoordinateArrays;
}();

var ForwardComparator = function () {
  function ForwardComparator() {
    classCallCheck(this, ForwardComparator);
  }

  createClass(ForwardComparator, [{
    key: 'compare',
    value: function compare(o1, o2) {
      var pts1 = o1;
      var pts2 = o2;
      return CoordinateArrays.compare(pts1, pts2);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparator];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return ForwardComparator;
    }
  }]);
  return ForwardComparator;
}();

var BidirectionalComparator = function () {
  function BidirectionalComparator() {
    classCallCheck(this, BidirectionalComparator);
  }

  createClass(BidirectionalComparator, [{
    key: 'compare',
    value: function compare(o1, o2) {
      var pts1 = o1;
      var pts2 = o2;
      if (pts1.length < pts2.length) return -1;
      if (pts1.length > pts2.length) return 1;
      if (pts1.length === 0) return 0;
      var forwardComp = CoordinateArrays.compare(pts1, pts2);
      var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
      if (isEqualRev) return 0;
      return forwardComp;
    }
  }, {
    key: 'OLDcompare',
    value: function OLDcompare(o1, o2) {
      var pts1 = o1;
      var pts2 = o2;
      if (pts1.length < pts2.length) return -1;
      if (pts1.length > pts2.length) return 1;
      if (pts1.length === 0) return 0;
      var dir1 = CoordinateArrays.increasingDirection(pts1);
      var dir2 = CoordinateArrays.increasingDirection(pts2);
      var i1 = dir1 > 0 ? 0 : pts1.length - 1;
      var i2 = dir2 > 0 ? 0 : pts1.length - 1;
      for (var i = 0; i < pts1.length; i++) {
        var comparePt = pts1[i1].compareTo(pts2[i2]);
        if (comparePt !== 0) return comparePt;
        i1 += dir1;
        i2 += dir2;
      }
      return 0;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparator];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BidirectionalComparator;
    }
  }]);
  return BidirectionalComparator;
}();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
 *
 * @constructor
 * @private
 */
var Map$1 = function () {
  function Map() {
    classCallCheck(this, Map);
  }

  createClass(Map, [{
    key: "get",

    /**
     * Returns the value to which the specified key is mapped, or null if this map
     * contains no mapping for the key.
     * @param {Object} key
     * @return {Object}
     */
    value: function get$$1() {}
  }, {
    key: "put",

    /**
     * Associates the specified value with the specified key in this map (optional
     * operation).
     * @param {Object} key
     * @param {Object} value
     * @return {Object}
     */
    value: function put() {}
  }, {
    key: "size",


    /**
     * Returns the number of key-value mappings in this map.
     * @return {number}
     */
    value: function size() {}
  }, {
    key: "values",


    /**
     * Returns a Collection view of the values contained in this map.
     * @return {javascript.util.Collection}
     */
    value: function values() {}
  }, {
    key: "entrySet",


    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own <tt>remove</tt> operation, or through the
     * <tt>setValue</tt> operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the <tt>Iterator.remove</tt>,
     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
     * <tt>clear</tt> operations.  It does not support the
     * <tt>add</tt> or <tt>addAll</tt> operations.
     *
     * @return {Set} a set view of the mappings contained in this map
     */
    value: function entrySet() {}
  }]);
  return Map;
}();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html
 *
 * @extends {Map}
 * @constructor
 * @private
 */

var SortedMap = function (_Map) {
  inherits(SortedMap, _Map);

  function SortedMap() {
    classCallCheck(this, SortedMap);
    return possibleConstructorReturn(this, (SortedMap.__proto__ || Object.getPrototypeOf(SortedMap)).apply(this, arguments));
  }

  return SortedMap;
}(Map$1);

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function OperationNotSupported(message) {
  this.message = message || '';
}
OperationNotSupported.prototype = new Error();

/**
 * @type {string}
 */
OperationNotSupported.prototype.name = 'OperationNotSupported';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html
 *
 * @extends {Collection}
 * @constructor
 * @private
 */
function Set() {}
Set.prototype = new Collection();

/**
 * Returns true if this set contains the specified element. More formally,
 * returns true if and only if this set contains an element e such that (o==null ?
 * e==null : o.equals(e)).
 * @param {Object} e
 * @return {boolean}
 */
Set.prototype.contains = function () {};

/**
 * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html
 *
 * @extends {javascript.util.Set}
 * @constructor
 * @private
 */

var HashSet = function (_Set) {
  inherits(HashSet, _Set);

  function HashSet() {
    classCallCheck(this, HashSet);

    var _this = possibleConstructorReturn(this, (HashSet.__proto__ || Object.getPrototypeOf(HashSet)).call(this));

    _this.array_ = [];

    if (arguments[0] instanceof Collection) {
      _this.addAll(arguments[0]);
    }
    return _this;
  }

  /**
   * @override
   */


  createClass(HashSet, [{
    key: 'contains',
    value: function contains(o) {
      for (var i = 0, len = this.array_.length; i < len; i++) {
        var e = this.array_[i];
        if (e === o) {
          return true;
        }
      }
      return false;
    }

    /**
     * @override
     */

  }, {
    key: 'add',
    value: function add(o) {
      if (this.contains(o)) {
        return false;
      }

      this.array_.push(o);

      return true;
    }

    /**
     * @override
     */

  }, {
    key: 'addAll',
    value: function addAll(c) {
      for (var i = c.iterator(); i.hasNext();) {
        this.add(i.next());
      }
      return true;
    }

    /**
     * @override
     */

  }, {
    key: 'remove',
    value: function remove(o) {
      // throw new javascript.util.OperationNotSupported()
      throw new Error();
    }

    /**
     * @override
     */

  }, {
    key: 'size',
    value: function size() {
      return this.array_.length;
    }

    /**
     * @override
     */

  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.array_.length === 0;
    }

    /**
     * @override
     */

  }, {
    key: 'toArray',
    value: function toArray$$1() {
      var array = [];

      for (var i = 0, len = this.array_.length; i < len; i++) {
        array.push(this.array_[i]);
      }

      return array;
    }

    /**
     * @override
     */

  }, {
    key: 'iterator',
    value: function iterator() {
      return new Iterator_$1(this);
    }
  }]);
  return HashSet;
}(Set);

var Iterator_$1 = function (_Iterator) {
  inherits(Iterator_, _Iterator);

  function Iterator_(hashSet) {
    classCallCheck(this, Iterator_);

    /**
     * @type {HashSet}
     * @private
     */
    var _this2 = possibleConstructorReturn(this, (Iterator_.__proto__ || Object.getPrototypeOf(Iterator_)).call(this));

    _this2.hashSet_ = hashSet;
    /**
     * @type {number}
     * @private
     */
    _this2.position_ = 0;
    return _this2;
  }

  /**
   * @override
   */


  createClass(Iterator_, [{
    key: 'next',
    value: function next() {
      if (this.position_ === this.hashSet_.size()) {
        throw new NoSuchElementException();
      }
      return this.hashSet_.array_[this.position_++];
    }

    /**
     * @override
     */

  }, {
    key: 'hasNext',
    value: function hasNext() {
      if (this.position_ < this.hashSet_.size()) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * @override
     */

  }, {
    key: 'remove',
    value: function remove() {
      throw new OperationNotSupported();
    }
  }]);
  return Iterator_;
}(Iterator);

var BLACK = 0;
var RED = 1;
function colorOf(p) {
  return p === null ? BLACK : p.color;
}
function parentOf(p) {
  return p === null ? null : p.parent;
}
function setColor(p, c) {
  if (p !== null) p.color = c;
}
function leftOf(p) {
  return p === null ? null : p.left;
}
function rightOf(p) {
  return p === null ? null : p.right;
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html
 *
 * @extends {SortedMap}
 * @constructor
 * @private
 */
function TreeMap() {
  /**
   * @type {Object}
   * @private
   */
  this.root_ = null;
  /**
   * @type {number}
   * @private
  */
  this.size_ = 0;
}
TreeMap.prototype = new SortedMap();

/**
 * @override
 */
TreeMap.prototype.get = function (key) {
  var p = this.root_;
  while (p !== null) {
    var cmp = key['compareTo'](p.key);
    if (cmp < 0) p = p.left;else if (cmp > 0) p = p.right;else return p.value;
  }
  return null;
};

/**
 * @override
 */
TreeMap.prototype.put = function (key, value) {
  if (this.root_ === null) {
    this.root_ = {
      key: key,
      value: value,
      left: null,
      right: null,
      parent: null,
      color: BLACK,
      getValue: function getValue() {
        return this.value;
      },
      getKey: function getKey() {
        return this.key;
      }
    };
    this.size_ = 1;
    return null;
  }
  var t = this.root_;
  var parent = void 0;
  var cmp = void 0;
  do {
    parent = t;
    cmp = key['compareTo'](t.key);
    if (cmp < 0) {
      t = t.left;
    } else if (cmp > 0) {
      t = t.right;
    } else {
      var oldValue = t.value;
      t.value = value;
      return oldValue;
    }
  } while (t !== null);
  var e = {
    key: key,
    left: null,
    right: null,
    value: value,
    parent: parent,
    color: BLACK,
    getValue: function getValue() {
      return this.value;
    },
    getKey: function getKey() {
      return this.key;
    }
  };
  if (cmp < 0) {
    parent.left = e;
  } else {
    parent.right = e;
  }
  this.fixAfterInsertion(e);
  this.size_++;
  return null;
};

/**
 * @param {Object} x
 */
TreeMap.prototype.fixAfterInsertion = function (x) {
  x.color = RED;
  while (x != null && x !== this.root_ && x.parent.color === RED) {
    if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
      var y = rightOf(parentOf(parentOf(x)));
      if (colorOf(y) === RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x === rightOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateLeft(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateRight(parentOf(parentOf(x)));
      }
    } else {
      var _y = leftOf(parentOf(parentOf(x)));
      if (colorOf(_y) === RED) {
        setColor(parentOf(x), BLACK);
        setColor(_y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x === leftOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateRight(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateLeft(parentOf(parentOf(x)));
      }
    }
  }
  this.root_.color = BLACK;
};

/**
 * @override
 */
TreeMap.prototype.values = function () {
  var arrayList = new ArrayList();
  var p = this.getFirstEntry();
  if (p !== null) {
    arrayList.add(p.value);
    while ((p = TreeMap.successor(p)) !== null) {
      arrayList.add(p.value);
    }
  }
  return arrayList;
};

/**
 * @override
 */
TreeMap.prototype.entrySet = function () {
  var hashSet = new HashSet();
  var p = this.getFirstEntry();
  if (p !== null) {
    hashSet.add(p);
    while ((p = TreeMap.successor(p)) !== null) {
      hashSet.add(p);
    }
  }
  return hashSet;
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateLeft = function (p) {
  if (p != null) {
    var r = p.right;
    p.right = r.left;
    if (r.left != null) {
      r.left.parent = p;
    }
    r.parent = p.parent;
    if (p.parent === null) {
      this.root_ = r;
    } else if (p.parent.left === p) {
      p.parent.left = r;
    } else {
      p.parent.right = r;
    }
    r.left = p;
    p.parent = r;
  }
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateRight = function (p) {
  if (p != null) {
    var l = p.left;
    p.left = l.right;
    if (l.right != null) l.right.parent = p;
    l.parent = p.parent;
    if (p.parent === null) {
      this.root_ = l;
    } else if (p.parent.right === p) {
      p.parent.right = l;
    } else p.parent.left = l;
    l.right = p;
    p.parent = l;
  }
};

/**
 * @return {Object}
 */
TreeMap.prototype.getFirstEntry = function () {
  var p = this.root_;
  if (p != null) {
    while (p.left != null) {
      p = p.left;
    }
  }
  return p;
};

/**
 * @param {Object} t
 * @return {Object}
 * @private
 */
TreeMap.successor = function (t) {
  if (t === null) {
    return null;
  } else if (t.right !== null) {
    var p = t.right;
    while (p.left !== null) {
      p = p.left;
    }
    return p;
  } else {
    var _p = t.parent;
    var ch = t;
    while (_p !== null && ch === _p.right) {
      ch = _p;
      _p = _p.parent;
    }
    return _p;
  }
};

/**
 * @override
 */
TreeMap.prototype.size = function () {
  return this.size_;
};

var Lineal = function () {
  function Lineal() {
    classCallCheck(this, Lineal);
  }

  createClass(Lineal, [{
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return Lineal;
    }
  }]);
  return Lineal;
}();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html
 *
 * @extends {Set}
 * @constructor
 * @private
 */
function SortedSet() {}
SortedSet.prototype = new Set();

// import Iterator from './Iterator'
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html
 *
 * @extends {SortedSet}
 * @constructor
 * @private
 */
function TreeSet() {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}
TreeSet.prototype = new SortedSet();

/**
 * @override
 */
TreeSet.prototype.contains = function (o) {
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 0) {
      return true;
    }
  }
  return false;
};

/**
 * @override
 */
TreeSet.prototype.add = function (o) {
  if (this.contains(o)) {
    return false;
  }

  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 1) {
      this.array_.splice(i, 0, o);
      return true;
    }
  }

  this.array_.push(o);

  return true;
};

/**
 * @override
 */
TreeSet.prototype.addAll = function (c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true;
};

/**
 * @override
 */
TreeSet.prototype.remove = function (e) {
  throw new OperationNotSupported();
};

/**
 * @override
 */
TreeSet.prototype.size = function () {
  return this.array_.length;
};

/**
 * @override
 */
TreeSet.prototype.isEmpty = function () {
  return this.array_.length === 0;
};

/**
 * @override
 */
TreeSet.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};

/**
 * @override
 */
TreeSet.prototype.iterator = function () {
  return new Iterator_$2(this);
};

/**
 * @extends {javascript.util.Iterator}
 * @param {javascript.util.TreeSet} treeSet
 * @constructor
 * @private
 */
var Iterator_$2 = function Iterator_(treeSet) {
  /**
   * @type {javascript.util.TreeSet}
   * @private
   */
  this.treeSet_ = treeSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_$2.prototype.next = function () {
  if (this.position_ === this.treeSet_.size()) {
    throw new NoSuchElementException();
  }
  return this.treeSet_.array_[this.position_++];
};

/**
 * @override
 */
Iterator_$2.prototype.hasNext = function () {
  if (this.position_ < this.treeSet_.size()) {
    return true;
  } else {
    return false;
  }
};

/**
 * @override
 */
Iterator_$2.prototype.remove = function () {
  throw new OperationNotSupported();
};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html
 *
 * @constructor
 * @private
 */

var Arrays = function () {
  function Arrays() {
    classCallCheck(this, Arrays);
  }

  createClass(Arrays, null, [{
    key: 'sort',
    value: function sort() {
      var a = arguments[0];
      var i = void 0;
      var t = void 0;
      var comparator = void 0;
      var compare = void 0;
      if (arguments.length === 1) {
        compare = function compare(a, b) {
          return a.compareTo(b);
        };
        a.sort(compare);
      } else if (arguments.length === 2) {
        comparator = arguments[1];
        compare = function compare(a, b) {
          return comparator['compare'](a, b);
        };
        a.sort(compare);
      } else if (arguments.length === 3) {
        t = a.slice(arguments[1], arguments[2]);
        t.sort();
        var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
        a.splice(0, a.length);
        for (i = 0; i < r.length; i++) {
          a.push(r[i]);
        }
      } else if (arguments.length === 4) {
        t = a.slice(arguments[1], arguments[2]);
        comparator = arguments[3];
        compare = function compare(a, b) {
          return comparator['compare'](a, b);
        };
        t.sort(compare);
        r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
        a.splice(0, a.length);
        for (i = 0; i < r.length; i++) {
          a.push(r[i]);
        }
      }
    }
    /**
     * @param {Array} array
     * @return {ArrayList}
     */

  }, {
    key: 'asList',
    value: function asList(array) {
      var arrayList = new ArrayList();
      for (var i = 0, len = array.length; i < len; i++) {
        arrayList.add(array[i]);
      }
      return arrayList;
    }
  }]);
  return Arrays;
}();

var Dimension = function () {
  function Dimension() {
    classCallCheck(this, Dimension);
  }

  createClass(Dimension, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Dimension;
    }
  }], [{
    key: 'toDimensionSymbol',
    value: function toDimensionSymbol(dimensionValue) {
      switch (dimensionValue) {
        case Dimension.FALSE:
          return Dimension.SYM_FALSE;
        case Dimension.TRUE:
          return Dimension.SYM_TRUE;
        case Dimension.DONTCARE:
          return Dimension.SYM_DONTCARE;
        case Dimension.P:
          return Dimension.SYM_P;
        case Dimension.L:
          return Dimension.SYM_L;
        case Dimension.A:
          return Dimension.SYM_A;
        default:
      }
      throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue);
    }
  }, {
    key: 'toDimensionValue',
    value: function toDimensionValue(dimensionSymbol) {
      switch (Character.toUpperCase(dimensionSymbol)) {
        case Dimension.SYM_FALSE:
          return Dimension.FALSE;
        case Dimension.SYM_TRUE:
          return Dimension.TRUE;
        case Dimension.SYM_DONTCARE:
          return Dimension.DONTCARE;
        case Dimension.SYM_P:
          return Dimension.P;
        case Dimension.SYM_L:
          return Dimension.L;
        case Dimension.SYM_A:
          return Dimension.A;
        default:
      }
      throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol);
    }
  }, {
    key: 'P',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'L',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'A',
    get: function get$$1() {
      return 2;
    }
  }, {
    key: 'FALSE',
    get: function get$$1() {
      return -1;
    }
  }, {
    key: 'TRUE',
    get: function get$$1() {
      return -2;
    }
  }, {
    key: 'DONTCARE',
    get: function get$$1() {
      return -3;
    }
  }, {
    key: 'SYM_FALSE',
    get: function get$$1() {
      return 'F';
    }
  }, {
    key: 'SYM_TRUE',
    get: function get$$1() {
      return 'T';
    }
  }, {
    key: 'SYM_DONTCARE',
    get: function get$$1() {
      return '*';
    }
  }, {
    key: 'SYM_P',
    get: function get$$1() {
      return '0';
    }
  }, {
    key: 'SYM_L',
    get: function get$$1() {
      return '1';
    }
  }, {
    key: 'SYM_A',
    get: function get$$1() {
      return '2';
    }
  }]);
  return Dimension;
}();

var GeometryFilter = function () {
  function GeometryFilter() {
    classCallCheck(this, GeometryFilter);
  }

  createClass(GeometryFilter, [{
    key: "filter",
    value: function filter(geom) {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return GeometryFilter;
    }
  }]);
  return GeometryFilter;
}();

var CoordinateSequenceFilter = function () {
  function CoordinateSequenceFilter() {
    classCallCheck(this, CoordinateSequenceFilter);
  }

  createClass(CoordinateSequenceFilter, [{
    key: "filter",
    value: function filter(seq, i) {}
  }, {
    key: "isDone",
    value: function isDone() {}
  }, {
    key: "isGeometryChanged",
    value: function isGeometryChanged() {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return CoordinateSequenceFilter;
    }
  }]);
  return CoordinateSequenceFilter;
}();

var GeometryCollection = function (_Geometry) {
  inherits(GeometryCollection, _Geometry);

  function GeometryCollection(geometries, factory) {
    classCallCheck(this, GeometryCollection);

    var _this = possibleConstructorReturn(this, (GeometryCollection.__proto__ || Object.getPrototypeOf(GeometryCollection)).call(this, factory));

    _this._geometries = geometries || [];

    if (Geometry.hasNullElements(_this._geometries)) {
      throw new IllegalArgumentException('geometries must not contain null elements');
    }
    return _this;
  }

  createClass(GeometryCollection, [{
    key: 'computeEnvelopeInternal',
    value: function computeEnvelopeInternal() {
      var envelope = new Envelope();
      for (var i = 0; i < this._geometries.length; i++) {
        envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());
      }
      return envelope;
    }
  }, {
    key: 'getGeometryN',
    value: function getGeometryN(n) {
      return this._geometries[n];
    }
  }, {
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_GEOMETRYCOLLECTION;
    }
  }, {
    key: 'getCoordinates',
    value: function getCoordinates() {
      var coordinates = new Array(this.getNumPoints()).fill(null);
      var k = -1;
      for (var i = 0; i < this._geometries.length; i++) {
        var childCoordinates = this._geometries[i].getCoordinates();
        for (var j = 0; j < childCoordinates.length; j++) {
          k++;
          coordinates[k] = childCoordinates[j];
        }
      }
      return coordinates;
    }
  }, {
    key: 'getArea',
    value: function getArea() {
      var area = 0.0;
      for (var i = 0; i < this._geometries.length; i++) {
        area += this._geometries[i].getArea();
      }
      return area;
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact() {
      if (arguments.length === 2) {
        var other = arguments[0];
        var tolerance = arguments[1];
        if (!this.isEquivalentClass(other)) {
          return false;
        }
        var otherCollection = other;
        if (this._geometries.length !== otherCollection._geometries.length) {
          return false;
        }
        for (var i = 0; i < this._geometries.length; i++) {
          if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
            return false;
          }
        }
        return true;
      } else return Geometry.prototype.equalsExact.apply(this, arguments);
    }
  }, {
    key: 'normalize',
    value: function normalize() {
      for (var i = 0; i < this._geometries.length; i++) {
        this._geometries[i].normalize();
      }
      Arrays.sort(this._geometries);
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      if (this.isEmpty()) return null;
      return this._geometries[0].getCoordinate();
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      var dimension = Dimension.FALSE;
      for (var i = 0; i < this._geometries.length; i++) {
        dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());
      }
      return dimension;
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      var dimension = Dimension.FALSE;
      for (var i = 0; i < this._geometries.length; i++) {
        dimension = Math.max(dimension, this._geometries[i].getDimension());
      }
      return dimension;
    }
  }, {
    key: 'getLength',
    value: function getLength() {
      var sum = 0.0;
      for (var i = 0; i < this._geometries.length; i++) {
        sum += this._geometries[i].getLength();
      }
      return sum;
    }
  }, {
    key: 'getNumPoints',
    value: function getNumPoints() {
      var numPoints = 0;
      for (var i = 0; i < this._geometries.length; i++) {
        numPoints += this._geometries[i].getNumPoints();
      }
      return numPoints;
    }
  }, {
    key: 'getNumGeometries',
    value: function getNumGeometries() {
      return this._geometries.length;
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      var n = this._geometries.length;
      var revGeoms = new Array(n).fill(null);
      for (var i = 0; i < this._geometries.length; i++) {
        revGeoms[i] = this._geometries[i].reverse();
      }
      return this.getFactory().createGeometryCollection(revGeoms);
    }
  }, {
    key: 'compareToSameClass',
    value: function compareToSameClass() {
      if (arguments.length === 1) {
        var o = arguments[0];
        var theseElements = new TreeSet(Arrays.asList(this._geometries));
        var otherElements = new TreeSet(Arrays.asList(o._geometries));
        return this.compare(theseElements, otherElements);
      } else if (arguments.length === 2) {
        var _o = arguments[0];
        var comp = arguments[1];
        var gc = _o;
        var n1 = this.getNumGeometries();
        var n2 = gc.getNumGeometries();
        var i = 0;
        while (i < n1 && i < n2) {
          var thisGeom = this.getGeometryN(i);
          var otherGeom = gc.getGeometryN(i);
          var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
          if (holeComp !== 0) return holeComp;
          i++;
        }
        if (i < n1) return 1;
        if (i < n2) return -1;
        return 0;
      }
    }
  }, {
    key: 'apply',
    value: function apply() {
      if (hasInterface(arguments[0], CoordinateFilter)) {
        var filter = arguments[0];
        for (var i = 0; i < this._geometries.length; i++) {
          this._geometries[i].apply(filter);
        }
      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
        var _filter = arguments[0];
        if (this._geometries.length === 0) return null;
        for (var _i = 0; _i < this._geometries.length; _i++) {
          this._geometries[_i].apply(_filter);
          if (_filter.isDone()) {
            break;
          }
        }
        if (_filter.isGeometryChanged()) this.geometryChanged();
      } else if (hasInterface(arguments[0], GeometryFilter)) {
        var _filter2 = arguments[0];
        _filter2.filter(this);
        for (var _i2 = 0; _i2 < this._geometries.length; _i2++) {
          this._geometries[_i2].apply(_filter2);
        }
      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
        var _filter3 = arguments[0];
        _filter3.filter(this);
        for (var _i3 = 0; _i3 < this._geometries.length; _i3++) {
          this._geometries[_i3].apply(_filter3);
        }
      }
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      this.checkNotGeometryCollection(this);
      Assert.shouldNeverReachHere();
      return null;
    }
  }, {
    key: 'clone',
    value: function clone() {
      var gc = Geometry.prototype.clone.call(this);
      gc._geometries = new Array(this._geometries.length).fill(null);
      for (var i = 0; i < this._geometries.length; i++) {
        gc._geometries[i] = this._geometries[i].clone();
      }
      return gc;
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'GeometryCollection';
    }
  }, {
    key: 'copy',
    value: function copy() {
      var geometries = new Array(this._geometries.length).fill(null);
      for (var i = 0; i < geometries.length; i++) {
        geometries[i] = this._geometries[i].copy();
      }
      return new GeometryCollection(geometries, this._factory);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      for (var i = 0; i < this._geometries.length; i++) {
        if (!this._geometries[i].isEmpty()) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryCollection;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return -5694727726395021467;
    }
  }]);
  return GeometryCollection;
}(Geometry);

var MultiLineString = function (_GeometryCollection) {
  inherits(MultiLineString, _GeometryCollection);

  function MultiLineString() {
    classCallCheck(this, MultiLineString);
    return possibleConstructorReturn(this, (MultiLineString.__proto__ || Object.getPrototypeOf(MultiLineString)).apply(this, arguments));
  }

  createClass(MultiLineString, [{
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_MULTILINESTRING;
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact() {
      if (arguments.length === 2) {
        var other = arguments[0];
        var tolerance = arguments[1];
        if (!this.isEquivalentClass(other)) {
          return false;
        }
        return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);
      } else return GeometryCollection.prototype.equalsExact.apply(this, arguments);
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      if (this.isClosed()) {
        return Dimension.FALSE;
      }
      return 0;
    }
  }, {
    key: 'isClosed',
    value: function isClosed() {
      if (this.isEmpty()) {
        return false;
      }
      for (var i = 0; i < this._geometries.length; i++) {
        if (!this._geometries[i].isClosed()) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      return 1;
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      var nLines = this._geometries.length;
      var revLines = new Array(nLines).fill(null);
      for (var i = 0; i < this._geometries.length; i++) {
        revLines[nLines - 1 - i] = this._geometries[i].reverse();
      }
      return this.getFactory().createMultiLineString(revLines);
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      return new BoundaryOp(this).getBoundary();
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'MultiLineString';
    }
  }, {
    key: 'copy',
    value: function copy() {
      var lineStrings = new Array(this._geometries.length).fill(null);
      for (var i = 0; i < lineStrings.length; i++) {
        lineStrings[i] = this._geometries[i].copy();
      }
      return new MultiLineString(lineStrings, this._factory);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Lineal];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MultiLineString;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return 8166665132445433741;
    }
  }]);
  return MultiLineString;
}(GeometryCollection);

var BoundaryOp = function () {
  function BoundaryOp() {
    classCallCheck(this, BoundaryOp);

    this._geom = null;
    this._geomFact = null;
    this._bnRule = null;
    this._endpointMap = null;
    if (arguments.length === 1) {
      var geom = arguments[0];
      var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;
      this._geom = geom;
      this._geomFact = geom.getFactory();
      this._bnRule = bnRule;
    } else if (arguments.length === 2) {
      var _geom = arguments[0];
      var _bnRule = arguments[1];
      this._geom = _geom;
      this._geomFact = _geom.getFactory();
      this._bnRule = _bnRule;
    }
  }

  createClass(BoundaryOp, [{
    key: 'boundaryMultiLineString',
    value: function boundaryMultiLineString(mLine) {
      if (this._geom.isEmpty()) {
        return this.getEmptyMultiPoint();
      }
      var bdyPts = this.computeBoundaryCoordinates(mLine);
      if (bdyPts.length === 1) {
        return this._geomFact.createPoint(bdyPts[0]);
      }
      return this._geomFact.createMultiPointFromCoords(bdyPts);
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      if (this._geom instanceof LineString) return this.boundaryLineString(this._geom);
      if (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);
      return this._geom.getBoundary();
    }
  }, {
    key: 'boundaryLineString',
    value: function boundaryLineString(line) {
      if (this._geom.isEmpty()) {
        return this.getEmptyMultiPoint();
      }
      if (line.isClosed()) {
        var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
        if (closedEndpointOnBoundary) {
          return line.getStartPoint();
        } else {
          return this._geomFact.createMultiPoint();
        }
      }
      return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);
    }
  }, {
    key: 'getEmptyMultiPoint',
    value: function getEmptyMultiPoint() {
      return this._geomFact.createMultiPoint();
    }
  }, {
    key: 'computeBoundaryCoordinates',
    value: function computeBoundaryCoordinates(mLine) {
      var bdyPts = new ArrayList();
      this._endpointMap = new TreeMap();
      for (var i = 0; i < mLine.getNumGeometries(); i++) {
        var line = mLine.getGeometryN(i);
        if (line.getNumPoints() === 0) continue;
        this.addEndpoint(line.getCoordinateN(0));
        this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
      }
      for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {
        var entry = it.next();
        var counter = entry.getValue();
        var valence = counter.count;
        if (this._bnRule.isInBoundary(valence)) {
          bdyPts.add(entry.getKey());
        }
      }
      return CoordinateArrays.toCoordinateArray(bdyPts);
    }
  }, {
    key: 'addEndpoint',
    value: function addEndpoint(pt) {
      var counter = this._endpointMap.get(pt);
      if (counter === null) {
        counter = new Counter();
        this._endpointMap.put(pt, counter);
      }
      counter.count++;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BoundaryOp;
    }
  }], [{
    key: 'getBoundary',
    value: function getBoundary() {
      if (arguments.length === 1) {
        var g = arguments[0];
        var bop = new BoundaryOp(g);
        return bop.getBoundary();
      } else if (arguments.length === 2) {
        var _g = arguments[0];
        var bnRule = arguments[1];
        var _bop = new BoundaryOp(_g, bnRule);
        return _bop.getBoundary();
      }
    }
  }]);
  return BoundaryOp;
}();

var Counter = function () {
  function Counter() {
    classCallCheck(this, Counter);

    this.count = null;
  }

  createClass(Counter, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Counter;
    }
  }]);
  return Counter;
}();

// boundary

function PrintStream() {}

function StringReader() {}

var DecimalFormat = function DecimalFormat() {
  classCallCheck(this, DecimalFormat);
};

function ByteArrayOutputStream() {}

function IOException() {}

function LineNumberReader() {}

var StringUtil = function () {
  function StringUtil() {
    classCallCheck(this, StringUtil);
  }

  createClass(StringUtil, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return StringUtil;
    }
  }], [{
    key: 'chars',
    value: function chars(c, n) {
      var ch = new Array(n).fill(null);
      for (var i = 0; i < n; i++) {
        ch[i] = c;
      }
      return String(ch);
    }
  }, {
    key: 'getStackTrace',
    value: function getStackTrace() {
      if (arguments.length === 1) {
        var t = arguments[0];
        var os = new ByteArrayOutputStream();
        var ps = new PrintStream(os);
        t.printStackTrace(ps);
        return os.toString();
      } else if (arguments.length === 2) {
        var _t = arguments[0];
        var depth = arguments[1];
        var stackTrace = '';
        var stringReader = new StringReader(StringUtil.getStackTrace(_t));
        var lineNumberReader = new LineNumberReader(stringReader);
        for (var i = 0; i < depth; i++) {
          try {
            stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
          } catch (e) {
            if (e instanceof IOException) {
              Assert.shouldNeverReachHere();
            } else throw e;
          } finally {}
        }
        return stackTrace;
      }
    }
  }, {
    key: 'split',
    value: function split(s, separator) {
      var separatorlen = separator.length;
      var tokenList = new ArrayList();
      var tmpString = '' + s;
      var pos = tmpString.indexOf(separator);
      while (pos >= 0) {
        var token = tmpString.substring(0, pos);
        tokenList.add(token);
        tmpString = tmpString.substring(pos + separatorlen);
        pos = tmpString.indexOf(separator);
      }
      if (tmpString.length > 0) tokenList.add(tmpString);
      var res = new Array(tokenList.size()).fill(null);
      for (var i = 0; i < res.length; i++) {
        res[i] = tokenList.get(i);
      }
      return res;
    }
  }, {
    key: 'toString',
    value: function toString() {
      if (arguments.length === 1) {
        var d = arguments[0];
        return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);
      }
    }
  }, {
    key: 'spaces',
    value: function spaces(n) {
      return StringUtil.chars(' ', n);
    }
  }, {
    key: 'NEWLINE',
    get: function get$$1() {
      return System.getProperty('line.separator');
    }
  }, {
    key: 'SIMPLE_ORDINATE_FORMAT',
    get: function get$$1() {
      return new DecimalFormat('0.#');
    }
  }]);
  return StringUtil;
}();

var CoordinateSequences = function () {
  function CoordinateSequences() {
    classCallCheck(this, CoordinateSequences);
  }

  createClass(CoordinateSequences, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateSequences;
    }
  }], [{
    key: 'copyCoord',
    value: function copyCoord(src, srcPos, dest, destPos) {
      var minDim = Math.min(src.getDimension(), dest.getDimension());
      for (var dim = 0; dim < minDim; dim++) {
        dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
      }
    }
  }, {
    key: 'isRing',
    value: function isRing(seq) {
      var n = seq.size();
      if (n === 0) return true;
      if (n <= 3) return false;
      return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
    }
  }, {
    key: 'isEqual',
    value: function isEqual(cs1, cs2) {
      var cs1Size = cs1.size();
      var cs2Size = cs2.size();
      if (cs1Size !== cs2Size) return false;
      var dim = Math.min(cs1.getDimension(), cs2.getDimension());
      for (var i = 0; i < cs1Size; i++) {
        for (var d = 0; d < dim; d++) {
          var v1 = cs1.getOrdinate(i, d);
          var v2 = cs2.getOrdinate(i, d);
          if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;
          if (Double.isNaN(v1) && Double.isNaN(v2)) continue;
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'extend',
    value: function extend(fact, seq, size) {
      var newseq = fact.create(size, seq.getDimension());
      var n = seq.size();
      CoordinateSequences.copy(seq, 0, newseq, 0, n);
      if (n > 0) {
        for (var i = n; i < size; i++) {
          CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
        }
      }
      return newseq;
    }
  }, {
    key: 'reverse',
    value: function reverse(seq) {
      var last = seq.size() - 1;
      var mid = Math.trunc(last / 2);
      for (var i = 0; i <= mid; i++) {
        CoordinateSequences.swap(seq, i, last - i);
      }
    }
  }, {
    key: 'swap',
    value: function swap(seq, i, j) {
      if (i === j) return null;
      for (var dim = 0; dim < seq.getDimension(); dim++) {
        var tmp = seq.getOrdinate(i, dim);
        seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
        seq.setOrdinate(j, dim, tmp);
      }
    }
  }, {
    key: 'copy',
    value: function copy(src, srcPos, dest, destPos, length) {
      for (var i = 0; i < length; i++) {
        CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      if (arguments.length === 1) {
        var cs = arguments[0];
        var size = cs.size();
        if (size === 0) return '()';
        var dim = cs.getDimension();
        var buf = new StringBuffer();
        buf.append('(');
        for (var i = 0; i < size; i++) {
          if (i > 0) buf.append(' ');
          for (var d = 0; d < dim; d++) {
            if (d > 0) buf.append(',');
            buf.append(StringUtil.toString(cs.getOrdinate(i, d)));
          }
        }
        buf.append(')');
        return buf.toString();
      }
    }
  }, {
    key: 'ensureValidRing',
    value: function ensureValidRing(fact, seq) {
      var n = seq.size();
      if (n === 0) return seq;
      if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);
      var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
      if (isClosed) return seq;
      return CoordinateSequences.createClosedRing(fact, seq, n + 1);
    }
  }, {
    key: 'createClosedRing',
    value: function createClosedRing(fact, seq, size) {
      var newseq = fact.create(size, seq.getDimension());
      var n = seq.size();
      CoordinateSequences.copy(seq, 0, newseq, 0, n);
      for (var i = n; i < size; i++) {
        CoordinateSequences.copy(seq, 0, newseq, i, 1);
      }return newseq;
    }
  }]);
  return CoordinateSequences;
}();

var LineString = function (_Geometry) {
  inherits(LineString, _Geometry);

  function LineString(points, factory) {
    classCallCheck(this, LineString);

    var _this = possibleConstructorReturn(this, (LineString.__proto__ || Object.getPrototypeOf(LineString)).call(this, factory));

    _this._points = null;
    _this.init(points);
    return _this;
  }

  createClass(LineString, [{
    key: 'computeEnvelopeInternal',
    value: function computeEnvelopeInternal() {
      if (this.isEmpty()) {
        return new Envelope();
      }
      return this._points.expandEnvelope(new Envelope());
    }
  }, {
    key: 'isRing',
    value: function isRing() {
      return this.isClosed() && this.isSimple();
    }
  }, {
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_LINESTRING;
    }
  }, {
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this._points.toCoordinateArray();
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact() {
      if (arguments.length === 2) {
        var other = arguments[0];
        var tolerance = arguments[1];
        if (!this.isEquivalentClass(other)) {
          return false;
        }
        var otherLineString = other;
        if (this._points.size() !== otherLineString._points.size()) {
          return false;
        }
        for (var i = 0; i < this._points.size(); i++) {
          if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
            return false;
          }
        }
        return true;
      } else return Geometry.prototype.equalsExact.apply(this, arguments);
    }
  }, {
    key: 'normalize',
    value: function normalize() {
      for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
        var j = this._points.size() - 1 - i;
        if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {
          if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {
            CoordinateSequences.reverse(this._points);
          }
          return null;
        }
      }
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      if (this.isEmpty()) return null;
      return this._points.getCoordinate(0);
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      if (this.isClosed()) {
        return Dimension.FALSE;
      }
      return 0;
    }
  }, {
    key: 'isClosed',
    value: function isClosed() {
      if (this.isEmpty()) {
        return false;
      }
      return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
    }
  }, {
    key: 'getEndPoint',
    value: function getEndPoint() {
      if (this.isEmpty()) {
        return null;
      }
      return this.getPointN(this.getNumPoints() - 1);
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      return 1;
    }
  }, {
    key: 'getLength',
    value: function getLength() {
      return CGAlgorithms.computeLength(this._points);
    }
  }, {
    key: 'getNumPoints',
    value: function getNumPoints() {
      return this._points.size();
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      var seq = this._points.copy();
      CoordinateSequences.reverse(seq);
      var revLine = this.getFactory().createLineString(seq);
      return revLine;
    }
  }, {
    key: 'compareToSameClass',
    value: function compareToSameClass() {
      if (arguments.length === 1) {
        var o = arguments[0];
        var line = o;
        var i = 0;
        var j = 0;
        while (i < this._points.size() && j < line._points.size()) {
          var comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
          if (comparison !== 0) {
            return comparison;
          }
          i++;
          j++;
        }
        if (i < this._points.size()) {
          return 1;
        }
        if (j < line._points.size()) {
          return -1;
        }
        return 0;
      } else if (arguments.length === 2) {
        var _o = arguments[0];
        var comp = arguments[1];
        var _line = _o;
        return comp.compare(this._points, _line._points);
      }
    }
  }, {
    key: 'apply',
    value: function apply() {
      if (hasInterface(arguments[0], CoordinateFilter)) {
        var filter = arguments[0];
        for (var i = 0; i < this._points.size(); i++) {
          filter.filter(this._points.getCoordinate(i));
        }
      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
        var _filter = arguments[0];
        if (this._points.size() === 0) return null;
        for (var _i = 0; _i < this._points.size(); _i++) {
          _filter.filter(this._points, _i);
          if (_filter.isDone()) break;
        }
        if (_filter.isGeometryChanged()) this.geometryChanged();
      } else if (hasInterface(arguments[0], GeometryFilter)) {
        var _filter2 = arguments[0];
        _filter2.filter(this);
      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
        var _filter3 = arguments[0];
        _filter3.filter(this);
      }
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      return new BoundaryOp(this).getBoundary();
    }
  }, {
    key: 'isEquivalentClass',
    value: function isEquivalentClass(other) {
      return other instanceof LineString;
    }
  }, {
    key: 'clone',
    value: function clone() {
      var ls = Geometry.prototype.clone.call(this);
      ls._points = this._points.clone();
      return ls;
    }
  }, {
    key: 'getCoordinateN',
    value: function getCoordinateN(n) {
      return this._points.getCoordinate(n);
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'LineString';
    }
  }, {
    key: 'copy',
    value: function copy() {
      return new LineString(this._points.copy(), this._factory);
    }
  }, {
    key: 'getCoordinateSequence',
    value: function getCoordinateSequence() {
      return this._points;
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this._points.size() === 0;
    }
  }, {
    key: 'init',
    value: function init(points) {
      if (points === null) {
        points = this.getFactory().getCoordinateSequenceFactory().create([]);
      }
      if (points.size() === 1) {
        throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)');
      }
      this._points = points;
    }
  }, {
    key: 'isCoordinate',
    value: function isCoordinate(pt) {
      for (var i = 0; i < this._points.size(); i++) {
        if (this._points.getCoordinate(i).equals(pt)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'getStartPoint',
    value: function getStartPoint() {
      if (this.isEmpty()) {
        return null;
      }
      return this.getPointN(0);
    }
  }, {
    key: 'getPointN',
    value: function getPointN(n) {
      return this.getFactory().createPoint(this._points.getCoordinate(n));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Lineal];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return LineString;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return 3110669828065365560;
    }
  }]);
  return LineString;
}(Geometry);

var Puntal = function () {
  function Puntal() {
    classCallCheck(this, Puntal);
  }

  createClass(Puntal, [{
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return Puntal;
    }
  }]);
  return Puntal;
}();

var Point = function (_Geometry) {
  inherits(Point, _Geometry);

  function Point(coordinates, factory) {
    classCallCheck(this, Point);

    var _this = possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, factory));

    _this._coordinates = coordinates || null;
    _this.init(_this._coordinates);
    return _this;
  }

  createClass(Point, [{
    key: 'computeEnvelopeInternal',
    value: function computeEnvelopeInternal() {
      if (this.isEmpty()) {
        return new Envelope();
      }
      var env = new Envelope();
      env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
      return env;
    }
  }, {
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_POINT;
    }
  }, {
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this.isEmpty() ? [] : [this.getCoordinate()];
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact() {
      if (arguments.length === 2) {
        var other = arguments[0];
        var tolerance = arguments[1];
        if (!this.isEquivalentClass(other)) {
          return false;
        }
        if (this.isEmpty() && other.isEmpty()) {
          return true;
        }
        if (this.isEmpty() !== other.isEmpty()) {
          return false;
        }
        return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
      } else return Geometry.prototype.equalsExact.apply(this, arguments);
    }
  }, {
    key: 'normalize',
    value: function normalize() {}
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      return Dimension.FALSE;
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      return 0;
    }
  }, {
    key: 'getNumPoints',
    value: function getNumPoints() {
      return this.isEmpty() ? 0 : 1;
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      return this.copy();
    }
  }, {
    key: 'getX',
    value: function getX() {
      if (this.getCoordinate() === null) {
        throw new Error('getX called on empty Point');
      }
      return this.getCoordinate().x;
    }
  }, {
    key: 'compareToSameClass',
    value: function compareToSameClass() {
      if (arguments.length === 1) {
        var other = arguments[0];
        var _point = other;
        return this.getCoordinate().compareTo(_point.getCoordinate());
      } else if (arguments.length === 2) {
        var _other = arguments[0];
        var comp = arguments[1];
        var point = _other;
        return comp.compare(this._coordinates, point._coordinates);
      }
    }
  }, {
    key: 'apply',
    value: function apply() {
      if (hasInterface(arguments[0], CoordinateFilter)) {
        var filter = arguments[0];
        if (this.isEmpty()) {
          return null;
        }
        filter.filter(this.getCoordinate());
      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
        var _filter = arguments[0];
        if (this.isEmpty()) return null;
        _filter.filter(this._coordinates, 0);
        if (_filter.isGeometryChanged()) this.geometryChanged();
      } else if (hasInterface(arguments[0], GeometryFilter)) {
        var _filter2 = arguments[0];
        _filter2.filter(this);
      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {
        var _filter3 = arguments[0];
        _filter3.filter(this);
      }
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      return this.getFactory().createGeometryCollection(null);
    }
  }, {
    key: 'clone',
    value: function clone() {
      var p = Geometry.prototype.clone.call(this);
      p._coordinates = this._coordinates.clone();
      return p;
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'Point';
    }
  }, {
    key: 'copy',
    value: function copy() {
      return new Point(this._coordinates.copy(), this._factory);
    }
  }, {
    key: 'getCoordinateSequence',
    value: function getCoordinateSequence() {
      return this._coordinates;
    }
  }, {
    key: 'getY',
    value: function getY() {
      if (this.getCoordinate() === null) {
        throw new Error('getY called on empty Point');
      }
      return this.getCoordinate().y;
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this._coordinates.size() === 0;
    }
  }, {
    key: 'init',
    value: function init(coordinates) {
      if (coordinates === null) {
        coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
      }
      Assert.isTrue(coordinates.size() <= 1);
      this._coordinates = coordinates;
    }
  }, {
    key: 'isSimple',
    value: function isSimple() {
      return true;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Puntal];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Point;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return 4902022702746614570;
    }
  }]);
  return Point;
}(Geometry);

var Polygonal = function () {
  function Polygonal() {
    classCallCheck(this, Polygonal);
  }

  createClass(Polygonal, [{
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return Polygonal;
    }
  }]);
  return Polygonal;
}();

var Polygon = function (_Geometry) {
  inherits(Polygon, _Geometry);

  function Polygon(shell, holes, factory) {
    classCallCheck(this, Polygon);

    var _this = possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, factory));

    _this._shell = null;
    _this._holes = null;
    if (shell === null) {
      shell = _this.getFactory().createLinearRing();
    }
    if (holes === null) {
      holes = [];
    }
    if (Geometry.hasNullElements(holes)) {
      throw new IllegalArgumentException('holes must not contain null elements');
    }
    if (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {
      throw new IllegalArgumentException('shell is empty but holes are not');
    }
    _this._shell = shell;
    _this._holes = holes;
    return _this;
  }

  createClass(Polygon, [{
    key: 'computeEnvelopeInternal',
    value: function computeEnvelopeInternal() {
      return this._shell.getEnvelopeInternal();
    }
  }, {
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_POLYGON;
    }
  }, {
    key: 'getCoordinates',
    value: function getCoordinates() {
      if (this.isEmpty()) {
        return [];
      }
      var coordinates = new Array(this.getNumPoints()).fill(null);
      var k = -1;
      var shellCoordinates = this._shell.getCoordinates();
      for (var x = 0; x < shellCoordinates.length; x++) {
        k++;
        coordinates[k] = shellCoordinates[x];
      }
      for (var i = 0; i < this._holes.length; i++) {
        var childCoordinates = this._holes[i].getCoordinates();
        for (var j = 0; j < childCoordinates.length; j++) {
          k++;
          coordinates[k] = childCoordinates[j];
        }
      }
      return coordinates;
    }
  }, {
    key: 'getArea',
    value: function getArea() {
      var area = 0.0;
      area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));
      for (var i = 0; i < this._holes.length; i++) {
        area -= Math.abs(CGAlgorithms.signedArea(this._holes[i].getCoordinateSequence()));
      }
      return area;
    }
  }, {
    key: 'isRectangle',
    value: function isRectangle() {
      if (this.getNumInteriorRing() !== 0) return false;
      if (this._shell === null) return false;
      if (this._shell.getNumPoints() !== 5) return false;
      var seq = this._shell.getCoordinateSequence();
      var env = this.getEnvelopeInternal();
      for (var i = 0; i < 5; i++) {
        var x = seq.getX(i);
        if (!(x === env.getMinX() || x === env.getMaxX())) return false;
        var y = seq.getY(i);
        if (!(y === env.getMinY() || y === env.getMaxY())) return false;
      }
      var prevX = seq.getX(0);
      var prevY = seq.getY(0);
      for (var _i = 1; _i <= 4; _i++) {
        var _x = seq.getX(_i);
        var _y = seq.getY(_i);
        var xChanged = _x !== prevX;
        var yChanged = _y !== prevY;
        if (xChanged === yChanged) return false;
        prevX = _x;
        prevY = _y;
      }
      return true;
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact() {
      if (arguments.length === 2) {
        var other = arguments[0];
        var tolerance = arguments[1];
        if (!this.isEquivalentClass(other)) {
          return false;
        }
        var otherPolygon = other;
        var thisShell = this._shell;
        var otherPolygonShell = otherPolygon._shell;
        if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
          return false;
        }
        if (this._holes.length !== otherPolygon._holes.length) {
          return false;
        }
        for (var i = 0; i < this._holes.length; i++) {
          if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
            return false;
          }
        }
        return true;
      } else return Geometry.prototype.equalsExact.apply(this, arguments);
    }
  }, {
    key: 'normalize',
    value: function normalize() {
      if (arguments.length === 0) {
        this.normalize(this._shell, true);
        for (var i = 0; i < this._holes.length; i++) {
          this.normalize(this._holes[i], false);
        }
        Arrays.sort(this._holes);
      } else if (arguments.length === 2) {
        var ring = arguments[0];
        var clockwise = arguments[1];
        if (ring.isEmpty()) {
          return null;
        }
        var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
        System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
        var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());
        CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
        System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
        ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
        if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {
          CoordinateArrays.reverse(ring.getCoordinates());
        }
      }
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this._shell.getCoordinate();
    }
  }, {
    key: 'getNumInteriorRing',
    value: function getNumInteriorRing() {
      return this._holes.length;
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      return 1;
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      return 2;
    }
  }, {
    key: 'getLength',
    value: function getLength() {
      var len = 0.0;
      len += this._shell.getLength();
      for (var i = 0; i < this._holes.length; i++) {
        len += this._holes[i].getLength();
      }
      return len;
    }
  }, {
    key: 'getNumPoints',
    value: function getNumPoints() {
      var numPoints = this._shell.getNumPoints();
      for (var i = 0; i < this._holes.length; i++) {
        numPoints += this._holes[i].getNumPoints();
      }
      return numPoints;
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      var poly = this.copy();
      poly._shell = this._shell.copy().reverse();
      poly._holes = new Array(this._holes.length).fill(null);
      for (var i = 0; i < this._holes.length; i++) {
        poly._holes[i] = this._holes[i].copy().reverse();
      }
      return poly;
    }
  }, {
    key: 'convexHull',
    value: function convexHull() {
      return this.getExteriorRing().convexHull();
    }
  }, {
    key: 'compareToSameClass',
    value: function compareToSameClass() {
      if (arguments.length === 1) {
        var o = arguments[0];
        var thisShell = this._shell;
        var otherShell = o._shell;
        return thisShell.compareToSameClass(otherShell);
      } else if (arguments.length === 2) {
        var _o = arguments[0];
        var comp = arguments[1];
        var poly = _o;
        var _thisShell = this._shell;
        var _otherShell = poly._shell;
        var shellComp = _thisShell.compareToSameClass(_otherShell, comp);
        if (shellComp !== 0) return shellComp;
        var nHole1 = this.getNumInteriorRing();
        var nHole2 = poly.getNumInteriorRing();
        var i = 0;
        while (i < nHole1 && i < nHole2) {
          var thisHole = this.getInteriorRingN(i);
          var otherHole = poly.getInteriorRingN(i);
          var holeComp = thisHole.compareToSameClass(otherHole, comp);
          if (holeComp !== 0) return holeComp;
          i++;
        }
        if (i < nHole1) return 1;
        if (i < nHole2) return -1;
        return 0;
      }
    }
  }, {
    key: 'apply',
    value: function apply(filter) {
      if (hasInterface(filter, CoordinateFilter)) {
        this._shell.apply(filter);
        for (var _i2 = 0; _i2 < this._holes.length; _i2++) {
          this._holes[_i2].apply(filter);
        }
      } else if (hasInterface(filter, CoordinateSequenceFilter)) {
        this._shell.apply(filter);
        if (!filter.isDone()) {
          for (var _i3 = 0; _i3 < this._holes.length; _i3++) {
            this._holes[_i3].apply(filter);
            if (filter.isDone()) break;
          }
        }
        if (filter.isGeometryChanged()) this.geometryChanged();
      } else if (hasInterface(filter, GeometryFilter)) {
        filter.filter(this);
      } else if (hasInterface(filter, GeometryComponentFilter)) {
        filter.filter(this);
        this._shell.apply(filter);
        for (var i = 0; i < this._holes.length; i++) {
          this._holes[i].apply(filter);
        }
      }
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      if (this.isEmpty()) {
        return this.getFactory().createMultiLineString();
      }
      var rings = new Array(this._holes.length + 1).fill(null);
      rings[0] = this._shell;
      for (var i = 0; i < this._holes.length; i++) {
        rings[i + 1] = this._holes[i];
      }
      if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
      return this.getFactory().createMultiLineString(rings);
    }
  }, {
    key: 'clone',
    value: function clone() {
      var poly = Geometry.prototype.clone.call(this);
      poly._shell = this._shell.clone();
      poly._holes = new Array(this._holes.length).fill(null);
      for (var i = 0; i < this._holes.length; i++) {
        poly._holes[i] = this._holes[i].clone();
      }
      return poly;
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'Polygon';
    }
  }, {
    key: 'copy',
    value: function copy() {
      var shell = this._shell.copy();
      var holes = new Array(this._holes.length).fill(null);
      for (var i = 0; i < holes.length; i++) {
        holes[i] = this._holes[i].copy();
      }
      return new Polygon(shell, holes, this._factory);
    }
  }, {
    key: 'getExteriorRing',
    value: function getExteriorRing() {
      return this._shell;
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this._shell.isEmpty();
    }
  }, {
    key: 'getInteriorRingN',
    value: function getInteriorRingN(n) {
      return this._holes[n];
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Polygonal];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Polygon;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return -3494792200821764533;
    }
  }]);
  return Polygon;
}(Geometry);

var MultiPoint = function (_GeometryCollection) {
  inherits(MultiPoint, _GeometryCollection);

  function MultiPoint() {
    classCallCheck(this, MultiPoint);
    return possibleConstructorReturn(this, (MultiPoint.__proto__ || Object.getPrototypeOf(MultiPoint)).apply(this, arguments));
  }

  createClass(MultiPoint, [{
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_MULTIPOINT;
    }
  }, {
    key: 'isValid',
    value: function isValid() {
      return true;
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact() {
      if (arguments.length === 2) {
        var other = arguments[0];
        var tolerance = arguments[1];
        if (!this.isEquivalentClass(other)) {
          return false;
        }
        return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);
      } else return GeometryCollection.prototype.equalsExact.apply(this, arguments);
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      if (arguments.length === 1) {
        var n = arguments[0];
        return this._geometries[n].getCoordinate();
      } else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      return Dimension.FALSE;
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      return 0;
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      return this.getFactory().createGeometryCollection(null);
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'MultiPoint';
    }
  }, {
    key: 'copy',
    value: function copy() {
      var points = new Array(this._geometries.length).fill(null);
      for (var i = 0; i < points.length; i++) {
        points[i] = this._geometries[i].copy();
      }
      return new MultiPoint(points, this._factory);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Puntal];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MultiPoint;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return -8048474874175355449;
    }
  }]);
  return MultiPoint;
}(GeometryCollection);

var LinearRing = function (_LineString) {
  inherits(LinearRing, _LineString);

  function LinearRing(points, factory) {
    classCallCheck(this, LinearRing);

    if (points instanceof Coordinate && factory instanceof GeometryFactory) {
      points = factory.getCoordinateSequenceFactory().create(points);
    }

    var _this = possibleConstructorReturn(this, (LinearRing.__proto__ || Object.getPrototypeOf(LinearRing)).call(this, points, factory));

    _this.validateConstruction();
    return _this;
  }

  createClass(LinearRing, [{
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_LINEARRING;
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      return Dimension.FALSE;
    }
  }, {
    key: 'isClosed',
    value: function isClosed() {
      if (this.isEmpty()) {
        return true;
      }
      return LineString.prototype.isClosed.call(this);
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      var seq = this._points.copy();
      CoordinateSequences.reverse(seq);
      var rev = this.getFactory().createLinearRing(seq);
      return rev;
    }
  }, {
    key: 'validateConstruction',
    value: function validateConstruction() {
      if (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {
        throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring');
      }
      if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {
        throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)');
      }
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'LinearRing';
    }
  }, {
    key: 'copy',
    value: function copy() {
      return new LinearRing(this._points.copy(), this._factory);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return LinearRing;
    }
  }], [{
    key: 'MINIMUM_VALID_SIZE',
    get: function get$$1() {
      return 4;
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return -4261142084085851829;
    }
  }]);
  return LinearRing;
}(LineString);

var MultiPolygon = function (_GeometryCollection) {
  inherits(MultiPolygon, _GeometryCollection);

  function MultiPolygon() {
    classCallCheck(this, MultiPolygon);
    return possibleConstructorReturn(this, (MultiPolygon.__proto__ || Object.getPrototypeOf(MultiPolygon)).apply(this, arguments));
  }

  createClass(MultiPolygon, [{
    key: 'getSortIndex',
    value: function getSortIndex() {
      return Geometry.SORTINDEX_MULTIPOLYGON;
    }
  }, {
    key: 'equalsExact',
    value: function equalsExact() {
      if (arguments.length === 2) {
        var other = arguments[0];
        var tolerance = arguments[1];
        if (!this.isEquivalentClass(other)) {
          return false;
        }
        return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);
      } else return GeometryCollection.prototype.equalsExact.apply(this, arguments);
    }
  }, {
    key: 'getBoundaryDimension',
    value: function getBoundaryDimension() {
      return 1;
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      return 2;
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      var n = this._geometries.length;
      var revGeoms = new Array(n).fill(null);
      for (var i = 0; i < this._geometries.length; i++) {
        revGeoms[i] = this._geometries[i].reverse();
      }
      return this.getFactory().createMultiPolygon(revGeoms);
    }
  }, {
    key: 'getBoundary',
    value: function getBoundary() {
      if (this.isEmpty()) {
        return this.getFactory().createMultiLineString();
      }
      var allRings = new ArrayList();
      for (var i = 0; i < this._geometries.length; i++) {
        var polygon = this._geometries[i];
        var rings = polygon.getBoundary();
        for (var j = 0; j < rings.getNumGeometries(); j++) {
          allRings.add(rings.getGeometryN(j));
        }
      }
      var allRingsArray = new Array(allRings.size()).fill(null);
      return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
    }
  }, {
    key: 'getGeometryType',
    value: function getGeometryType() {
      return 'MultiPolygon';
    }
  }, {
    key: 'copy',
    value: function copy() {
      var polygons = new Array(this._geometries.length).fill(null);
      for (var i = 0; i < polygons.length; i++) {
        polygons[i] = this._geometries[i].copy();
      }
      return new MultiPolygon(polygons, this._factory);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Polygonal];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MultiPolygon;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return -551033529766975875;
    }
  }]);
  return MultiPolygon;
}(GeometryCollection);

var GeometryEditor = function () {
  function GeometryEditor(factory) {
    classCallCheck(this, GeometryEditor);

    this._factory = factory || null;
    this._isUserDataCopied = false;
  }

  createClass(GeometryEditor, [{
    key: 'setCopyUserData',
    value: function setCopyUserData(isUserDataCopied) {
      this._isUserDataCopied = isUserDataCopied;
    }
  }, {
    key: 'edit',
    value: function edit(geometry, operation) {
      if (geometry === null) return null;
      var result = this.editInternal(geometry, operation);
      if (this._isUserDataCopied) {
        result.setUserData(geometry.getUserData());
      }
      return result;
    }
  }, {
    key: 'editInternal',
    value: function editInternal(geometry, operation) {
      if (this._factory === null) this._factory = geometry.getFactory();
      if (geometry instanceof GeometryCollection) {
        return this.editGeometryCollection(geometry, operation);
      }
      if (geometry instanceof Polygon) {
        return this.editPolygon(geometry, operation);
      }
      if (geometry instanceof Point) {
        return operation.edit(geometry, this._factory);
      }
      if (geometry instanceof LineString) {
        return operation.edit(geometry, this._factory);
      }
      Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());
      return null;
    }
  }, {
    key: 'editGeometryCollection',
    value: function editGeometryCollection(collection, operation) {
      var collectionForType = operation.edit(collection, this._factory);
      var geometries = new ArrayList();
      for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
        var geometry = this.edit(collectionForType.getGeometryN(i), operation);
        if (geometry === null || geometry.isEmpty()) {
          continue;
        }
        geometries.add(geometry);
      }
      if (collectionForType.getClass() === MultiPoint) {
        return this._factory.createMultiPoint(geometries.toArray([]));
      }
      if (collectionForType.getClass() === MultiLineString) {
        return this._factory.createMultiLineString(geometries.toArray([]));
      }
      if (collectionForType.getClass() === MultiPolygon) {
        return this._factory.createMultiPolygon(geometries.toArray([]));
      }
      return this._factory.createGeometryCollection(geometries.toArray([]));
    }
  }, {
    key: 'editPolygon',
    value: function editPolygon(polygon, operation) {
      var newPolygon = operation.edit(polygon, this._factory);
      if (newPolygon === null) newPolygon = this._factory.createPolygon(null);
      if (newPolygon.isEmpty()) {
        return newPolygon;
      }
      var shell = this.edit(newPolygon.getExteriorRing(), operation);
      if (shell === null || shell.isEmpty()) {
        return this._factory.createPolygon();
      }
      var holes = new ArrayList();
      for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
        var hole = this.edit(newPolygon.getInteriorRingN(i), operation);
        if (hole === null || hole.isEmpty()) {
          continue;
        }
        holes.add(hole);
      }
      return this._factory.createPolygon(shell, holes.toArray([]));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryEditor;
    }
  }], [{
    key: 'GeometryEditorOperation',
    value: function GeometryEditorOperation() {}
  }, {
    key: 'NoOpGeometryOperation',
    get: function get$$1() {
      return NoOpGeometryOperation;
    }
  }, {
    key: 'CoordinateOperation',
    get: function get$$1() {
      return CoordinateOperation;
    }
  }, {
    key: 'CoordinateSequenceOperation',
    get: function get$$1() {
      return CoordinateSequenceOperation;
    }
  }]);
  return GeometryEditor;
}();

var NoOpGeometryOperation = function () {
  function NoOpGeometryOperation() {
    classCallCheck(this, NoOpGeometryOperation);
  }

  createClass(NoOpGeometryOperation, [{
    key: 'edit',
    value: function edit(geometry, factory) {
      return geometry;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryEditor.GeometryEditorOperation];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NoOpGeometryOperation;
    }
  }]);
  return NoOpGeometryOperation;
}();

var CoordinateOperation = function () {
  function CoordinateOperation() {
    classCallCheck(this, CoordinateOperation);
  }

  createClass(CoordinateOperation, [{
    key: 'edit',
    value: function edit(geometry, factory) {
      var coords = this.editCoordinates(geometry.getCoordinates(), geometry);
      if (coords === null) return geometry;
      if (geometry instanceof LinearRing) {
        return factory.createLinearRing(coords);
      }
      if (geometry instanceof LineString) {
        return factory.createLineString(coords);
      }
      if (geometry instanceof Point) {
        if (coords.length > 0) {
          return factory.createPoint(coords[0]);
        } else {
          return factory.createPoint();
        }
      }
      return geometry;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryEditor.GeometryEditorOperation];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateOperation;
    }
  }]);
  return CoordinateOperation;
}();

var CoordinateSequenceOperation = function () {
  function CoordinateSequenceOperation() {
    classCallCheck(this, CoordinateSequenceOperation);
  }

  createClass(CoordinateSequenceOperation, [{
    key: 'edit',
    value: function edit(geometry, factory) {
      if (geometry instanceof LinearRing) {
        return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));
      }
      if (geometry instanceof LineString) {
        return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));
      }
      if (geometry instanceof Point) {
        return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));
      }
      return geometry;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryEditor.GeometryEditorOperation];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateSequenceOperation;
    }
  }]);
  return CoordinateSequenceOperation;
}();

var CoordinateArraySequence = function () {
  function CoordinateArraySequence() {
    classCallCheck(this, CoordinateArraySequence);

    this._dimension = 3;
    this._coordinates = null;
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        this._coordinates = arguments[0];
        this._dimension = 3;
      } else if (Number.isInteger(arguments[0])) {
        var size = arguments[0];
        this._coordinates = new Array(size).fill(null);
        for (var i = 0; i < size; i++) {
          this._coordinates[i] = new Coordinate();
        }
      } else if (hasInterface(arguments[0], CoordinateSequence)) {
        var coordSeq = arguments[0];
        if (coordSeq === null) {
          this._coordinates = new Array(0).fill(null);
          return null;
        }
        this._dimension = coordSeq.getDimension();
        this._coordinates = new Array(coordSeq.size()).fill(null);
        for (var _i = 0; _i < this._coordinates.length; _i++) {
          this._coordinates[_i] = coordSeq.getCoordinateCopy(_i);
        }
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
        var coordinates = arguments[0];
        var dimension = arguments[1];
        this._coordinates = coordinates;
        this._dimension = dimension;
        if (coordinates === null) this._coordinates = new Array(0).fill(null);
      } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
        var _size = arguments[0];
        var _dimension = arguments[1];
        this._coordinates = new Array(_size).fill(null);
        this._dimension = _dimension;
        for (var _i2 = 0; _i2 < _size; _i2++) {
          this._coordinates[_i2] = new Coordinate();
        }
      }
    }
  }

  createClass(CoordinateArraySequence, [{
    key: 'setOrdinate',
    value: function setOrdinate(index, ordinateIndex, value) {
      switch (ordinateIndex) {
        case CoordinateSequence.X:
          this._coordinates[index].x = value;
          break;
        case CoordinateSequence.Y:
          this._coordinates[index].y = value;
          break;
        case CoordinateSequence.Z:
          this._coordinates[index].z = value;
          break;
        default:
          throw new IllegalArgumentException('invalid ordinateIndex');
      }
    }
  }, {
    key: 'size',
    value: function size() {
      return this._coordinates.length;
    }
  }, {
    key: 'getOrdinate',
    value: function getOrdinate(index, ordinateIndex) {
      switch (ordinateIndex) {
        case CoordinateSequence.X:
          return this._coordinates[index].x;
        case CoordinateSequence.Y:
          return this._coordinates[index].y;
        case CoordinateSequence.Z:
          return this._coordinates[index].z;
        default:
      }
      return Double.NaN;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      if (arguments.length === 1) {
        var i = arguments[0];
        return this._coordinates[i];
      } else if (arguments.length === 2) {
        var index = arguments[0];
        var coord = arguments[1];
        coord.x = this._coordinates[index].x;
        coord.y = this._coordinates[index].y;
        coord.z = this._coordinates[index].z;
      }
    }
  }, {
    key: 'getCoordinateCopy',
    value: function getCoordinateCopy(i) {
      return new Coordinate(this._coordinates[i]);
    }
  }, {
    key: 'getDimension',
    value: function getDimension() {
      return this._dimension;
    }
  }, {
    key: 'getX',
    value: function getX(index) {
      return this._coordinates[index].x;
    }
  }, {
    key: 'clone',
    value: function clone() {
      var cloneCoordinates = new Array(this.size()).fill(null);
      for (var i = 0; i < this._coordinates.length; i++) {
        cloneCoordinates[i] = this._coordinates[i].clone();
      }
      return new CoordinateArraySequence(cloneCoordinates, this._dimension);
    }
  }, {
    key: 'expandEnvelope',
    value: function expandEnvelope(env) {
      for (var i = 0; i < this._coordinates.length; i++) {
        env.expandToInclude(this._coordinates[i]);
      }
      return env;
    }
  }, {
    key: 'copy',
    value: function copy() {
      var cloneCoordinates = new Array(this.size()).fill(null);
      for (var i = 0; i < this._coordinates.length; i++) {
        cloneCoordinates[i] = this._coordinates[i].copy();
      }
      return new CoordinateArraySequence(cloneCoordinates, this._dimension);
    }
  }, {
    key: 'toString',
    value: function toString() {
      if (this._coordinates.length > 0) {
        var strBuf = new StringBuffer(17 * this._coordinates.length);
        strBuf.append('(');
        strBuf.append(this._coordinates[0]);
        for (var i = 1; i < this._coordinates.length; i++) {
          strBuf.append(', ');
          strBuf.append(this._coordinates[i]);
        }
        strBuf.append(')');
        return strBuf.toString();
      } else {
        return '()';
      }
    }
  }, {
    key: 'getY',
    value: function getY(index) {
      return this._coordinates[index].y;
    }
  }, {
    key: 'toCoordinateArray',
    value: function toCoordinateArray() {
      return this._coordinates;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateSequence, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateArraySequence;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return -915438501601840650;
    }
  }]);
  return CoordinateArraySequence;
}();

var CoordinateArraySequenceFactory = function () {
  function CoordinateArraySequenceFactory() {
    classCallCheck(this, CoordinateArraySequenceFactory);
  }

  createClass(CoordinateArraySequenceFactory, [{
    key: 'readResolve',
    value: function readResolve() {
      return CoordinateArraySequenceFactory.instance();
    }
  }, {
    key: 'create',
    value: function create() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var coordinates = arguments[0];
          return new CoordinateArraySequence(coordinates);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordSeq = arguments[0];
          return new CoordinateArraySequence(coordSeq);
        }
      } else if (arguments.length === 2) {
        var size = arguments[0];
        var dimension = arguments[1];
        if (dimension > 3) dimension = 3;
        if (dimension < 2) return new CoordinateArraySequence(size);
        return new CoordinateArraySequence(size, dimension);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateSequenceFactory, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CoordinateArraySequenceFactory;
    }
  }], [{
    key: 'instance',
    value: function instance() {
      return CoordinateArraySequenceFactory.instanceObject;
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return -4099577099607551657;
    }
  }, {
    key: 'instanceObject',
    get: function get$$1() {
      return new CoordinateArraySequenceFactory();
    }
  }]);
  return CoordinateArraySequenceFactory;
}();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html
 *
 * @extends {javascript.util.Map}
 * @constructor
 * @private
 */

var HashMap = function (_MapInterface) {
  inherits(HashMap, _MapInterface);

  function HashMap() {
    classCallCheck(this, HashMap);

    var _this = possibleConstructorReturn(this, (HashMap.__proto__ || Object.getPrototypeOf(HashMap)).call(this));

    _this.map_ = new Map();
    return _this;
  }
  /**
   * @override
   */


  createClass(HashMap, [{
    key: 'get',
    value: function get$$1(key) {
      return this.map_.get(key) || null;
    }

    /**
     * @override
     */

  }, {
    key: 'put',
    value: function put(key, value) {
      this.map_.set(key, value);
      return value;
    }

    /**
     * @override
     */

  }, {
    key: 'values',
    value: function values() {
      var arrayList = new ArrayList();
      var it = this.map_.values();
      var o = it.next();
      while (!o.done) {
        arrayList.add(o.value);
        o = it.next();
      }
      return arrayList;
    }

    /**
     * @override
     */

  }, {
    key: 'entrySet',
    value: function entrySet() {
      var hashSet = new HashSet();
      this.map_.entries().forEach(function (entry) {
        return hashSet.add(entry);
      });
      return hashSet;
    }

    /**
     * @override
     */

  }, {
    key: 'size',
    value: function size() {
      return this.map_.size();
    }
  }]);
  return HashMap;
}(Map$1);

var PrecisionModel = function () {
  function PrecisionModel() {
    classCallCheck(this, PrecisionModel);

    this._modelType = null;
    this._scale = null;
    if (arguments.length === 0) {
      this._modelType = PrecisionModel.FLOATING;
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Type) {
        var modelType = arguments[0];
        this._modelType = modelType;
        if (modelType === PrecisionModel.FIXED) {
          this.setScale(1.0);
        }
      } else if (typeof arguments[0] === 'number') {
        var scale = arguments[0];
        this._modelType = PrecisionModel.FIXED;
        this.setScale(scale);
      } else if (arguments[0] instanceof PrecisionModel) {
        var pm = arguments[0];
        this._modelType = pm._modelType;
        this._scale = pm._scale;
      }
    }
  }

  createClass(PrecisionModel, [{
    key: 'equals',
    value: function equals(other) {
      if (!(other instanceof PrecisionModel)) {
        return false;
      }
      var otherPrecisionModel = other;
      return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var other = o;
      var sigDigits = this.getMaximumSignificantDigits();
      var otherSigDigits = other.getMaximumSignificantDigits();
      return new Integer(sigDigits).compareTo(new Integer(otherSigDigits));
    }
  }, {
    key: 'getScale',
    value: function getScale() {
      return this._scale;
    }
  }, {
    key: 'isFloating',
    value: function isFloating() {
      return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this._modelType;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var description = 'UNKNOWN';
      if (this._modelType === PrecisionModel.FLOATING) {
        description = 'Floating';
      } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
        description = 'Floating-Single';
      } else if (this._modelType === PrecisionModel.FIXED) {
        description = 'Fixed (Scale=' + this.getScale() + ')';
      }
      return description;
    }
  }, {
    key: 'makePrecise',
    value: function makePrecise() {
      if (typeof arguments[0] === 'number') {
        var val = arguments[0];
        if (Double.isNaN(val)) return val;
        if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
          var floatSingleVal = val;
          return floatSingleVal;
        }
        if (this._modelType === PrecisionModel.FIXED) {
          return Math.round(val * this._scale) / this._scale;
        }
        return val;
      } else if (arguments[0] instanceof Coordinate) {
        var coord = arguments[0];
        if (this._modelType === PrecisionModel.FLOATING) return null;
        coord.x = this.makePrecise(coord.x);
        coord.y = this.makePrecise(coord.y);
      }
    }
  }, {
    key: 'getMaximumSignificantDigits',
    value: function getMaximumSignificantDigits() {
      var maxSigDigits = 16;
      if (this._modelType === PrecisionModel.FLOATING) {
        maxSigDigits = 16;
      } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
        maxSigDigits = 6;
      } else if (this._modelType === PrecisionModel.FIXED) {
        maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
      }
      return maxSigDigits;
    }
  }, {
    key: 'setScale',
    value: function setScale(scale) {
      this._scale = Math.abs(scale);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Serializable, Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PrecisionModel;
    }
  }], [{
    key: 'mostPrecise',
    value: function mostPrecise(pm1, pm2) {
      if (pm1.compareTo(pm2) >= 0) return pm1;
      return pm2;
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return 7777263578777803835;
    }
  }, {
    key: 'maximumPreciseValue',
    get: function get$$1() {
      return 9007199254740992.0;
    }
  }]);
  return PrecisionModel;
}();

var Type = function () {
  function Type(name) {
    classCallCheck(this, Type);

    this._name = name || null;
    Type.nameToTypeMap.put(name, this);
  }

  createClass(Type, [{
    key: 'readResolve',
    value: function readResolve() {
      return Type.nameToTypeMap.get(this._name);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this._name;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Type;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return -5528602631731589822;
    }
  }, {
    key: 'nameToTypeMap',
    get: function get$$1() {
      return new HashMap();
    }
  }]);
  return Type;
}();

PrecisionModel.Type = Type;
PrecisionModel.FIXED = new Type('FIXED');
PrecisionModel.FLOATING = new Type('FLOATING');
PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');

var GeometryFactory = function () {
  function GeometryFactory() {
    classCallCheck(this, GeometryFactory);

    this._precisionModel = new PrecisionModel();
    this._SRID = 0;
    this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();

    if (arguments.length === 0) {} else if (arguments.length === 1) {
      if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
        this._coordinateSequenceFactory = arguments[0];
      } else if (arguments[0] instanceof PrecisionModel) {
        this._precisionModel = arguments[0];
      }
    } else if (arguments.length === 2) {
      this._precisionModel = arguments[0];
      this._SRID = arguments[1];
    } else if (arguments.length === 3) {
      this._precisionModel = arguments[0];
      this._SRID = arguments[1];
      this._coordinateSequenceFactory = arguments[2];
    }
  }

  createClass(GeometryFactory, [{
    key: 'toGeometry',
    value: function toGeometry(envelope) {
      if (envelope.isNull()) {
        return this.createPoint(null);
      }
      if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
        return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));
      }
      if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
        return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);
      }
      return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);
    }
  }, {
    key: 'createLineString',
    value: function createLineString(coordinates) {
      if (!coordinates) return new LineString(this.getCoordinateSequenceFactory().create([]), this);else if (coordinates instanceof Array) return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this);else if (hasInterface(coordinates, CoordinateSequence)) return new LineString(coordinates, this);
    }
  }, {
    key: 'createMultiLineString',
    value: function createMultiLineString() {
      if (arguments.length === 0) {
        return new MultiLineString(null, this);
      } else if (arguments.length === 1) {
        var lineStrings = arguments[0];
        return new MultiLineString(lineStrings, this);
      }
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry(geomList) {
      var geomClass = null;
      var isHeterogeneous = false;
      var hasGeometryCollection = false;
      for (var i = geomList.iterator(); i.hasNext();) {
        var geom = i.next();
        var partClass = geom.getClass();
        if (geomClass === null) {
          geomClass = partClass;
        }
        if (partClass !== geomClass) {
          isHeterogeneous = true;
        }
        if (geom.isGeometryCollectionOrDerived()) hasGeometryCollection = true;
      }
      if (geomClass === null) {
        return this.createGeometryCollection();
      }
      if (isHeterogeneous || hasGeometryCollection) {
        return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
      }
      var geom0 = geomList.iterator().next();
      var isCollection = geomList.size() > 1;
      if (isCollection) {
        if (geom0 instanceof Polygon) {
          return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
        } else if (geom0 instanceof LineString) {
          return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
        } else if (geom0 instanceof Point) {
          return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
        }
        Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());
      }
      return geom0;
    }
  }, {
    key: 'createMultiPointFromCoords',
    value: function createMultiPointFromCoords(coordinates) {
      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    }
  }, {
    key: 'createPoint',
    value: function createPoint() {
      if (arguments.length === 0) {
        return this.createPoint(this.getCoordinateSequenceFactory().create([]));
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Coordinate) {
          var coordinate = arguments[0];
          return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordinates = arguments[0];
          return new Point(coordinates, this);
        }
      }
    }
  }, {
    key: 'getCoordinateSequenceFactory',
    value: function getCoordinateSequenceFactory() {
      return this._coordinateSequenceFactory;
    }
  }, {
    key: 'createPolygon',
    value: function createPolygon() {
      if (arguments.length === 0) {
        return new Polygon(null, null, this);
      } else if (arguments.length === 1) {
        if (hasInterface(arguments[0], CoordinateSequence)) {
          var coordinates = arguments[0];
          return this.createPolygon(this.createLinearRing(coordinates));
        } else if (arguments[0] instanceof Array) {
          var _coordinates = arguments[0];
          return this.createPolygon(this.createLinearRing(_coordinates));
        } else if (arguments[0] instanceof LinearRing) {
          var shell = arguments[0];
          return this.createPolygon(shell, null);
        }
      } else if (arguments.length === 2) {
        var _shell = arguments[0];
        var holes = arguments[1];
        return new Polygon(_shell, holes, this);
      }
    }
  }, {
    key: 'getSRID',
    value: function getSRID() {
      return this._SRID;
    }
  }, {
    key: 'createGeometryCollection',
    value: function createGeometryCollection() {
      if (arguments.length === 0) {
        return new GeometryCollection(null, this);
      } else if (arguments.length === 1) {
        var geometries = arguments[0];
        return new GeometryCollection(geometries, this);
      }
    }
  }, {
    key: 'createGeometry',
    value: function createGeometry(g) {
      var editor = new GeometryEditor(this);
      return editor.edit(g, {
        edit: function edit() {
          if (arguments.length === 2) {
            var coordSeq = arguments[0];
            // const geometry = arguments[1]
            return this._coordinateSequenceFactory.create(coordSeq);
          }
        }
      });
    }
  }, {
    key: 'getPrecisionModel',
    value: function getPrecisionModel() {
      return this._precisionModel;
    }
  }, {
    key: 'createLinearRing',
    value: function createLinearRing() {
      if (arguments.length === 0) {
        return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var coordinates = arguments[0];
          return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var _coordinates2 = arguments[0];
          return new LinearRing(_coordinates2, this);
        }
      }
    }
  }, {
    key: 'createMultiPolygon',
    value: function createMultiPolygon() {
      if (arguments.length === 0) {
        return new MultiPolygon(null, this);
      } else if (arguments.length === 1) {
        var polygons = arguments[0];
        return new MultiPolygon(polygons, this);
      }
    }
  }, {
    key: 'createMultiPoint',
    value: function createMultiPoint() {
      if (arguments.length === 0) {
        return new MultiPoint(null, this);
      } else if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var point = arguments[0];
          return new MultiPoint(point, this);
        } else if (arguments[0] instanceof Array) {
          var coordinates = arguments[0];
          return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
        } else if (hasInterface(arguments[0], CoordinateSequence)) {
          var _coordinates3 = arguments[0];
          if (_coordinates3 === null) {
            return this.createMultiPoint(new Array(0).fill(null));
          }
          var points = new Array(_coordinates3.size()).fill(null);
          for (var i = 0; i < _coordinates3.size(); i++) {
            var ptSeq = this.getCoordinateSequenceFactory().create(1, _coordinates3.getDimension());
            CoordinateSequences.copy(_coordinates3, i, ptSeq, 0, 1);
            points[i] = this.createPoint(ptSeq);
          }
          return this.createMultiPoint(points);
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryFactory;
    }
  }], [{
    key: 'toMultiPolygonArray',
    value: function toMultiPolygonArray(multiPolygons) {
      var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
      return multiPolygons.toArray(multiPolygonArray);
    }
  }, {
    key: 'toGeometryArray',
    value: function toGeometryArray(geometries) {
      if (geometries === null) return null;
      var geometryArray = new Array(geometries.size()).fill(null);
      return geometries.toArray(geometryArray);
    }
  }, {
    key: 'getDefaultCoordinateSequenceFactory',
    value: function getDefaultCoordinateSequenceFactory() {
      return CoordinateArraySequenceFactory.instance();
    }
  }, {
    key: 'toMultiLineStringArray',
    value: function toMultiLineStringArray(multiLineStrings) {
      var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
      return multiLineStrings.toArray(multiLineStringArray);
    }
  }, {
    key: 'toLineStringArray',
    value: function toLineStringArray(lineStrings) {
      var lineStringArray = new Array(lineStrings.size()).fill(null);
      return lineStrings.toArray(lineStringArray);
    }
  }, {
    key: 'toMultiPointArray',
    value: function toMultiPointArray(multiPoints) {
      var multiPointArray = new Array(multiPoints.size()).fill(null);
      return multiPoints.toArray(multiPointArray);
    }
  }, {
    key: 'toLinearRingArray',
    value: function toLinearRingArray(linearRings) {
      var linearRingArray = new Array(linearRings.size()).fill(null);
      return linearRings.toArray(linearRingArray);
    }
  }, {
    key: 'toPointArray',
    value: function toPointArray(points) {
      var pointArray = new Array(points.size()).fill(null);
      return points.toArray(pointArray);
    }
  }, {
    key: 'toPolygonArray',
    value: function toPolygonArray(polygons) {
      var polygonArray = new Array(polygons.size()).fill(null);
      return polygons.toArray(polygonArray);
    }
  }, {
    key: 'createPointFromInternalCoord',
    value: function createPointFromInternalCoord(coord, exemplar) {
      exemplar.getPrecisionModel().makePrecise(coord);
      return exemplar.getFactory().createPoint(coord);
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return -6820524753094095635;
    }
  }]);
  return GeometryFactory;
}();

var geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

/**
 * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/**
 * Create a new parser for GeoJSON
 *
 * @param {GeometryFactory} geometryFactory
 * @return An instance of GeoJsonParser.
 * @constructor
 * @private
 */

var GeoJSONParser = function () {
  function GeoJSONParser(geometryFactory) {
    classCallCheck(this, GeoJSONParser);

    this.geometryFactory = geometryFactory || new GeometryFactory();
  }
  /**
   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
   *
   * @param {}
   *          A GeoJSON object.
   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
   * @private
   */


  createClass(GeoJSONParser, [{
    key: 'read',
    value: function read(json) {
      var obj = void 0;
      if (typeof json === 'string') {
        obj = JSON.parse(json);
      } else {
        obj = json;
      }

      var type = obj.type;

      if (!parse[type]) {
        throw new Error('Unknown GeoJSON type: ' + obj.type);
      }

      if (geometryTypes.indexOf(type) !== -1) {
        return parse[type].apply(this, [obj.coordinates]);
      } else if (type === 'GeometryCollection') {
        return parse[type].apply(this, [obj.geometries]);
      }

      // feature or feature collection
      return parse[type].apply(this, [obj]);
    }

    /**
     * Serialize a Geometry object into GeoJSON
     *
     * @param {Geometry}
     *          geometry A Geometry or array of Geometries.
     * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
     * @private
     */

  }, {
    key: 'write',
    value: function write(geometry) {
      var type = geometry.getGeometryType();

      if (!extract[type]) {
        throw new Error('Geometry is not supported');
      }

      return extract[type].apply(this, [geometry]);
    }
  }]);
  return GeoJSONParser;
}();

var parse = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function Feature(obj) {
    var feature = {};

    // copy features
    for (var key in obj) {
      feature[key] = obj[key];
    }

    // parse geometry
    if (obj.geometry) {
      var type = obj.geometry.type;
      if (!parse[type]) {
        throw new Error('Unknown GeoJSON type: ' + obj.type);
      }
      feature.geometry = this.read(obj.geometry);
    }

    // bbox
    if (obj.bbox) {
      feature.bbox = parse.bbox.apply(this, [obj.bbox]);
    }

    return feature;
  },

  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function FeatureCollection(obj) {
    var featureCollection = {};

    if (obj.features) {
      featureCollection.features = [];

      for (var i = 0; i < obj.features.length; ++i) {
        featureCollection.features.push(this.read(obj.features[i]));
      }
    }

    if (obj.bbox) {
      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);
    }

    return featureCollection;
  },

  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function coordinates(array) {
    var coordinates = [];
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i];
      coordinates.push(new Coordinate(sub[0], sub[1]));
    }
    return coordinates;
  },

  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function bbox(array) {
    return this.geometryFactory.createLinearRing([new Coordinate(array[0], array[1]), new Coordinate(array[2], array[1]), new Coordinate(array[2], array[3]), new Coordinate(array[0], array[3]), new Coordinate(array[0], array[1])]);
  },

  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function Point(array) {
    var coordinate = new Coordinate(array[0], array[1]);
    return this.geometryFactory.createPoint(coordinate);
  },

  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function MultiPoint(array) {
    var points = [];
    for (var i = 0; i < array.length; ++i) {
      points.push(parse.Point.apply(this, [array[i]]));
    }
    return this.geometryFactory.createMultiPoint(points);
  },

  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function LineString(array) {
    var coordinates = parse.coordinates.apply(this, [array]);
    return this.geometryFactory.createLineString(coordinates);
  },

  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function MultiLineString(array) {
    var lineStrings = [];
    for (var i = 0; i < array.length; ++i) {
      lineStrings.push(parse.LineString.apply(this, [array[i]]));
    }
    return this.geometryFactory.createMultiLineString(lineStrings);
  },

  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function Polygon(array) {
    var shellCoordinates = parse.coordinates.apply(this, [array[0]]);
    var shell = this.geometryFactory.createLinearRing(shellCoordinates);
    var holes = [];
    for (var i = 1; i < array.length; ++i) {
      var hole = array[i];
      var coordinates = parse.coordinates.apply(this, [hole]);
      var linearRing = this.geometryFactory.createLinearRing(coordinates);
      holes.push(linearRing);
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },

  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function MultiPolygon(array) {
    var polygons = [];
    for (var i = 0; i < array.length; ++i) {
      var polygon = array[i];
      polygons.push(parse.Polygon.apply(this, [polygon]));
    }
    return this.geometryFactory.createMultiPolygon(polygons);
  },

  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function GeometryCollection(array) {
    var geometries = [];
    for (var i = 0; i < array.length; ++i) {
      var geometry = array[i];
      geometries.push(this.read(geometry));
    }
    return this.geometryFactory.createGeometryCollection(geometries);
  }
};

var extract = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function coordinate(_coordinate) {
    return [_coordinate.x, _coordinate.y];
  },

  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function Point(point) {
    var array = extract.coordinate.apply(this, [point.getCoordinate()]);
    return {
      type: 'Point',
      coordinates: array
    };
  },

  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function MultiPoint(multipoint) {
    var array = [];
    for (var i = 0; i < multipoint._geometries.length; ++i) {
      var point = multipoint._geometries[i];
      var geoJson = extract.Point.apply(this, [point]);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPoint',
      coordinates: array
    };
  },

  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function LineString(linestring) {
    var array = [];
    var coordinates = linestring.getCoordinates();
    for (var i = 0; i < coordinates.length; ++i) {
      var coordinate = coordinates[i];
      array.push(extract.coordinate.apply(this, [coordinate]));
    }
    return {
      type: 'LineString',
      coordinates: array
    };
  },

  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function MultiLineString(multilinestring) {
    var array = [];
    for (var i = 0; i < multilinestring._geometries.length; ++i) {
      var linestring = multilinestring._geometries[i];
      var geoJson = extract.LineString.apply(this, [linestring]);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiLineString',
      coordinates: array
    };
  },

  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function Polygon(polygon) {
    var array = [];
    var shellGeoJson = extract.LineString.apply(this, [polygon._shell]);
    array.push(shellGeoJson.coordinates);
    for (var i = 0; i < polygon._holes.length; ++i) {
      var hole = polygon._holes[i];
      var holeGeoJson = extract.LineString.apply(this, [hole]);
      array.push(holeGeoJson.coordinates);
    }
    return {
      type: 'Polygon',
      coordinates: array
    };
  },

  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function MultiPolygon(multipolygon) {
    var array = [];
    for (var i = 0; i < multipolygon._geometries.length; ++i) {
      var polygon = multipolygon._geometries[i];
      var geoJson = extract.Polygon.apply(this, [polygon]);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPolygon',
      coordinates: array
    };
  },

  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function GeometryCollection(collection) {
    var array = [];
    for (var i = 0; i < collection._geometries.length; ++i) {
      var geometry = collection._geometries[i];
      var type = geometry.getGeometryType();
      array.push(extract[type].apply(this, [geometry]));
    }
    return {
      type: 'GeometryCollection',
      geometries: array
    };
  }
};

/**
 * Converts a geometry in GeoJSON to a {@link Geometry}.
 */

/**
 * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */

var GeoJSONReader = function () {
  function GeoJSONReader(geometryFactory) {
    classCallCheck(this, GeoJSONReader);

    this.geometryFactory = geometryFactory || new GeometryFactory();
    this.precisionModel = this.geometryFactory.getPrecisionModel();
    this.parser = new GeoJSONParser(this.geometryFactory);
  }
  /**
   * Reads a GeoJSON representation of a {@link Geometry}
   *
   * Will also parse GeoJSON Features/FeatureCollections as custom objects.
   *
   * @param {Object|String} geoJson a GeoJSON Object or String.
   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>
   * @memberof GeoJSONReader
   */


  createClass(GeoJSONReader, [{
    key: 'read',
    value: function read(geoJson) {
      var geometry = this.parser.read(geoJson);

      if (this.precisionModel.getType() === PrecisionModel.FIXED) {
        this.reducePrecision(geometry);
      }

      return geometry;
    }

    // NOTE: this is a hack

  }, {
    key: 'reducePrecision',
    value: function reducePrecision(geometry) {
      var i, len;

      if (geometry.coordinate) {
        this.precisionModel.makePrecise(geometry.coordinate);
      } else if (geometry.points) {
        for (i = 0, len = geometry.points.length; i < len; i++) {
          this.precisionModel.makePrecise(geometry.points[i]);
        }
      } else if (geometry.geometries) {
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          this.reducePrecision(geometry.geometries[i]);
        }
      }
    }
  }]);
  return GeoJSONReader;
}();

/**
 * @module GeoJSONWriter
 */

/**
 * Writes the GeoJSON representation of a {@link Geometry}. The
 * The GeoJSON format is defined <A
 * HREF="http://geojson.org/geojson-spec.html">here</A>.
 */

/**
 * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */

var GeoJSONWriter = function () {
  function GeoJSONWriter() {
    classCallCheck(this, GeoJSONWriter);

    this.parser = new GeoJSONParser(this.geometryFactory);
  }
  /**
   * Converts a <code>Geometry</code> to its GeoJSON representation.
   *
   * @param {Geometry}
   *          geometry a <code>Geometry</code> to process.
   * @return {Object} The GeoJSON representation of the Geometry.
   * @memberof GeoJSONWriter
   */


  createClass(GeoJSONWriter, [{
    key: 'write',
    value: function write(geometry) {
      return this.parser.write(geometry);
    }
  }]);
  return GeoJSONWriter;
}();

/* eslint-disable no-undef */

function p2c(p) {
  return [p.x, p.y];
}

/**
 * OpenLayers 3 Geometry parser and writer
 * @param {GeometryFactory} geometryFactory
 * @param {ol} olReference
 * @constructor
 */

var OL3Parser = function () {
  function OL3Parser(geometryFactory, olReference) {
    classCallCheck(this, OL3Parser);

    this.geometryFactory = geometryFactory || new GeometryFactory();
    this.ol = olReference || typeof ol !== 'undefined' && ol;
  }

  /**
   * @param geometry {ol.geom.Geometry}
   * @return {Geometry}
   * @memberof OL3Parser
   */


  createClass(OL3Parser, [{
    key: 'read',
    value: function read(geometry) {
      var ol = this.ol;
      if (geometry instanceof ol.geom.Point) {
        return this.convertFromPoint(geometry);
      } else if (geometry instanceof ol.geom.LineString) {
        return this.convertFromLineString(geometry);
      } else if (geometry instanceof ol.geom.LinearRing) {
        return this.convertFromLinearRing(geometry);
      } else if (geometry instanceof ol.geom.Polygon) {
        return this.convertFromPolygon(geometry);
      } else if (geometry instanceof ol.geom.MultiPoint) {
        return this.convertFromMultiPoint(geometry);
      } else if (geometry instanceof ol.geom.MultiLineString) {
        return this.convertFromMultiLineString(geometry);
      } else if (geometry instanceof ol.geom.MultiPolygon) {
        return this.convertFromMultiPolygon(geometry);
      } else if (geometry instanceof ol.geom.GeometryCollection) {
        return this.convertFromCollection(geometry);
      }
    }
  }, {
    key: 'convertFromPoint',
    value: function convertFromPoint(point) {
      var coordinates = point.getCoordinates();
      return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]));
    }
  }, {
    key: 'convertFromLineString',
    value: function convertFromLineString(lineString) {
      return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {
        return new Coordinate(coordinates[0], coordinates[1]);
      }));
    }
  }, {
    key: 'convertFromLinearRing',
    value: function convertFromLinearRing(linearRing) {
      return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {
        return new Coordinate(coordinates[0], coordinates[1]);
      }));
    }
  }, {
    key: 'convertFromPolygon',
    value: function convertFromPolygon(polygon) {
      var linearRings = polygon.getLinearRings();
      var shell = null;
      var holes = [];
      for (var i = 0; i < linearRings.length; i++) {
        var linearRing = this.convertFromLinearRing(linearRings[i]);
        if (i === 0) {
          shell = linearRing;
        } else {
          holes.push(linearRing);
        }
      }
      return this.geometryFactory.createPolygon(shell, holes);
    }
  }, {
    key: 'convertFromMultiPoint',
    value: function convertFromMultiPoint(multiPoint) {
      var points = multiPoint.getPoints().map(function (point) {
        return this.convertFromPoint(point);
      }, this);
      return this.geometryFactory.createMultiPoint(points);
    }
  }, {
    key: 'convertFromMultiLineString',
    value: function convertFromMultiLineString(multiLineString) {
      var lineStrings = multiLineString.getLineStrings().map(function (lineString) {
        return this.convertFromLineString(lineString);
      }, this);
      return this.geometryFactory.createMultiLineString(lineStrings);
    }
  }, {
    key: 'convertFromMultiPolygon',
    value: function convertFromMultiPolygon(multiPolygon) {
      var polygons = multiPolygon.getPolygons().map(function (polygon) {
        return this.convertFromPolygon(polygon);
      }, this);
      return this.geometryFactory.createMultiPolygon(polygons);
    }
  }, {
    key: 'convertFromCollection',
    value: function convertFromCollection(collection) {
      var geometries = collection.getGeometries().map(function (geometry) {
        return this.read(geometry);
      }, this);
      return this.geometryFactory.createGeometryCollection(geometries);
    }

    /**
     * @param geometry
     *          {Geometry}
     * @return {ol.geom.Geometry}
     * @memberof! OL3Parser
     */

  }, {
    key: 'write',
    value: function write(geometry) {
      if (geometry.getGeometryType() === 'Point') {
        return this.convertToPoint(geometry.getCoordinate());
      } else if (geometry.getGeometryType() === 'LineString') {
        return this.convertToLineString(geometry);
      } else if (geometry.getGeometryType() === 'LinearRing') {
        return this.convertToLinearRing(geometry);
      } else if (geometry.getGeometryType() === 'Polygon') {
        return this.convertToPolygon(geometry);
      } else if (geometry.getGeometryType() === 'MultiPoint') {
        return this.convertToMultiPoint(geometry);
      } else if (geometry.getGeometryType() === 'MultiLineString') {
        return this.convertToMultiLineString(geometry);
      } else if (geometry.getGeometryType() === 'MultiPolygon') {
        return this.convertToMultiPolygon(geometry);
      } else if (geometry.getGeometryType() === 'GeometryCollection') {
        return this.convertToCollection(geometry);
      }
    }
  }, {
    key: 'convertToPoint',
    value: function convertToPoint(coordinate) {
      return new this.ol.geom.Point([coordinate.x, coordinate.y]);
    }
  }, {
    key: 'convertToLineString',
    value: function convertToLineString(lineString) {
      var points = lineString.points.coordinates.map(p2c);
      return new this.ol.geom.LineString(points);
    }
  }, {
    key: 'convertToLinearRing',
    value: function convertToLinearRing(linearRing) {
      var points = linearRing.points.coordinates.map(p2c);
      return new this.ol.geom.LinearRing(points);
    }
  }, {
    key: 'convertToPolygon',
    value: function convertToPolygon(polygon) {
      var rings = [polygon.shell.points.coordinates.map(p2c)];
      for (var i = 0; i < polygon.holes.length; i++) {
        rings.push(polygon.holes[i].points.coordinates.map(p2c));
      }
      return new this.ol.geom.Polygon(rings);
    }
  }, {
    key: 'convertToMultiPoint',
    value: function convertToMultiPoint(multiPoint) {
      return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));
    }
  }, {
    key: 'convertToMultiLineString',
    value: function convertToMultiLineString(multiLineString) {
      var lineStrings = [];
      for (var i = 0; i < multiLineString.geometries.length; i++) {
        lineStrings.push(this.convertToLineString(multiLineString.geometries[i]).getCoordinates());
      }
      return new this.ol.geom.MultiLineString(lineStrings);
    }
  }, {
    key: 'convertToMultiPolygon',
    value: function convertToMultiPolygon(multiPolygon) {
      var polygons = [];
      for (var i = 0; i < multiPolygon.geometries.length; i++) {
        polygons.push(this.convertToPolygon(multiPolygon.geometries[i]).getCoordinates());
      }
      return new this.ol.geom.MultiPolygon(polygons);
    }
  }, {
    key: 'convertToCollection',
    value: function convertToCollection(geometryCollection) {
      var geometries = [];
      for (var i = 0; i < geometryCollection.geometries.length; i++) {
        var geometry = geometryCollection.geometries[i];
        geometries.push(this.write(geometry));
      }
      return new this.ol.geom.GeometryCollection(geometries);
    }
  }]);
  return OL3Parser;
}();

/**
 * Converts a geometry in Well-Known Text format to a {@link Geometry}.
 * <p>
 * <code>WKTReader</code> supports extracting <code>Geometry</code> objects
 * from either {@link Reader}s or {@link String}s. This allows it to function
 * as a parser to read <code>Geometry</code> objects from text blocks embedded
 * in other data formats (e.g. XML).
 */

/**
 * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */

var WKTReader = function () {
  function WKTReader(geometryFactory) {
    classCallCheck(this, WKTReader);

    this.geometryFactory = geometryFactory || new GeometryFactory();
    this.precisionModel = this.geometryFactory.getPrecisionModel();
    this.parser = new WKTParser(this.geometryFactory);
  }
  /**
   * Reads a Well-Known Text representation of a {@link Geometry}
   *
   * @param {string}
   *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features
   *          Specification).
   * @return {Geometry} a <code>Geometry</code> read from
   *         <code>string.</code>
   * @memberof WKTReader
   */


  createClass(WKTReader, [{
    key: 'read',
    value: function read(wkt) {
      var geometry = this.parser.read(wkt);

      // TODO: port and use GeometryPrecisionReducer, this is a hack
      if (this.precisionModel.getType() === PrecisionModel.FIXED) {
        this.reducePrecision(geometry);
      }

      return geometry;
    }
  }, {
    key: 'reducePrecision',
    value: function reducePrecision(geometry) {
      if (geometry.coordinate) {
        this.precisionModel.makePrecise(geometry.coordinate);
      } else if (geometry._points) {
        for (var i = 0, len = geometry._points._coordinates.length; i < len; i++) {
          this.precisionModel.makePrecise(geometry._points._coordinates[i]);
        }
      } else if (geometry._geometries) {
        for (var _i = 0, _len = geometry._geometries.length; _i < _len; _i++) {
          this.reducePrecision(geometry._geometries[_i]);
        }
      }
    }
  }]);
  return WKTReader;
}();

// io

var Position = function () {
  function Position() {
    classCallCheck(this, Position);
  }

  createClass(Position, [{
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return Position;
    }
  }], [{
    key: "opposite",
    value: function opposite(position) {
      if (position === Position.LEFT) return Position.RIGHT;
      if (position === Position.RIGHT) return Position.LEFT;
      return position;
    }
  }, {
    key: "ON",
    get: function get$$1() {
      return 0;
    }
  }, {
    key: "LEFT",
    get: function get$$1() {
      return 1;
    }
  }, {
    key: "RIGHT",
    get: function get$$1() {
      return 2;
    }
  }]);
  return Position;
}();

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function EmptyStackException(message) {
  this.message = message || '';
}
EmptyStackException.prototype = new Error();

/**
 * @type {string}
 */
EmptyStackException.prototype.name = 'EmptyStackException';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html
 *
 * @extends {List}
 * @constructor
 * @private
 */
function Stack() {
  /**
   * @type {Array}
   * @private
   */
  this.array_ = [];
}
Stack.prototype = new List();

/**
 * @override
 */
Stack.prototype.add = function (e) {
  this.array_.push(e);
  return true;
};

/**
 * @override
 */
Stack.prototype.get = function (index) {
  if (index < 0 || index >= this.size()) {
    throw new Error();
  }

  return this.array_[index];
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.push = function (e) {
  this.array_.push(e);
  return e;
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.pop = function (e) {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }

  return this.array_.pop();
};

/**
 * Looks at the object at the top of this stack without removing it from the
 * stack.
 * @return {Object}
 */
Stack.prototype.peek = function () {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }

  return this.array_[this.array_.length - 1];
};

/**
 * Tests if this stack is empty.
 * @return {boolean} true if and only if this stack contains no items; false
 *         otherwise.
 */
Stack.prototype.empty = function () {
  if (this.array_.length === 0) {
    return true;
  } else {
    return false;
  }
};

/**
 * @return {boolean}
 */
Stack.prototype.isEmpty = function () {
  return this.empty();
};

/**
 * Returns the 1-based position where an object is on this stack. If the object
 * o occurs as an item in this stack, this method returns the distance from the
 * top of the stack of the occurrence nearest the top of the stack; the topmost
 * item on the stack is considered to be at distance 1. The equals method is
 * used to compare o to the items in this stack.
 *
 * NOTE: does not currently actually use equals. (=== is used)
 *
 * @param {Object} o
 * @return {number} the 1-based position from the top of the stack where the
 *         object is located; the return value -1 indicates that the object is
 *         not on the stack.
 */
Stack.prototype.search = function (o) {
  return this.array_.indexOf(o);
};

/**
 * @return {number}
 * @export
 */
Stack.prototype.size = function () {
  return this.array_.length;
};

/**
 * @return {Array}
 */
Stack.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};

var RightmostEdgeFinder = function () {
  function RightmostEdgeFinder() {
    classCallCheck(this, RightmostEdgeFinder);

    this._minIndex = -1;
    this._minCoord = null;
    this._minDe = null;
    this._orientedDe = null;
  }

  createClass(RightmostEdgeFinder, [{
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this._minCoord;
    }
  }, {
    key: 'getRightmostSide',
    value: function getRightmostSide(de, index) {
      var side = this.getRightmostSideOfSegment(de, index);
      if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);
      if (side < 0) {
        this._minCoord = null;
        this.checkForRightmostCoordinate(de);
      }
      return side;
    }
  }, {
    key: 'findRightmostEdgeAtVertex',
    value: function findRightmostEdgeAtVertex() {
      var pts = this._minDe.getEdge().getCoordinates();
      Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');
      var pPrev = pts[this._minIndex - 1];
      var pNext = pts[this._minIndex + 1];
      var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);
      var usePrev = false;
      if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {
        usePrev = true;
      } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {
        usePrev = true;
      }
      if (usePrev) {
        this._minIndex = this._minIndex - 1;
      }
    }
  }, {
    key: 'getRightmostSideOfSegment',
    value: function getRightmostSideOfSegment(de, i) {
      var e = de.getEdge();
      var coord = e.getCoordinates();
      if (i < 0 || i + 1 >= coord.length) return -1;
      if (coord[i].y === coord[i + 1].y) return -1;
      var pos = Position.LEFT;
      if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;
      return pos;
    }
  }, {
    key: 'getEdge',
    value: function getEdge() {
      return this._orientedDe;
    }
  }, {
    key: 'checkForRightmostCoordinate',
    value: function checkForRightmostCoordinate(de) {
      var coord = de.getEdge().getCoordinates();
      for (var i = 0; i < coord.length - 1; i++) {
        if (this._minCoord === null || coord[i].x > this._minCoord.x) {
          this._minDe = de;
          this._minIndex = i;
          this._minCoord = coord[i];
        }
      }
    }
  }, {
    key: 'findRightmostEdgeAtNode',
    value: function findRightmostEdgeAtNode() {
      var node = this._minDe.getNode();
      var star = node.getEdges();
      this._minDe = star.getRightmostEdge();
      if (!this._minDe.isForward()) {
        this._minDe = this._minDe.getSym();
        this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
      }
    }
  }, {
    key: 'findEdge',
    value: function findEdge(dirEdgeList) {
      for (var i = dirEdgeList.iterator(); i.hasNext();) {
        var de = i.next();
        if (!de.isForward()) continue;
        this.checkForRightmostCoordinate(de);
      }
      Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');
      if (this._minIndex === 0) {
        this.findRightmostEdgeAtNode();
      } else {
        this.findRightmostEdgeAtVertex();
      }
      this._orientedDe = this._minDe;
      var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
      if (rightmostSide === Position.LEFT) {
        this._orientedDe = this._minDe.getSym();
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return RightmostEdgeFinder;
    }
  }]);
  return RightmostEdgeFinder;
}();

var TopologyException = function (_RuntimeException) {
  inherits(TopologyException, _RuntimeException);

  function TopologyException(msg, pt) {
    classCallCheck(this, TopologyException);

    var _this = possibleConstructorReturn(this, (TopologyException.__proto__ || Object.getPrototypeOf(TopologyException)).call(this, TopologyException.msgWithCoord(msg, pt)));

    _this.pt = pt ? new Coordinate(pt) : null;
    _this.name = 'TopologyException';
    return _this;
  }

  createClass(TopologyException, [{
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this.pt;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return TopologyException;
    }
  }], [{
    key: 'msgWithCoord',
    value: function msgWithCoord(msg, pt) {
      if (!pt) return msg + ' [ ' + pt + ' ]';
      return msg;
    }
  }]);
  return TopologyException;
}(RuntimeException);

var LinkedList = function () {
  function LinkedList() {
    classCallCheck(this, LinkedList);

    this.array_ = [];
  }

  createClass(LinkedList, [{
    key: "addLast",
    value: function addLast(e) {
      this.array_.push(e);
    }
  }, {
    key: "removeFirst",
    value: function removeFirst() {
      return this.array_.shift();
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.array_.length === 0;
    }
  }]);
  return LinkedList;
}();

var BufferSubgraph = function () {
  function BufferSubgraph() {
    classCallCheck(this, BufferSubgraph);

    this._finder = null;
    this._dirEdgeList = new ArrayList();
    this._nodes = new ArrayList();
    this._rightMostCoord = null;
    this._env = null;
    this._finder = new RightmostEdgeFinder();
  }

  createClass(BufferSubgraph, [{
    key: 'clearVisitedEdges',
    value: function clearVisitedEdges() {
      for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
        var de = it.next();
        de.setVisited(false);
      }
    }
  }, {
    key: 'getRightmostCoordinate',
    value: function getRightmostCoordinate() {
      return this._rightMostCoord;
    }
  }, {
    key: 'computeNodeDepth',
    value: function computeNodeDepth(n) {
      var startEdge = null;
      for (var i = n.getEdges().iterator(); i.hasNext();) {
        var de = i.next();
        if (de.isVisited() || de.getSym().isVisited()) {
          startEdge = de;
          break;
        }
      }
      if (startEdge === null) throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate());
      n.getEdges().computeDepths(startEdge);
      for (var _i = n.getEdges().iterator(); _i.hasNext();) {
        var _de = _i.next();
        _de.setVisited(true);
        this.copySymDepths(_de);
      }
    }
  }, {
    key: 'computeDepth',
    value: function computeDepth(outsideDepth) {
      this.clearVisitedEdges();
      var de = this._finder.getEdge();
      // const n = de.getNode()
      // const label = de.getLabel()
      de.setEdgeDepths(Position.RIGHT, outsideDepth);
      this.copySymDepths(de);
      this.computeDepths(de);
    }
  }, {
    key: 'create',
    value: function create(node) {
      this.addReachable(node);
      this._finder.findEdge(this._dirEdgeList);
      this._rightMostCoord = this._finder.getCoordinate();
    }
  }, {
    key: 'findResultEdges',
    value: function findResultEdges() {
      for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
        var de = it.next();
        if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
          de.setInResult(true);
        }
      }
    }
  }, {
    key: 'computeDepths',
    value: function computeDepths(startEdge) {
      var nodesVisited = new HashSet();
      var nodeQueue = new LinkedList();
      var startNode = startEdge.getNode();
      nodeQueue.addLast(startNode);
      nodesVisited.add(startNode);
      startEdge.setVisited(true);
      while (!nodeQueue.isEmpty()) {
        var n = nodeQueue.removeFirst();
        nodesVisited.add(n);
        this.computeNodeDepth(n);
        for (var i = n.getEdges().iterator(); i.hasNext();) {
          var de = i.next();
          var sym = de.getSym();
          if (sym.isVisited()) continue;
          var adjNode = sym.getNode();
          if (!nodesVisited.contains(adjNode)) {
            nodeQueue.addLast(adjNode);
            nodesVisited.add(adjNode);
          }
        }
      }
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var graph = o;
      if (this._rightMostCoord.x < graph._rightMostCoord.x) {
        return -1;
      }
      if (this._rightMostCoord.x > graph._rightMostCoord.x) {
        return 1;
      }
      return 0;
    }
  }, {
    key: 'getEnvelope',
    value: function getEnvelope() {
      if (this._env === null) {
        var edgeEnv = new Envelope();
        for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
          var dirEdge = it.next();
          var pts = dirEdge.getEdge().getCoordinates();
          for (var i = 0; i < pts.length - 1; i++) {
            edgeEnv.expandToInclude(pts[i]);
          }
        }
        this._env = edgeEnv;
      }
      return this._env;
    }
  }, {
    key: 'addReachable',
    value: function addReachable(startNode) {
      var nodeStack = new Stack();
      nodeStack.add(startNode);
      while (!nodeStack.empty()) {
        var node = nodeStack.pop();
        this.add(node, nodeStack);
      }
    }
  }, {
    key: 'copySymDepths',
    value: function copySymDepths(de) {
      var sym = de.getSym();
      sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
      sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
    }
  }, {
    key: 'add',
    value: function add(node, nodeStack) {
      node.setVisited(true);
      this._nodes.add(node);
      for (var i = node.getEdges().iterator(); i.hasNext();) {
        var de = i.next();
        this._dirEdgeList.add(de);
        var sym = de.getSym();
        var symNode = sym.getNode();
        if (!symNode.isVisited()) nodeStack.push(symNode);
      }
    }
  }, {
    key: 'getNodes',
    value: function getNodes() {
      return this._nodes;
    }
  }, {
    key: 'getDirectedEdges',
    value: function getDirectedEdges() {
      return this._dirEdgeList;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BufferSubgraph;
    }
  }]);
  return BufferSubgraph;
}();

var TopologyLocation = function () {
  function TopologyLocation() {
    classCallCheck(this, TopologyLocation);

    this.location = null;
    if (arguments.length === 1) {
      if (arguments[0] instanceof Array) {
        var location = arguments[0];
        this.init(location.length);
      } else if (Number.isInteger(arguments[0])) {
        var on = arguments[0];
        this.init(1);
        this.location[Position.ON] = on;
      } else if (arguments[0] instanceof TopologyLocation) {
        var gl = arguments[0];
        this.init(gl.location.length);
        if (gl !== null) {
          for (var i = 0; i < this.location.length; i++) {
            this.location[i] = gl.location[i];
          }
        }
      }
    } else if (arguments.length === 3) {
      var _on = arguments[0];
      var left = arguments[1];
      var right = arguments[2];
      this.init(3);
      this.location[Position.ON] = _on;
      this.location[Position.LEFT] = left;
      this.location[Position.RIGHT] = right;
    }
  }

  createClass(TopologyLocation, [{
    key: 'setAllLocations',
    value: function setAllLocations(locValue) {
      for (var i = 0; i < this.location.length; i++) {
        this.location[i] = locValue;
      }
    }
  }, {
    key: 'isNull',
    value: function isNull() {
      for (var i = 0; i < this.location.length; i++) {
        if (this.location[i] !== Location.NONE) return false;
      }
      return true;
    }
  }, {
    key: 'setAllLocationsIfNull',
    value: function setAllLocationsIfNull(locValue) {
      for (var i = 0; i < this.location.length; i++) {
        if (this.location[i] === Location.NONE) this.location[i] = locValue;
      }
    }
  }, {
    key: 'isLine',
    value: function isLine() {
      return this.location.length === 1;
    }
  }, {
    key: 'merge',
    value: function merge(gl) {
      if (gl.location.length > this.location.length) {
        var newLoc = new Array(3).fill(null);
        newLoc[Position.ON] = this.location[Position.ON];
        newLoc[Position.LEFT] = Location.NONE;
        newLoc[Position.RIGHT] = Location.NONE;
        this.location = newLoc;
      }
      for (var i = 0; i < this.location.length; i++) {
        if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];
      }
    }
  }, {
    key: 'getLocations',
    value: function getLocations() {
      return this.location;
    }
  }, {
    key: 'flip',
    value: function flip() {
      if (this.location.length <= 1) return null;
      var temp = this.location[Position.LEFT];
      this.location[Position.LEFT] = this.location[Position.RIGHT];
      this.location[Position.RIGHT] = temp;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var buf = new StringBuffer();
      if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));
      buf.append(Location.toLocationSymbol(this.location[Position.ON]));
      if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));
      return buf.toString();
    }
  }, {
    key: 'setLocations',
    value: function setLocations(on, left, right) {
      this.location[Position.ON] = on;
      this.location[Position.LEFT] = left;
      this.location[Position.RIGHT] = right;
    }
  }, {
    key: 'get',
    value: function get$$1(posIndex) {
      if (posIndex < this.location.length) return this.location[posIndex];
      return Location.NONE;
    }
  }, {
    key: 'isArea',
    value: function isArea() {
      return this.location.length > 1;
    }
  }, {
    key: 'isAnyNull',
    value: function isAnyNull() {
      for (var i = 0; i < this.location.length; i++) {
        if (this.location[i] === Location.NONE) return true;
      }
      return false;
    }
  }, {
    key: 'setLocation',
    value: function setLocation() {
      if (arguments.length === 1) {
        var locValue = arguments[0];
        this.setLocation(Position.ON, locValue);
      } else if (arguments.length === 2) {
        var locIndex = arguments[0];
        var _locValue = arguments[1];
        this.location[locIndex] = _locValue;
      }
    }
  }, {
    key: 'init',
    value: function init(size) {
      this.location = new Array(size).fill(null);
      this.setAllLocations(Location.NONE);
    }
  }, {
    key: 'isEqualOnSide',
    value: function isEqualOnSide(le, locIndex) {
      return this.location[locIndex] === le.location[locIndex];
    }
  }, {
    key: 'allPositionsEqual',
    value: function allPositionsEqual(loc) {
      for (var i = 0; i < this.location.length; i++) {
        if (this.location[i] !== loc) return false;
      }
      return true;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return TopologyLocation;
    }
  }]);
  return TopologyLocation;
}();

var Label = function () {
  function Label() {
    classCallCheck(this, Label);

    this.elt = new Array(2).fill(null);
    if (arguments.length === 1) {
      if (Number.isInteger(arguments[0])) {
        var onLoc = arguments[0];
        this.elt[0] = new TopologyLocation(onLoc);
        this.elt[1] = new TopologyLocation(onLoc);
      } else if (arguments[0] instanceof Label) {
        var lbl = arguments[0];
        this.elt[0] = new TopologyLocation(lbl.elt[0]);
        this.elt[1] = new TopologyLocation(lbl.elt[1]);
      }
    } else if (arguments.length === 2) {
      var geomIndex = arguments[0];
      var _onLoc = arguments[1];
      this.elt[0] = new TopologyLocation(Location.NONE);
      this.elt[1] = new TopologyLocation(Location.NONE);
      this.elt[geomIndex].setLocation(_onLoc);
    } else if (arguments.length === 3) {
      var _onLoc2 = arguments[0];
      var leftLoc = arguments[1];
      var rightLoc = arguments[2];
      this.elt[0] = new TopologyLocation(_onLoc2, leftLoc, rightLoc);
      this.elt[1] = new TopologyLocation(_onLoc2, leftLoc, rightLoc);
    } else if (arguments.length === 4) {
      var _geomIndex = arguments[0];
      var _onLoc3 = arguments[1];
      var _leftLoc = arguments[2];
      var _rightLoc = arguments[3];
      this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
      this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
      this.elt[_geomIndex].setLocations(_onLoc3, _leftLoc, _rightLoc);
    }
  }

  createClass(Label, [{
    key: 'getGeometryCount',
    value: function getGeometryCount() {
      var count = 0;
      if (!this.elt[0].isNull()) count++;
      if (!this.elt[1].isNull()) count++;
      return count;
    }
  }, {
    key: 'setAllLocations',
    value: function setAllLocations(geomIndex, location) {
      this.elt[geomIndex].setAllLocations(location);
    }
  }, {
    key: 'isNull',
    value: function isNull(geomIndex) {
      return this.elt[geomIndex].isNull();
    }
  }, {
    key: 'setAllLocationsIfNull',
    value: function setAllLocationsIfNull() {
      if (arguments.length === 1) {
        var location = arguments[0];
        this.setAllLocationsIfNull(0, location);
        this.setAllLocationsIfNull(1, location);
      } else if (arguments.length === 2) {
        var geomIndex = arguments[0];
        var _location = arguments[1];
        this.elt[geomIndex].setAllLocationsIfNull(_location);
      }
    }
  }, {
    key: 'isLine',
    value: function isLine(geomIndex) {
      return this.elt[geomIndex].isLine();
    }
  }, {
    key: 'merge',
    value: function merge(lbl) {
      for (var i = 0; i < 2; i++) {
        if (this.elt[i] === null && lbl.elt[i] !== null) {
          this.elt[i] = new TopologyLocation(lbl.elt[i]);
        } else {
          this.elt[i].merge(lbl.elt[i]);
        }
      }
    }
  }, {
    key: 'flip',
    value: function flip() {
      this.elt[0].flip();
      this.elt[1].flip();
    }
  }, {
    key: 'getLocation',
    value: function getLocation() {
      if (arguments.length === 1) {
        var geomIndex = arguments[0];
        return this.elt[geomIndex].get(Position.ON);
      } else if (arguments.length === 2) {
        var _geomIndex2 = arguments[0];
        var posIndex = arguments[1];
        return this.elt[_geomIndex2].get(posIndex);
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      var buf = new StringBuffer();
      if (this.elt[0] !== null) {
        buf.append('A:');
        buf.append(this.elt[0].toString());
      }
      if (this.elt[1] !== null) {
        buf.append(' B:');
        buf.append(this.elt[1].toString());
      }
      return buf.toString();
    }
  }, {
    key: 'isArea',
    value: function isArea() {
      if (arguments.length === 0) {
        return this.elt[0].isArea() || this.elt[1].isArea();
      } else if (arguments.length === 1) {
        var geomIndex = arguments[0];
        return this.elt[geomIndex].isArea();
      }
    }
  }, {
    key: 'isAnyNull',
    value: function isAnyNull(geomIndex) {
      return this.elt[geomIndex].isAnyNull();
    }
  }, {
    key: 'setLocation',
    value: function setLocation() {
      if (arguments.length === 2) {
        var geomIndex = arguments[0];
        var location = arguments[1];
        this.elt[geomIndex].setLocation(Position.ON, location);
      } else if (arguments.length === 3) {
        var _geomIndex3 = arguments[0];
        var posIndex = arguments[1];
        var _location2 = arguments[2];
        this.elt[_geomIndex3].setLocation(posIndex, _location2);
      }
    }
  }, {
    key: 'isEqualOnSide',
    value: function isEqualOnSide(lbl, side) {
      return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
    }
  }, {
    key: 'allPositionsEqual',
    value: function allPositionsEqual(geomIndex, loc) {
      return this.elt[geomIndex].allPositionsEqual(loc);
    }
  }, {
    key: 'toLine',
    value: function toLine(geomIndex) {
      if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Label;
    }
  }], [{
    key: 'toLineLabel',
    value: function toLineLabel(label) {
      var lineLabel = new Label(Location.NONE);
      for (var i = 0; i < 2; i++) {
        lineLabel.setLocation(i, label.getLocation(i));
      }
      return lineLabel;
    }
  }]);
  return Label;
}();

var EdgeRing = function () {
  function EdgeRing() {
    classCallCheck(this, EdgeRing);

    this._startDe = null;
    this._maxNodeDegree = -1;
    this._edges = new ArrayList();
    this._pts = new ArrayList();
    this._label = new Label(Location.NONE);
    this._ring = null;
    this._isHole = null;
    this._shell = null;
    this._holes = new ArrayList();
    this._geometryFactory = null;
    var start = arguments[0];
    var geometryFactory = arguments[1];
    this._geometryFactory = geometryFactory;
    this.computePoints(start);
    this.computeRing();
  }

  createClass(EdgeRing, [{
    key: 'computeRing',
    value: function computeRing() {
      if (this._ring !== null) return null;
      var coord = new Array(this._pts.size()).fill(null);
      for (var i = 0; i < this._pts.size(); i++) {
        coord[i] = this._pts.get(i);
      }
      this._ring = this._geometryFactory.createLinearRing(coord);
      this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());
    }
  }, {
    key: 'isIsolated',
    value: function isIsolated() {
      return this._label.getGeometryCount() === 1;
    }
  }, {
    key: 'computePoints',
    value: function computePoints(start) {
      this._startDe = start;
      var de = start;
      var isFirstEdge = true;
      do {
        if (de === null) throw new TopologyException('Found null DirectedEdge');
        if (de.getEdgeRing() === this) throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate());
        this._edges.add(de);
        var label = de.getLabel();
        Assert.isTrue(label.isArea());
        this.mergeLabel(label);
        this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
        isFirstEdge = false;
        this.setEdgeRing(de, this);
        de = this.getNext(de);
      } while (de !== this._startDe);
    }
  }, {
    key: 'getLinearRing',
    value: function getLinearRing() {
      return this._ring;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate(i) {
      return this._pts.get(i);
    }
  }, {
    key: 'computeMaxNodeDegree',
    value: function computeMaxNodeDegree() {
      this._maxNodeDegree = 0;
      var de = this._startDe;
      do {
        var node = de.getNode();
        var degree = node.getEdges().getOutgoingDegree(this);
        if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;
        de = this.getNext(de);
      } while (de !== this._startDe);
      this._maxNodeDegree *= 2;
    }
  }, {
    key: 'addPoints',
    value: function addPoints(edge, isForward, isFirstEdge) {
      var edgePts = edge.getCoordinates();
      if (isForward) {
        var startIndex = 1;
        if (isFirstEdge) startIndex = 0;
        for (var i = startIndex; i < edgePts.length; i++) {
          this._pts.add(edgePts[i]);
        }
      } else {
        var _startIndex = edgePts.length - 2;
        if (isFirstEdge) _startIndex = edgePts.length - 1;
        for (var _i = _startIndex; _i >= 0; _i--) {
          this._pts.add(edgePts[_i]);
        }
      }
    }
  }, {
    key: 'isHole',
    value: function isHole() {
      return this._isHole;
    }
  }, {
    key: 'setInResult',
    value: function setInResult() {
      var de = this._startDe;
      do {
        de.getEdge().setInResult(true);
        de = de.getNext();
      } while (de !== this._startDe);
    }
  }, {
    key: 'containsPoint',
    value: function containsPoint(p) {
      var shell = this.getLinearRing();
      var env = shell.getEnvelopeInternal();
      if (!env.contains(p)) return false;
      if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) return false;
      for (var i = this._holes.iterator(); i.hasNext();) {
        var hole = i.next();
        if (hole.containsPoint(p)) return false;
      }
      return true;
    }
  }, {
    key: 'addHole',
    value: function addHole(ring) {
      this._holes.add(ring);
    }
  }, {
    key: 'isShell',
    value: function isShell() {
      return this._shell === null;
    }
  }, {
    key: 'getLabel',
    value: function getLabel() {
      return this._label;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this._edges;
    }
  }, {
    key: 'getMaxNodeDegree',
    value: function getMaxNodeDegree() {
      if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();
      return this._maxNodeDegree;
    }
  }, {
    key: 'getShell',
    value: function getShell() {
      return this._shell;
    }
  }, {
    key: 'mergeLabel',
    value: function mergeLabel() {
      if (arguments.length === 1) {
        var deLabel = arguments[0];
        this.mergeLabel(deLabel, 0);
        this.mergeLabel(deLabel, 1);
      } else if (arguments.length === 2) {
        var _deLabel = arguments[0];
        var geomIndex = arguments[1];
        var loc = _deLabel.getLocation(geomIndex, Position.RIGHT);
        if (loc === Location.NONE) return null;
        if (this._label.getLocation(geomIndex) === Location.NONE) {
          this._label.setLocation(geomIndex, loc);
          return null;
        }
      }
    }
  }, {
    key: 'setShell',
    value: function setShell(shell) {
      this._shell = shell;
      if (shell !== null) shell.addHole(this);
    }
  }, {
    key: 'toPolygon',
    value: function toPolygon(geometryFactory) {
      var holeLR = new Array(this._holes.size()).fill(null);
      for (var i = 0; i < this._holes.size(); i++) {
        holeLR[i] = this._holes.get(i).getLinearRing();
      }
      var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
      return poly;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeRing;
    }
  }]);
  return EdgeRing;
}();

var MinimalEdgeRing = function (_EdgeRing) {
  inherits(MinimalEdgeRing, _EdgeRing);

  function MinimalEdgeRing() {
    classCallCheck(this, MinimalEdgeRing);

    var start = arguments[0];
    var geometryFactory = arguments[1];
    return possibleConstructorReturn(this, (MinimalEdgeRing.__proto__ || Object.getPrototypeOf(MinimalEdgeRing)).call(this, start, geometryFactory));
  }

  createClass(MinimalEdgeRing, [{
    key: 'setEdgeRing',
    value: function setEdgeRing(de, er) {
      de.setMinEdgeRing(er);
    }
  }, {
    key: 'getNext',
    value: function getNext(de) {
      return de.getNextMin();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MinimalEdgeRing;
    }
  }]);
  return MinimalEdgeRing;
}(EdgeRing);

var MaximalEdgeRing = function (_EdgeRing) {
  inherits(MaximalEdgeRing, _EdgeRing);

  function MaximalEdgeRing() {
    classCallCheck(this, MaximalEdgeRing);

    var start = arguments[0];
    var geometryFactory = arguments[1];
    return possibleConstructorReturn(this, (MaximalEdgeRing.__proto__ || Object.getPrototypeOf(MaximalEdgeRing)).call(this, start, geometryFactory));
  }

  createClass(MaximalEdgeRing, [{
    key: 'buildMinimalRings',
    value: function buildMinimalRings() {
      var minEdgeRings = new ArrayList();
      var de = this._startDe;
      do {
        if (de.getMinEdgeRing() === null) {
          var minEr = new MinimalEdgeRing(de, this._geometryFactory);
          minEdgeRings.add(minEr);
        }
        de = de.getNext();
      } while (de !== this._startDe);
      return minEdgeRings;
    }
  }, {
    key: 'setEdgeRing',
    value: function setEdgeRing(de, er) {
      de.setEdgeRing(er);
    }
  }, {
    key: 'linkDirectedEdgesForMinimalEdgeRings',
    value: function linkDirectedEdgesForMinimalEdgeRings() {
      var de = this._startDe;
      do {
        var node = de.getNode();
        node.getEdges().linkMinimalDirectedEdges(this);
        de = de.getNext();
      } while (de !== this._startDe);
    }
  }, {
    key: 'getNext',
    value: function getNext(de) {
      return de.getNext();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MaximalEdgeRing;
    }
  }]);
  return MaximalEdgeRing;
}(EdgeRing);

var GraphComponent = function () {
  function GraphComponent() {
    classCallCheck(this, GraphComponent);

    this._label = null;
    this._isInResult = false;
    this._isCovered = false;
    this._isCoveredSet = false;
    this._isVisited = false;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      var label = arguments[0];
      this._label = label;
    }
  }

  createClass(GraphComponent, [{
    key: 'setVisited',
    value: function setVisited(isVisited) {
      this._isVisited = isVisited;
    }
  }, {
    key: 'setInResult',
    value: function setInResult(isInResult) {
      this._isInResult = isInResult;
    }
  }, {
    key: 'isCovered',
    value: function isCovered() {
      return this._isCovered;
    }
  }, {
    key: 'isCoveredSet',
    value: function isCoveredSet() {
      return this._isCoveredSet;
    }
  }, {
    key: 'setLabel',
    value: function setLabel(label) {
      this._label = label;
    }
  }, {
    key: 'getLabel',
    value: function getLabel() {
      return this._label;
    }
  }, {
    key: 'setCovered',
    value: function setCovered(isCovered) {
      this._isCovered = isCovered;
      this._isCoveredSet = true;
    }
  }, {
    key: 'updateIM',
    value: function updateIM(im) {
      Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');
      this.computeIM(im);
    }
  }, {
    key: 'isInResult',
    value: function isInResult() {
      return this._isInResult;
    }
  }, {
    key: 'isVisited',
    value: function isVisited() {
      return this._isVisited;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GraphComponent;
    }
  }]);
  return GraphComponent;
}();

var Node = function (_GraphComponent) {
  inherits(Node, _GraphComponent);

  function Node() {
    classCallCheck(this, Node);

    var _this = possibleConstructorReturn(this, (Node.__proto__ || Object.getPrototypeOf(Node)).call(this));

    _this._coord = null;
    _this._edges = null;
    var coord = arguments[0];
    var edges = arguments[1];
    _this._coord = coord;
    _this._edges = edges;
    _this._label = new Label(0, Location.NONE);
    return _this;
  }

  createClass(Node, [{
    key: 'isIncidentEdgeInResult',
    value: function isIncidentEdgeInResult() {
      for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {
        var de = it.next();
        if (de.getEdge().isInResult()) return true;
      }
      return false;
    }
  }, {
    key: 'isIsolated',
    value: function isIsolated() {
      return this._label.getGeometryCount() === 1;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this._coord;
    }
  }, {
    key: 'print',
    value: function print(out) {
      out.println('node ' + this._coord + ' lbl: ' + this._label);
    }
  }, {
    key: 'computeIM',
    value: function computeIM(im) {}
  }, {
    key: 'computeMergedLocation',
    value: function computeMergedLocation(label2, eltIndex) {
      var loc = Location.NONE;
      loc = this._label.getLocation(eltIndex);
      if (!label2.isNull(eltIndex)) {
        var nLoc = label2.getLocation(eltIndex);
        if (loc !== Location.BOUNDARY) loc = nLoc;
      }
      return loc;
    }
  }, {
    key: 'setLabel',
    value: function setLabel() {
      if (arguments.length === 2) {
        var argIndex = arguments[0];
        var onLocation = arguments[1];
        if (this._label === null) {
          this._label = new Label(argIndex, onLocation);
        } else this._label.setLocation(argIndex, onLocation);
      } else return GraphComponent.prototype.setLabel.apply(this, arguments);
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this._edges;
    }
  }, {
    key: 'mergeLabel',
    value: function mergeLabel() {
      if (arguments[0] instanceof Node) {
        var n = arguments[0];
        this.mergeLabel(n._label);
      } else if (arguments[0] instanceof Label) {
        var label2 = arguments[0];
        for (var i = 0; i < 2; i++) {
          var loc = this.computeMergedLocation(label2, i);
          var thisLoc = this._label.getLocation(i);
          if (thisLoc === Location.NONE) this._label.setLocation(i, loc);
        }
      }
    }
  }, {
    key: 'add',
    value: function add(e) {
      this._edges.insert(e);
      e.setNode(this);
    }
  }, {
    key: 'setLabelBoundary',
    value: function setLabelBoundary(argIndex) {
      if (this._label === null) return null;
      var loc = Location.NONE;
      if (this._label !== null) loc = this._label.getLocation(argIndex);
      var newLoc = null;
      switch (loc) {
        case Location.BOUNDARY:
          newLoc = Location.INTERIOR;
          break;
        case Location.INTERIOR:
          newLoc = Location.BOUNDARY;
          break;
        default:
          newLoc = Location.BOUNDARY;
          break;
      }
      this._label.setLocation(argIndex, newLoc);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Node;
    }
  }]);
  return Node;
}(GraphComponent);

var NodeMap = function () {
  function NodeMap() {
    classCallCheck(this, NodeMap);

    this.nodeMap = new TreeMap();
    this.nodeFact = null;
    var nodeFact = arguments[0];
    this.nodeFact = nodeFact;
  }

  createClass(NodeMap, [{
    key: 'find',
    value: function find(coord) {
      return this.nodeMap.get(coord);
    }
  }, {
    key: 'addNode',
    value: function addNode() {
      if (arguments[0] instanceof Coordinate) {
        var coord = arguments[0];
        var node = this.nodeMap.get(coord);
        if (node === null) {
          node = this.nodeFact.createNode(coord);
          this.nodeMap.put(coord, node);
        }
        return node;
      } else if (arguments[0] instanceof Node) {
        var n = arguments[0];
        var _node = this.nodeMap.get(n.getCoordinate());
        if (_node === null) {
          this.nodeMap.put(n.getCoordinate(), n);
          return n;
        }
        _node.mergeLabel(n);
        return _node;
      }
    }
  }, {
    key: 'print',
    value: function print(out) {
      for (var it = this.iterator(); it.hasNext();) {
        var n = it.next();
        n.print(out);
      }
    }
  }, {
    key: 'iterator',
    value: function iterator() {
      return this.nodeMap.values().iterator();
    }
  }, {
    key: 'values',
    value: function values() {
      return this.nodeMap.values();
    }
  }, {
    key: 'getBoundaryNodes',
    value: function getBoundaryNodes(geomIndex) {
      var bdyNodes = new ArrayList();
      for (var i = this.iterator(); i.hasNext();) {
        var node = i.next();
        if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);
      }
      return bdyNodes;
    }
  }, {
    key: 'add',
    value: function add(e) {
      var p = e.getCoordinate();
      var n = this.addNode(p);
      n.add(e);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NodeMap;
    }
  }]);
  return NodeMap;
}();

var Quadrant = function () {
  function Quadrant() {
    classCallCheck(this, Quadrant);
  }

  createClass(Quadrant, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Quadrant;
    }
  }], [{
    key: 'isNorthern',
    value: function isNorthern(quad) {
      return quad === Quadrant.NE || quad === Quadrant.NW;
    }
  }, {
    key: 'isOpposite',
    value: function isOpposite(quad1, quad2) {
      if (quad1 === quad2) return false;
      var diff = (quad1 - quad2 + 4) % 4;
      if (diff === 2) return true;
      return false;
    }
  }, {
    key: 'commonHalfPlane',
    value: function commonHalfPlane(quad1, quad2) {
      if (quad1 === quad2) return quad1;
      var diff = (quad1 - quad2 + 4) % 4;
      if (diff === 2) return -1;
      var min = quad1 < quad2 ? quad1 : quad2;
      var max = quad1 > quad2 ? quad1 : quad2;
      if (min === 0 && max === 3) return 3;
      return min;
    }
  }, {
    key: 'isInHalfPlane',
    value: function isInHalfPlane(quad, halfPlane) {
      if (halfPlane === Quadrant.SE) {
        return quad === Quadrant.SE || quad === Quadrant.SW;
      }
      return quad === halfPlane || quad === halfPlane + 1;
    }
  }, {
    key: 'quadrant',
    value: function quadrant() {
      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
        var dx = arguments[0];
        var dy = arguments[1];
        if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )');
        if (dx >= 0.0) {
          if (dy >= 0.0) return Quadrant.NE;else return Quadrant.SE;
        } else {
          if (dy >= 0.0) return Quadrant.NW;else return Quadrant.SW;
        }
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0);
        if (p1.x >= p0.x) {
          if (p1.y >= p0.y) return Quadrant.NE;else return Quadrant.SE;
        } else {
          if (p1.y >= p0.y) return Quadrant.NW;else return Quadrant.SW;
        }
      }
    }
  }, {
    key: 'NE',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'NW',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'SW',
    get: function get$$1() {
      return 2;
    }
  }, {
    key: 'SE',
    get: function get$$1() {
      return 3;
    }
  }]);
  return Quadrant;
}();

var EdgeEnd = function () {
  function EdgeEnd() {
    classCallCheck(this, EdgeEnd);

    this._edge = null;
    this._label = null;
    this._node = null;
    this._p0 = null;
    this._p1 = null;
    this._dx = null;
    this._dy = null;
    this._quadrant = null;
    if (arguments.length === 1) {
      var edge = arguments[0];
      this._edge = edge;
    } else if (arguments.length === 3) {
      var _edge = arguments[0];
      var p0 = arguments[1];
      var p1 = arguments[2];
      var label = null;
      this._edge = _edge;
      this.init(p0, p1);
      this._label = label;
    } else if (arguments.length === 4) {
      var _edge2 = arguments[0];
      var _p = arguments[1];
      var _p2 = arguments[2];
      var _label = arguments[3];
      this._edge = _edge2;
      this.init(_p, _p2);
      this._label = _label;
    }
  }

  createClass(EdgeEnd, [{
    key: 'compareDirection',
    value: function compareDirection(e) {
      if (this._dx === e._dx && this._dy === e._dy) return 0;
      if (this._quadrant > e._quadrant) return 1;
      if (this._quadrant < e._quadrant) return -1;
      return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);
    }
  }, {
    key: 'getDy',
    value: function getDy() {
      return this._dy;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this._p0;
    }
  }, {
    key: 'setNode',
    value: function setNode(node) {
      this._node = node;
    }
  }, {
    key: 'print',
    value: function print(out) {
      var angle = Math.atan2(this._dy, this._dx);
      var className = this.getClass().getName();
      var lastDotPos = className.lastIndexOf('.');
      var name = className.substring(lastDotPos + 1);
      out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);
    }
  }, {
    key: 'compareTo',
    value: function compareTo(obj) {
      var e = obj;
      return this.compareDirection(e);
    }
  }, {
    key: 'getDirectedCoordinate',
    value: function getDirectedCoordinate() {
      return this._p1;
    }
  }, {
    key: 'getDx',
    value: function getDx() {
      return this._dx;
    }
  }, {
    key: 'getLabel',
    value: function getLabel() {
      return this._label;
    }
  }, {
    key: 'getEdge',
    value: function getEdge() {
      return this._edge;
    }
  }, {
    key: 'getQuadrant',
    value: function getQuadrant() {
      return this._quadrant;
    }
  }, {
    key: 'getNode',
    value: function getNode() {
      return this._node;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var angle = Math.atan2(this._dy, this._dx);
      var className = this.getClass().getName();
      var lastDotPos = className.lastIndexOf('.');
      var name = className.substring(lastDotPos + 1);
      return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label;
    }
  }, {
    key: 'computeLabel',
    value: function computeLabel(boundaryNodeRule) {}
  }, {
    key: 'init',
    value: function init(p0, p1) {
      this._p0 = p0;
      this._p1 = p1;
      this._dx = p1.x - p0.x;
      this._dy = p1.y - p0.y;
      this._quadrant = Quadrant.quadrant(this._dx, this._dy);
      Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeEnd;
    }
  }]);
  return EdgeEnd;
}();

var DirectedEdge = function (_EdgeEnd) {
  inherits(DirectedEdge, _EdgeEnd);

  function DirectedEdge() {
    classCallCheck(this, DirectedEdge);

    var edge = arguments[0];
    var isForward = arguments[1];

    var _this = possibleConstructorReturn(this, (DirectedEdge.__proto__ || Object.getPrototypeOf(DirectedEdge)).call(this, edge));

    _this._isForward = null;
    _this._isInResult = false;
    _this._isVisited = false;
    _this._sym = null;
    _this._next = null;
    _this._nextMin = null;
    _this._edgeRing = null;
    _this._minEdgeRing = null;
    _this._depth = [0, -999, -999];
    _this._isForward = isForward;
    if (isForward) {
      _this.init(edge.getCoordinate(0), edge.getCoordinate(1));
    } else {
      var n = edge.getNumPoints() - 1;
      _this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
    }
    _this.computeDirectedLabel();
    return _this;
  }

  createClass(DirectedEdge, [{
    key: 'getNextMin',
    value: function getNextMin() {
      return this._nextMin;
    }
  }, {
    key: 'getDepth',
    value: function getDepth(position) {
      return this._depth[position];
    }
  }, {
    key: 'setVisited',
    value: function setVisited(isVisited) {
      this._isVisited = isVisited;
    }
  }, {
    key: 'computeDirectedLabel',
    value: function computeDirectedLabel() {
      this._label = new Label(this._edge.getLabel());
      if (!this._isForward) this._label.flip();
    }
  }, {
    key: 'getNext',
    value: function getNext() {
      return this._next;
    }
  }, {
    key: 'setDepth',
    value: function setDepth(position, depthVal) {
      if (this._depth[position] !== -999) {
        if (this._depth[position] !== depthVal) throw new TopologyException('assigned depths do not match', this.getCoordinate());
      }
      this._depth[position] = depthVal;
    }
  }, {
    key: 'isInteriorAreaEdge',
    value: function isInteriorAreaEdge() {
      var isInteriorAreaEdge = true;
      for (var i = 0; i < 2; i++) {
        if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
          isInteriorAreaEdge = false;
        }
      }
      return isInteriorAreaEdge;
    }
  }, {
    key: 'setNextMin',
    value: function setNextMin(nextMin) {
      this._nextMin = nextMin;
    }
  }, {
    key: 'print',
    value: function print(out) {
      EdgeEnd.prototype.print.call(this, out);
      out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);
      out.print(' (' + this.getDepthDelta() + ')');
      if (this._isInResult) out.print(' inResult');
    }
  }, {
    key: 'setMinEdgeRing',
    value: function setMinEdgeRing(minEdgeRing) {
      this._minEdgeRing = minEdgeRing;
    }
  }, {
    key: 'isLineEdge',
    value: function isLineEdge() {
      var isLine = this._label.isLine(0) || this._label.isLine(1);
      var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
      var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
      return isLine && isExteriorIfArea0 && isExteriorIfArea1;
    }
  }, {
    key: 'setEdgeRing',
    value: function setEdgeRing(edgeRing) {
      this._edgeRing = edgeRing;
    }
  }, {
    key: 'getMinEdgeRing',
    value: function getMinEdgeRing() {
      return this._minEdgeRing;
    }
  }, {
    key: 'getDepthDelta',
    value: function getDepthDelta() {
      var depthDelta = this._edge.getDepthDelta();
      if (!this._isForward) depthDelta = -depthDelta;
      return depthDelta;
    }
  }, {
    key: 'setInResult',
    value: function setInResult(isInResult) {
      this._isInResult = isInResult;
    }
  }, {
    key: 'getSym',
    value: function getSym() {
      return this._sym;
    }
  }, {
    key: 'isForward',
    value: function isForward() {
      return this._isForward;
    }
  }, {
    key: 'getEdge',
    value: function getEdge() {
      return this._edge;
    }
  }, {
    key: 'printEdge',
    value: function printEdge(out) {
      this.print(out);
      out.print(' ');
      if (this._isForward) this._edge.print(out);else this._edge.printReverse(out);
    }
  }, {
    key: 'setSym',
    value: function setSym(de) {
      this._sym = de;
    }
  }, {
    key: 'setVisitedEdge',
    value: function setVisitedEdge(isVisited) {
      this.setVisited(isVisited);
      this._sym.setVisited(isVisited);
    }
  }, {
    key: 'setEdgeDepths',
    value: function setEdgeDepths(position, depth) {
      var depthDelta = this.getEdge().getDepthDelta();
      if (!this._isForward) depthDelta = -depthDelta;
      var directionFactor = 1;
      if (position === Position.LEFT) directionFactor = -1;
      var oppositePos = Position.opposite(position);
      var delta = depthDelta * directionFactor;
      var oppositeDepth = depth + delta;
      this.setDepth(position, depth);
      this.setDepth(oppositePos, oppositeDepth);
    }
  }, {
    key: 'getEdgeRing',
    value: function getEdgeRing() {
      return this._edgeRing;
    }
  }, {
    key: 'isInResult',
    value: function isInResult() {
      return this._isInResult;
    }
  }, {
    key: 'setNext',
    value: function setNext(next) {
      this._next = next;
    }
  }, {
    key: 'isVisited',
    value: function isVisited() {
      return this._isVisited;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DirectedEdge;
    }
  }], [{
    key: 'depthFactor',
    value: function depthFactor(currLocation, nextLocation) {
      if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1;else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;
      return 0;
    }
  }]);
  return DirectedEdge;
}(EdgeEnd);

var NodeFactory = function () {
  function NodeFactory() {
    classCallCheck(this, NodeFactory);
  }

  createClass(NodeFactory, [{
    key: 'createNode',
    value: function createNode(coord) {
      return new Node(coord, null);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NodeFactory;
    }
  }]);
  return NodeFactory;
}();

var PlanarGraph = function () {
  function PlanarGraph() {
    classCallCheck(this, PlanarGraph);

    this._edges = new ArrayList();
    this._nodes = null;
    this._edgeEndList = new ArrayList();
    if (arguments.length === 0) {
      this._nodes = new NodeMap(new NodeFactory());
    } else if (arguments.length === 1) {
      var nodeFact = arguments[0];
      this._nodes = new NodeMap(nodeFact);
    }
  }

  createClass(PlanarGraph, [{
    key: 'printEdges',
    value: function printEdges(out) {
      out.println('Edges:');
      for (var i = 0; i < this._edges.size(); i++) {
        out.println('edge ' + i + ':');
        var e = this._edges.get(i);
        e.print(out);
        e.eiList.print(out);
      }
    }
  }, {
    key: 'find',
    value: function find(coord) {
      return this._nodes.find(coord);
    }
  }, {
    key: 'addNode',
    value: function addNode() {
      if (arguments[0] instanceof Node) {
        var node = arguments[0];
        return this._nodes.addNode(node);
      } else if (arguments[0] instanceof Coordinate) {
        var coord = arguments[0];
        return this._nodes.addNode(coord);
      }
    }
  }, {
    key: 'getNodeIterator',
    value: function getNodeIterator() {
      return this._nodes.iterator();
    }
  }, {
    key: 'linkResultDirectedEdges',
    value: function linkResultDirectedEdges() {
      for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        node.getEdges().linkResultDirectedEdges();
      }
    }
  }, {
    key: 'debugPrintln',
    value: function debugPrintln(o) {
      System.out.println(o);
    }
  }, {
    key: 'isBoundaryNode',
    value: function isBoundaryNode(geomIndex, coord) {
      var node = this._nodes.find(coord);
      if (node === null) return false;
      var label = node.getLabel();
      if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;
      return false;
    }
  }, {
    key: 'linkAllDirectedEdges',
    value: function linkAllDirectedEdges() {
      for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        node.getEdges().linkAllDirectedEdges();
      }
    }
  }, {
    key: 'matchInSameDirection',
    value: function matchInSameDirection(p0, p1, ep0, ep1) {
      if (!p0.equals(ep0)) return false;
      if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;
      return false;
    }
  }, {
    key: 'getEdgeEnds',
    value: function getEdgeEnds() {
      return this._edgeEndList;
    }
  }, {
    key: 'debugPrint',
    value: function debugPrint(o) {
      System.out.print(o);
    }
  }, {
    key: 'getEdgeIterator',
    value: function getEdgeIterator() {
      return this._edges.iterator();
    }
  }, {
    key: 'findEdgeInSameDirection',
    value: function findEdgeInSameDirection(p0, p1) {
      for (var i = 0; i < this._edges.size(); i++) {
        var e = this._edges.get(i);
        var eCoord = e.getCoordinates();
        if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;
        if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;
      }
      return null;
    }
  }, {
    key: 'insertEdge',
    value: function insertEdge(e) {
      this._edges.add(e);
    }
  }, {
    key: 'findEdgeEnd',
    value: function findEdgeEnd(e) {
      for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {
        var ee = i.next();
        if (ee.getEdge() === e) return ee;
      }
      return null;
    }
  }, {
    key: 'addEdges',
    value: function addEdges(edgesToAdd) {
      for (var it = edgesToAdd.iterator(); it.hasNext();) {
        var e = it.next();
        this._edges.add(e);
        var de1 = new DirectedEdge(e, true);
        var de2 = new DirectedEdge(e, false);
        de1.setSym(de2);
        de2.setSym(de1);
        this.add(de1);
        this.add(de2);
      }
    }
  }, {
    key: 'add',
    value: function add(e) {
      this._nodes.add(e);
      this._edgeEndList.add(e);
    }
  }, {
    key: 'getNodes',
    value: function getNodes() {
      return this._nodes.values();
    }
  }, {
    key: 'findEdge',
    value: function findEdge(p0, p1) {
      for (var i = 0; i < this._edges.size(); i++) {
        var e = this._edges.get(i);
        var eCoord = e.getCoordinates();
        if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;
      }
      return null;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PlanarGraph;
    }
  }], [{
    key: 'linkResultDirectedEdges',
    value: function linkResultDirectedEdges(nodes) {
      for (var nodeit = nodes.iterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        node.getEdges().linkResultDirectedEdges();
      }
    }
  }]);
  return PlanarGraph;
}();

var PolygonBuilder = function () {
  function PolygonBuilder() {
    classCallCheck(this, PolygonBuilder);

    this._geometryFactory = null;
    this._shellList = new ArrayList();
    var geometryFactory = arguments[0];
    this._geometryFactory = geometryFactory;
  }

  createClass(PolygonBuilder, [{
    key: 'sortShellsAndHoles',
    value: function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
      for (var it = edgeRings.iterator(); it.hasNext();) {
        var er = it.next();
        if (er.isHole()) {
          freeHoleList.add(er);
        } else {
          shellList.add(er);
        }
      }
    }
  }, {
    key: 'computePolygons',
    value: function computePolygons(shellList) {
      var resultPolyList = new ArrayList();
      for (var it = shellList.iterator(); it.hasNext();) {
        var er = it.next();
        var poly = er.toPolygon(this._geometryFactory);
        resultPolyList.add(poly);
      }
      return resultPolyList;
    }
  }, {
    key: 'placeFreeHoles',
    value: function placeFreeHoles(shellList, freeHoleList) {
      for (var it = freeHoleList.iterator(); it.hasNext();) {
        var hole = it.next();
        if (hole.getShell() === null) {
          var shell = this.findEdgeRingContaining(hole, shellList);
          if (shell === null) throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0));
          hole.setShell(shell);
        }
      }
    }
  }, {
    key: 'buildMinimalEdgeRings',
    value: function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
      var edgeRings = new ArrayList();
      for (var it = maxEdgeRings.iterator(); it.hasNext();) {
        var er = it.next();
        if (er.getMaxNodeDegree() > 2) {
          er.linkDirectedEdgesForMinimalEdgeRings();
          var minEdgeRings = er.buildMinimalRings();
          var shell = this.findShell(minEdgeRings);
          if (shell !== null) {
            this.placePolygonHoles(shell, minEdgeRings);
            shellList.add(shell);
          } else {
            freeHoleList.addAll(minEdgeRings);
          }
        } else {
          edgeRings.add(er);
        }
      }
      return edgeRings;
    }
  }, {
    key: 'containsPoint',
    value: function containsPoint(p) {
      for (var it = this._shellList.iterator(); it.hasNext();) {
        var er = it.next();
        if (er.containsPoint(p)) return true;
      }
      return false;
    }
  }, {
    key: 'buildMaximalEdgeRings',
    value: function buildMaximalEdgeRings(dirEdges) {
      var maxEdgeRings = new ArrayList();
      for (var it = dirEdges.iterator(); it.hasNext();) {
        var de = it.next();
        if (de.isInResult() && de.getLabel().isArea()) {
          if (de.getEdgeRing() === null) {
            var er = new MaximalEdgeRing(de, this._geometryFactory);
            maxEdgeRings.add(er);
            er.setInResult();
          }
        }
      }
      return maxEdgeRings;
    }
  }, {
    key: 'placePolygonHoles',
    value: function placePolygonHoles(shell, minEdgeRings) {
      for (var it = minEdgeRings.iterator(); it.hasNext();) {
        var er = it.next();
        if (er.isHole()) {
          er.setShell(shell);
        }
      }
    }
  }, {
    key: 'getPolygons',
    value: function getPolygons() {
      var resultPolyList = this.computePolygons(this._shellList);
      return resultPolyList;
    }
  }, {
    key: 'findEdgeRingContaining',
    value: function findEdgeRingContaining(testEr, shellList) {
      var testRing = testEr.getLinearRing();
      var testEnv = testRing.getEnvelopeInternal();
      var testPt = testRing.getCoordinateN(0);
      var minShell = null;
      var minEnv = null;
      for (var it = shellList.iterator(); it.hasNext();) {
        var tryShell = it.next();
        var tryRing = tryShell.getLinearRing();
        var tryEnv = tryRing.getEnvelopeInternal();
        if (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();
        var isContained = false;
        if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) isContained = true;
        if (isContained) {
          if (minShell === null || minEnv.contains(tryEnv)) {
            minShell = tryShell;
          }
        }
      }
      return minShell;
    }
  }, {
    key: 'findShell',
    value: function findShell(minEdgeRings) {
      var shellCount = 0;
      var shell = null;
      for (var it = minEdgeRings.iterator(); it.hasNext();) {
        var er = it.next();
        if (!er.isHole()) {
          shell = er;
          shellCount++;
        }
      }
      Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
      return shell;
    }
  }, {
    key: 'add',
    value: function add() {
      if (arguments.length === 1) {
        var graph = arguments[0];
        this.add(graph.getEdgeEnds(), graph.getNodes());
      } else if (arguments.length === 2) {
        var dirEdges = arguments[0];
        var nodes = arguments[1];
        PlanarGraph.linkResultDirectedEdges(nodes);
        var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
        var freeHoleList = new ArrayList();
        var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
        this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
        this.placeFreeHoles(this._shellList, freeHoleList);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PolygonBuilder;
    }
  }]);
  return PolygonBuilder;
}();

var Boundable = function () {
  function Boundable() {
    classCallCheck(this, Boundable);
  }

  createClass(Boundable, [{
    key: "getBounds",
    value: function getBounds() {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return Boundable;
    }
  }]);
  return Boundable;
}();

var ItemBoundable = function () {
  function ItemBoundable() {
    classCallCheck(this, ItemBoundable);

    this._bounds = null;
    this._item = null;
    var bounds = arguments[0];
    var item = arguments[1];
    this._bounds = bounds;
    this._item = item;
  }

  createClass(ItemBoundable, [{
    key: 'getItem',
    value: function getItem() {
      return this._item;
    }
  }, {
    key: 'getBounds',
    value: function getBounds() {
      return this._bounds;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Boundable, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return ItemBoundable;
    }
  }]);
  return ItemBoundable;
}();

var PriorityQueue = function () {
  function PriorityQueue() {
    classCallCheck(this, PriorityQueue);

    this._size = null;
    this._items = null;
    this._size = 0;
    this._items = new ArrayList();
    this._items.add(null);
  }

  createClass(PriorityQueue, [{
    key: 'poll',
    value: function poll() {
      if (this.isEmpty()) return null;
      var minItem = this._items.get(1);
      this._items.set(1, this._items.get(this._size));
      this._size -= 1;
      this.reorder(1);
      return minItem;
    }
  }, {
    key: 'size',
    value: function size() {
      return this._size;
    }
  }, {
    key: 'reorder',
    value: function reorder(hole) {
      var child = null;
      var tmp = this._items.get(hole);
      for (; hole * 2 <= this._size; hole = child) {
        child = hole * 2;
        if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;
        if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child));else break;
      }
      this._items.set(hole, tmp);
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._size = 0;
      this._items.clear();
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this._size === 0;
    }
  }, {
    key: 'add',
    value: function add(x) {
      this._items.add(null);
      this._size += 1;
      var hole = this._size;
      this._items.set(0, x);
      for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
        this._items.set(hole, this._items.get(Math.trunc(hole / 2)));
      }
      this._items.set(hole, x);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PriorityQueue;
    }
  }]);
  return PriorityQueue;
}();

var ItemVisitor = function () {
  function ItemVisitor() {
    classCallCheck(this, ItemVisitor);
  }

  createClass(ItemVisitor, [{
    key: "visitItem",
    value: function visitItem(item) {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return ItemVisitor;
    }
  }]);
  return ItemVisitor;
}();

var SpatialIndex = function () {
  function SpatialIndex() {
    classCallCheck(this, SpatialIndex);
  }

  createClass(SpatialIndex, [{
    key: "insert",
    value: function insert(itemEnv, item) {}
  }, {
    key: "remove",
    value: function remove(itemEnv, item) {}
  }, {
    key: "query",
    value: function query() {
      // if (arguments.length === 1) {
      //   const searchEnv = arguments[0]
      // } else if (arguments.length === 2) {
      //   const searchEnv = arguments[0]
      //   const visitor = arguments[1]
      // }
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return SpatialIndex;
    }
  }]);
  return SpatialIndex;
}();

var AbstractNode = function () {
  function AbstractNode() {
    classCallCheck(this, AbstractNode);

    this._childBoundables = new ArrayList();
    this._bounds = null;
    this._level = null;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      var level = arguments[0];
      this._level = level;
    }
  }

  createClass(AbstractNode, [{
    key: 'getLevel',
    value: function getLevel() {
      return this._level;
    }
  }, {
    key: 'size',
    value: function size() {
      return this._childBoundables.size();
    }
  }, {
    key: 'getChildBoundables',
    value: function getChildBoundables() {
      return this._childBoundables;
    }
  }, {
    key: 'addChildBoundable',
    value: function addChildBoundable(childBoundable) {
      Assert.isTrue(this._bounds === null);
      this._childBoundables.add(childBoundable);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this._childBoundables.isEmpty();
    }
  }, {
    key: 'getBounds',
    value: function getBounds() {
      if (this._bounds === null) {
        this._bounds = this.computeBounds();
      }
      return this._bounds;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Boundable, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return AbstractNode;
    }
  }], [{
    key: 'serialVersionUID',
    get: function get$$1() {
      return 6493722185909573708;
    }
  }]);
  return AbstractNode;
}();

var Collections = function () {
  function Collections() {
    classCallCheck(this, Collections);
  }

  createClass(Collections, null, [{
    key: 'reverseOrder',
    value: function reverseOrder() {
      return {
        compare: function compare(a, b) {
          return b.compareTo(a);
        }
      };
    }
  }, {
    key: 'min',
    value: function min(l) {
      Collections.sort(l);
      return l.get(0);
    }
  }, {
    key: 'sort',
    value: function sort(l, c) {
      var a = l.toArray();
      if (c) {
        Arrays.sort(a, c);
      } else {
        Arrays.sort(a);
      }
      var i = l.iterator();
      for (var pos = 0, alen = a.length; pos < alen; pos++) {
        i.next();
        i.set(a[pos]);
      }
    }
  }, {
    key: 'singletonList',
    value: function singletonList(o) {
      var arrayList = new ArrayList();
      arrayList.add(o);
      return arrayList;
    }
  }]);
  return Collections;
}();

var BoundablePair = function () {
  function BoundablePair() {
    classCallCheck(this, BoundablePair);

    this._boundable1 = null;
    this._boundable2 = null;
    this._distance = null;
    this._itemDistance = null;
    var boundable1 = arguments[0];
    var boundable2 = arguments[1];
    var itemDistance = arguments[2];
    this._boundable1 = boundable1;
    this._boundable2 = boundable2;
    this._itemDistance = itemDistance;
    this._distance = this.distance();
  }

  createClass(BoundablePair, [{
    key: 'expandToQueue',
    value: function expandToQueue(priQ, minDistance) {
      var isComp1 = BoundablePair.isComposite(this._boundable1);
      var isComp2 = BoundablePair.isComposite(this._boundable2);
      if (isComp1 && isComp2) {
        if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
          this.expand(this._boundable1, this._boundable2, priQ, minDistance);
          return null;
        } else {
          this.expand(this._boundable2, this._boundable1, priQ, minDistance);
          return null;
        }
      } else if (isComp1) {
        this.expand(this._boundable1, this._boundable2, priQ, minDistance);
        return null;
      } else if (isComp2) {
        this.expand(this._boundable2, this._boundable1, priQ, minDistance);
        return null;
      }
      throw new IllegalArgumentException('neither boundable is composite');
    }
  }, {
    key: 'isLeaves',
    value: function isLeaves() {
      return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var nd = o;
      if (this._distance < nd._distance) return -1;
      if (this._distance > nd._distance) return 1;
      return 0;
    }
  }, {
    key: 'expand',
    value: function expand(bndComposite, bndOther, priQ, minDistance) {
      var children = bndComposite.getChildBoundables();
      for (var i = children.iterator(); i.hasNext();) {
        var child = i.next();
        var bp = new BoundablePair(child, bndOther, this._itemDistance);
        if (bp.getDistance() < minDistance) {
          priQ.add(bp);
        }
      }
    }
  }, {
    key: 'getBoundable',
    value: function getBoundable(i) {
      if (i === 0) return this._boundable1;
      return this._boundable2;
    }
  }, {
    key: 'getDistance',
    value: function getDistance() {
      return this._distance;
    }
  }, {
    key: 'distance',
    value: function distance() {
      if (this.isLeaves()) {
        return this._itemDistance.distance(this._boundable1, this._boundable2);
      }
      return this._boundable1.getBounds().distance(this._boundable2.getBounds());
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BoundablePair;
    }
  }], [{
    key: 'area',
    value: function area(b) {
      return b.getBounds().getArea();
    }
  }, {
    key: 'isComposite',
    value: function isComposite(item) {
      return item instanceof AbstractNode;
    }
  }]);
  return BoundablePair;
}();

var AbstractSTRtree = function () {
  function AbstractSTRtree() {
    classCallCheck(this, AbstractSTRtree);

    this._root = null;
    this._built = false;
    this._itemBoundables = new ArrayList();
    this._nodeCapacity = null;
    if (arguments.length === 0) {
      var nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;
      this._nodeCapacity = nodeCapacity;
    } else if (arguments.length === 1) {
      var _nodeCapacity = arguments[0];
      Assert.isTrue(_nodeCapacity > 1, 'Node capacity must be greater than 1');
      this._nodeCapacity = _nodeCapacity;
    }
  }

  createClass(AbstractSTRtree, [{
    key: 'getNodeCapacity',
    value: function getNodeCapacity() {
      return this._nodeCapacity;
    }
  }, {
    key: 'lastNode',
    value: function lastNode(nodes) {
      return nodes.get(nodes.size() - 1);
    }
  }, {
    key: 'size',
    value: function size() {
      if (arguments.length === 0) {
        if (this.isEmpty()) {
          return 0;
        }
        this.build();
        return this.size(this._root);
      } else if (arguments.length === 1) {
        var node = arguments[0];
        var size = 0;
        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
          var childBoundable = i.next();
          if (childBoundable instanceof AbstractNode) {
            size += this.size(childBoundable);
          } else if (childBoundable instanceof ItemBoundable) {
            size += 1;
          }
        }
        return size;
      }
    }
  }, {
    key: 'removeItem',
    value: function removeItem(node, item) {
      var childToRemove = null;
      for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
        var childBoundable = i.next();
        if (childBoundable instanceof ItemBoundable) {
          if (childBoundable.getItem() === item) childToRemove = childBoundable;
        }
      }
      if (childToRemove !== null) {
        node.getChildBoundables().remove(childToRemove);
        return true;
      }
      return false;
    }
  }, {
    key: 'itemsTree',
    value: function itemsTree() {
      if (arguments.length === 0) {
        this.build();
        var valuesTree = this.itemsTree(this._root);
        if (valuesTree === null) return new ArrayList();
        return valuesTree;
      } else if (arguments.length === 1) {
        var node = arguments[0];
        var valuesTreeForNode = new ArrayList();
        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
          var childBoundable = i.next();
          if (childBoundable instanceof AbstractNode) {
            var valuesTreeForChild = this.itemsTree(childBoundable);
            if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);
          } else if (childBoundable instanceof ItemBoundable) {
            valuesTreeForNode.add(childBoundable.getItem());
          } else {
            Assert.shouldNeverReachHere();
          }
        }
        if (valuesTreeForNode.size() <= 0) return null;
        return valuesTreeForNode;
      }
    }
  }, {
    key: 'insert',
    value: function insert(bounds, item) {
      Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');
      this._itemBoundables.add(new ItemBoundable(bounds, item));
    }
  }, {
    key: 'boundablesAtLevel',
    value: function boundablesAtLevel() {
      if (arguments.length === 1) {
        var level = arguments[0];
        var boundables = new ArrayList();
        this.boundablesAtLevel(level, this._root, boundables);
        return boundables;
      } else if (arguments.length === 3) {
        var _level = arguments[0];
        var top = arguments[1];
        var _boundables = arguments[2];
        Assert.isTrue(_level > -2);
        if (top.getLevel() === _level) {
          _boundables.add(top);
          return null;
        }
        for (var i = top.getChildBoundables().iterator(); i.hasNext();) {
          var boundable = i.next();
          if (boundable instanceof AbstractNode) {
            this.boundablesAtLevel(_level, boundable, _boundables);
          } else {
            Assert.isTrue(boundable instanceof ItemBoundable);
            if (_level === -1) {
              _boundables.add(boundable);
            }
          }
        }
        return null;
      }
    }
  }, {
    key: 'query',
    value: function query() {
      if (arguments.length === 1) {
        var searchBounds = arguments[0];
        this.build();
        var matches = new ArrayList();
        if (this.isEmpty()) {
          return matches;
        }
        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
          this.query(searchBounds, this._root, matches);
        }
        return matches;
      } else if (arguments.length === 2) {
        var _searchBounds = arguments[0];
        var visitor = arguments[1];
        this.build();
        if (this.isEmpty()) {
          return null;
        }
        if (this.getIntersectsOp().intersects(this._root.getBounds(), _searchBounds)) {
          this.query(_searchBounds, this._root, visitor);
        }
      } else if (arguments.length === 3) {
        if (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {
          var _searchBounds2 = arguments[0];
          var node = arguments[1];
          var _visitor = arguments[2];
          var childBoundables = node.getChildBoundables();
          for (var i = 0; i < childBoundables.size(); i++) {
            var childBoundable = childBoundables.get(i);
            if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), _searchBounds2)) {
              continue;
            }
            if (childBoundable instanceof AbstractNode) {
              this.query(_searchBounds2, childBoundable, _visitor);
            } else if (childBoundable instanceof ItemBoundable) {
              _visitor.visitItem(childBoundable.getItem());
            } else {
              Assert.shouldNeverReachHere();
            }
          }
        } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {
          var _searchBounds3 = arguments[0];
          var _node = arguments[1];
          var _matches = arguments[2];
          var _childBoundables = _node.getChildBoundables();
          for (var _i = 0; _i < _childBoundables.size(); _i++) {
            var _childBoundable = _childBoundables.get(_i);
            if (!this.getIntersectsOp().intersects(_childBoundable.getBounds(), _searchBounds3)) {
              continue;
            }
            if (_childBoundable instanceof AbstractNode) {
              this.query(_searchBounds3, _childBoundable, _matches);
            } else if (_childBoundable instanceof ItemBoundable) {
              _matches.add(_childBoundable.getItem());
            } else {
              Assert.shouldNeverReachHere();
            }
          }
        }
      }
    }
  }, {
    key: 'build',
    value: function build() {
      if (this._built) return null;
      this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
      this._itemBoundables = null;
      this._built = true;
    }
  }, {
    key: 'getRoot',
    value: function getRoot() {
      this.build();
      return this._root;
    }
  }, {
    key: 'remove',
    value: function remove() {
      if (arguments.length === 2) {
        var searchBounds = arguments[0];
        var item = arguments[1];
        this.build();
        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
          return this.remove(searchBounds, this._root, item);
        }
        return false;
      } else if (arguments.length === 3) {
        var _searchBounds4 = arguments[0];
        var node = arguments[1];
        var _item = arguments[2];
        var found = this.removeItem(node, _item);
        if (found) return true;
        var childToPrune = null;
        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
          var childBoundable = i.next();
          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), _searchBounds4)) {
            continue;
          }
          if (childBoundable instanceof AbstractNode) {
            found = this.remove(_searchBounds4, childBoundable, _item);
            if (found) {
              childToPrune = childBoundable;
              break;
            }
          }
        }
        if (childToPrune !== null) {
          if (childToPrune.getChildBoundables().isEmpty()) {
            node.getChildBoundables().remove(childToPrune);
          }
        }
        return found;
      }
    }
  }, {
    key: 'createHigherLevels',
    value: function createHigherLevels(boundablesOfALevel, level) {
      Assert.isTrue(!boundablesOfALevel.isEmpty());
      var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
      if (parentBoundables.size() === 1) {
        return parentBoundables.get(0);
      }
      return this.createHigherLevels(parentBoundables, level + 1);
    }
  }, {
    key: 'depth',
    value: function depth() {
      if (arguments.length === 0) {
        if (this.isEmpty()) {
          return 0;
        }
        this.build();
        return this.depth(this._root);
      } else if (arguments.length === 1) {
        var node = arguments[0];
        var maxChildDepth = 0;
        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
          var childBoundable = i.next();
          if (childBoundable instanceof AbstractNode) {
            var childDepth = this.depth(childBoundable);
            if (childDepth > maxChildDepth) maxChildDepth = childDepth;
          }
        }
        return maxChildDepth + 1;
      }
    }
  }, {
    key: 'createParentBoundables',
    value: function createParentBoundables(childBoundables, newLevel) {
      Assert.isTrue(!childBoundables.isEmpty());
      var parentBoundables = new ArrayList();
      parentBoundables.add(this.createNode(newLevel));
      var sortedChildBoundables = new ArrayList(childBoundables);
      Collections.sort(sortedChildBoundables, this.getComparator());
      for (var i = sortedChildBoundables.iterator(); i.hasNext();) {
        var childBoundable = i.next();
        if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {
          parentBoundables.add(this.createNode(newLevel));
        }
        this.lastNode(parentBoundables).addChildBoundable(childBoundable);
      }
      return parentBoundables;
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      if (!this._built) return this._itemBoundables.isEmpty();
      return this._root.isEmpty();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return AbstractSTRtree;
    }
  }], [{
    key: 'compareDoubles',
    value: function compareDoubles(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
  }, {
    key: 'IntersectsOp',
    get: function get$$1() {
      return IntersectsOp;
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return -3886435814360241337;
    }
  }, {
    key: 'DEFAULT_NODE_CAPACITY',
    get: function get$$1() {
      return 10;
    }
  }]);
  return AbstractSTRtree;
}();

var IntersectsOp = function IntersectsOp() {
  classCallCheck(this, IntersectsOp);
};

var ItemDistance = function () {
  function ItemDistance() {
    classCallCheck(this, ItemDistance);
  }

  createClass(ItemDistance, [{
    key: "distance",
    value: function distance(item1, item2) {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return ItemDistance;
    }
  }]);
  return ItemDistance;
}();

var STRtree = function (_AbstractSTRtree) {
  inherits(STRtree, _AbstractSTRtree);

  function STRtree(nodeCapacity) {
    classCallCheck(this, STRtree);

    nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;
    return possibleConstructorReturn(this, (STRtree.__proto__ || Object.getPrototypeOf(STRtree)).call(this, nodeCapacity));
  }

  createClass(STRtree, [{
    key: 'createParentBoundablesFromVerticalSlices',
    value: function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
      Assert.isTrue(verticalSlices.length > 0);
      var parentBoundables = new ArrayList();
      for (var i = 0; i < verticalSlices.length; i++) {
        parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
      }
      return parentBoundables;
    }
  }, {
    key: 'createNode',
    value: function createNode(level) {
      return new STRtreeNode(level);
    }
  }, {
    key: 'size',
    value: function size() {
      if (arguments.length === 0) {
        return AbstractSTRtree.prototype.size.call(this);
      } else return AbstractSTRtree.prototype.size.apply(this, arguments);
    }
  }, {
    key: 'insert',
    value: function insert() {
      if (arguments.length === 2) {
        var itemEnv = arguments[0];
        var item = arguments[1];
        if (itemEnv.isNull()) {
          return null;
        }
        AbstractSTRtree.prototype.insert.call(this, itemEnv, item);
      } else return AbstractSTRtree.prototype.insert.apply(this, arguments);
    }
  }, {
    key: 'getIntersectsOp',
    value: function getIntersectsOp() {
      return STRtree.intersectsOp;
    }
  }, {
    key: 'verticalSlices',
    value: function verticalSlices(childBoundables, sliceCount) {
      var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
      var slices = new Array(sliceCount).fill(null);
      var i = childBoundables.iterator();
      for (var j = 0; j < sliceCount; j++) {
        slices[j] = new ArrayList();
        var boundablesAddedToSlice = 0;
        while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
          var childBoundable = i.next();
          slices[j].add(childBoundable);
          boundablesAddedToSlice++;
        }
      }
      return slices;
    }
  }, {
    key: 'query',
    value: function query() {
      if (arguments.length === 1) {
        var searchEnv = arguments[0];
        return AbstractSTRtree.prototype.query.call(this, searchEnv);
      } else if (arguments.length === 2) {
        var _searchEnv = arguments[0];
        var visitor = arguments[1];
        AbstractSTRtree.prototype.query.call(this, _searchEnv, visitor);
      } else if (arguments.length === 3) {
        if (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {
          var searchBounds = arguments[0];
          var node = arguments[1];
          var _visitor = arguments[2];
          AbstractSTRtree.prototype.query.call(this, searchBounds, node, _visitor);
        } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {
          var _searchBounds = arguments[0];
          var _node = arguments[1];
          var matches = arguments[2];
          AbstractSTRtree.prototype.query.call(this, _searchBounds, _node, matches);
        }
      }
    }
  }, {
    key: 'getComparator',
    value: function getComparator() {
      return STRtree.yComparator;
    }
  }, {
    key: 'createParentBoundablesFromVerticalSlice',
    value: function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
      return AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);
    }
  }, {
    key: 'remove',
    value: function remove() {
      if (arguments.length === 2) {
        var itemEnv = arguments[0];
        var item = arguments[1];
        return AbstractSTRtree.prototype.remove.call(this, itemEnv, item);
      } else return AbstractSTRtree.prototype.remove.apply(this, arguments);
    }
  }, {
    key: 'depth',
    value: function depth() {
      if (arguments.length === 0) {
        return AbstractSTRtree.prototype.depth.call(this);
      } else return AbstractSTRtree.prototype.depth.apply(this, arguments);
    }
  }, {
    key: 'createParentBoundables',
    value: function createParentBoundables(childBoundables, newLevel) {
      Assert.isTrue(!childBoundables.isEmpty());
      var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
      var sortedChildBoundables = new ArrayList(childBoundables);
      Collections.sort(sortedChildBoundables, STRtree.xComparator);
      var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
      return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
    }
  }, {
    key: 'nearestNeighbour',
    value: function nearestNeighbour() {
      if (arguments.length === 1) {
        if (hasInterface(arguments[0], ItemDistance)) {
          var itemDist = arguments[0];
          var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
          return this.nearestNeighbour(bp);
        } else if (arguments[0] instanceof BoundablePair) {
          var initBndPair = arguments[0];
          return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);
        }
      } else if (arguments.length === 2) {
        if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {
          var tree = arguments[0];
          var _itemDist = arguments[1];
          var _bp = new BoundablePair(this.getRoot(), tree.getRoot(), _itemDist);
          return this.nearestNeighbour(_bp);
        } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {
          var _initBndPair = arguments[0];
          var maxDistance = arguments[1];
          var distanceLowerBound = maxDistance;
          var minPair = null;
          var priQ = new PriorityQueue();
          priQ.add(_initBndPair);
          while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
            var bndPair = priQ.poll();
            var currentDistance = bndPair.getDistance();
            if (currentDistance >= distanceLowerBound) break;
            if (bndPair.isLeaves()) {
              distanceLowerBound = currentDistance;
              minPair = bndPair;
            } else {
              bndPair.expandToQueue(priQ, distanceLowerBound);
            }
          }
          return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];
        }
      } else if (arguments.length === 3) {
        var env = arguments[0];
        var item = arguments[1];
        var _itemDist2 = arguments[2];
        var bnd = new ItemBoundable(env, item);
        var _bp2 = new BoundablePair(this.getRoot(), bnd, _itemDist2);
        return this.nearestNeighbour(_bp2)[0];
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [SpatialIndex, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return STRtree;
    }
  }], [{
    key: 'centreX',
    value: function centreX(e) {
      return STRtree.avg(e.getMinX(), e.getMaxX());
    }
  }, {
    key: 'avg',
    value: function avg(a, b) {
      return (a + b) / 2;
    }
  }, {
    key: 'centreY',
    value: function centreY(e) {
      return STRtree.avg(e.getMinY(), e.getMaxY());
    }
  }, {
    key: 'STRtreeNode',
    get: function get$$1() {
      return STRtreeNode;
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return 259274702368956900;
    }
  }, {
    key: 'xComparator',
    get: function get$$1() {
      return {
        interfaces_: function interfaces_() {
          return [Comparator];
        },
        compare: function compare(o1, o2) {
          return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));
        }
      };
    }
  }, {
    key: 'yComparator',
    get: function get$$1() {
      return {
        interfaces_: function interfaces_() {
          return [Comparator];
        },
        compare: function compare(o1, o2) {
          return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));
        }
      };
    }
  }, {
    key: 'intersectsOp',
    get: function get$$1() {
      return {
        interfaces_: function interfaces_() {
          return [AbstractSTRtree.IntersectsOp];
        },
        intersects: function intersects(aBounds, bBounds) {
          return aBounds.intersects(bBounds);
        }
      };
    }
  }, {
    key: 'DEFAULT_NODE_CAPACITY',
    get: function get$$1() {
      return 10;
    }
  }]);
  return STRtree;
}(AbstractSTRtree);

var STRtreeNode = function (_AbstractNode) {
  inherits(STRtreeNode, _AbstractNode);

  function STRtreeNode() {
    classCallCheck(this, STRtreeNode);

    var level = arguments[0];
    return possibleConstructorReturn(this, (STRtreeNode.__proto__ || Object.getPrototypeOf(STRtreeNode)).call(this, level));
  }

  createClass(STRtreeNode, [{
    key: 'computeBounds',
    value: function computeBounds() {
      var bounds = null;
      for (var i = this.getChildBoundables().iterator(); i.hasNext();) {
        var childBoundable = i.next();
        if (bounds === null) {
          bounds = new Envelope(childBoundable.getBounds());
        } else {
          bounds.expandToInclude(childBoundable.getBounds());
        }
      }
      return bounds;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return STRtreeNode;
    }
  }]);
  return STRtreeNode;
}(AbstractNode);

var SegmentPointComparator = function () {
  function SegmentPointComparator() {
    classCallCheck(this, SegmentPointComparator);
  }

  createClass(SegmentPointComparator, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SegmentPointComparator;
    }
  }], [{
    key: 'relativeSign',
    value: function relativeSign(x0, x1) {
      if (x0 < x1) return -1;
      if (x0 > x1) return 1;
      return 0;
    }
  }, {
    key: 'compare',
    value: function compare(octant, p0, p1) {
      if (p0.equals2D(p1)) return 0;
      var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
      var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
      switch (octant) {
        case 0:
          return SegmentPointComparator.compareValue(xSign, ySign);
        case 1:
          return SegmentPointComparator.compareValue(ySign, xSign);
        case 2:
          return SegmentPointComparator.compareValue(ySign, -xSign);
        case 3:
          return SegmentPointComparator.compareValue(-xSign, ySign);
        case 4:
          return SegmentPointComparator.compareValue(-xSign, -ySign);
        case 5:
          return SegmentPointComparator.compareValue(-ySign, -xSign);
        case 6:
          return SegmentPointComparator.compareValue(-ySign, xSign);
        case 7:
          return SegmentPointComparator.compareValue(xSign, -ySign);
        default:
      }
      Assert.shouldNeverReachHere('invalid octant value');
      return 0;
    }
  }, {
    key: 'compareValue',
    value: function compareValue(compareSign0, compareSign1) {
      if (compareSign0 < 0) return -1;
      if (compareSign0 > 0) return 1;
      if (compareSign1 < 0) return -1;
      if (compareSign1 > 0) return 1;
      return 0;
    }
  }]);
  return SegmentPointComparator;
}();

var SegmentNode = function () {
  function SegmentNode() {
    classCallCheck(this, SegmentNode);

    this._segString = null;
    this.coord = null;
    this.segmentIndex = null;
    this._segmentOctant = null;
    this._isInterior = null;
    var segString = arguments[0];
    var coord = arguments[1];
    var segmentIndex = arguments[2];
    var segmentOctant = arguments[3];
    this._segString = segString;
    this.coord = new Coordinate(coord);
    this.segmentIndex = segmentIndex;
    this._segmentOctant = segmentOctant;
    this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
  }

  createClass(SegmentNode, [{
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this.coord;
    }
  }, {
    key: 'print',
    value: function print(out) {
      out.print(this.coord);
      out.print(' seg # = ' + this.segmentIndex);
    }
  }, {
    key: 'compareTo',
    value: function compareTo(obj) {
      var other = obj;
      if (this.segmentIndex < other.segmentIndex) return -1;
      if (this.segmentIndex > other.segmentIndex) return 1;
      if (this.coord.equals2D(other.coord)) return 0;
      return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);
    }
  }, {
    key: 'isEndPoint',
    value: function isEndPoint(maxSegmentIndex) {
      if (this.segmentIndex === 0 && !this._isInterior) return true;
      if (this.segmentIndex === maxSegmentIndex) return true;
      return false;
    }
  }, {
    key: 'isInterior',
    value: function isInterior() {
      return this._isInterior;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SegmentNode;
    }
  }]);
  return SegmentNode;
}();

// import Iterator from '../../../../java/util/Iterator'
var SegmentNodeList = function () {
  function SegmentNodeList() {
    classCallCheck(this, SegmentNodeList);

    this._nodeMap = new TreeMap();
    this._edge = null;
    var edge = arguments[0];
    this._edge = edge;
  }

  createClass(SegmentNodeList, [{
    key: 'getSplitCoordinates',
    value: function getSplitCoordinates() {
      var coordList = new CoordinateList();
      this.addEndpoints();
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        this.addEdgeCoordinates(eiPrev, ei, coordList);
        eiPrev = ei;
      }
      return coordList.toCoordinateArray();
    }
  }, {
    key: 'addCollapsedNodes',
    value: function addCollapsedNodes() {
      var collapsedVertexIndexes = new ArrayList();
      this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
      this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
      for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {
        var vertexIndex = it.next().intValue();
        this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);
      }
    }
  }, {
    key: 'print',
    value: function print(out) {
      out.println('Intersections:');
      for (var it = this.iterator(); it.hasNext();) {
        var ei = it.next();
        ei.print(out);
      }
    }
  }, {
    key: 'findCollapsesFromExistingVertices',
    value: function findCollapsesFromExistingVertices(collapsedVertexIndexes) {
      for (var i = 0; i < this._edge.size() - 2; i++) {
        var p0 = this._edge.getCoordinate(i);
        // const p1 = this._edge.getCoordinate(i + 1)
        var p2 = this._edge.getCoordinate(i + 2);
        if (p0.equals2D(p2)) {
          collapsedVertexIndexes.add(new Integer(i + 1));
        }
      }
    }
  }, {
    key: 'addEdgeCoordinates',
    value: function addEdgeCoordinates(ei0, ei1, coordList) {
      // let npts = ei1.segmentIndex - ei0.segmentIndex + 2
      var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
      var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
      // if (!useIntPt1) {
      //   npts--
      // }
      // const ipt = 0
      coordList.add(new Coordinate(ei0.coord), false);
      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
        coordList.add(this._edge.getCoordinate(i));
      }
      if (useIntPt1) {
        coordList.add(new Coordinate(ei1.coord));
      }
    }
  }, {
    key: 'iterator',
    value: function iterator() {
      return this._nodeMap.values().iterator();
    }
  }, {
    key: 'addSplitEdges',
    value: function addSplitEdges(edgeList) {
      this.addEndpoints();
      this.addCollapsedNodes();
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        var newEdge = this.createSplitEdge(eiPrev, ei);
        edgeList.add(newEdge);
        eiPrev = ei;
      }
    }
  }, {
    key: 'findCollapseIndex',
    value: function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
      if (!ei0.coord.equals2D(ei1.coord)) return false;
      var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
      if (!ei1.isInterior()) {
        numVerticesBetween--;
      }
      if (numVerticesBetween === 1) {
        collapsedVertexIndex[0] = ei0.segmentIndex + 1;
        return true;
      }
      return false;
    }
  }, {
    key: 'findCollapsesFromInsertedNodes',
    value: function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
      var collapsedVertexIndex = new Array(1).fill(null);
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        var isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
        if (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));
        eiPrev = ei;
      }
    }
  }, {
    key: 'getEdge',
    value: function getEdge() {
      return this._edge;
    }
  }, {
    key: 'addEndpoints',
    value: function addEndpoints() {
      var maxSegIndex = this._edge.size() - 1;
      this.add(this._edge.getCoordinate(0), 0);
      this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
    }
  }, {
    key: 'createSplitEdge',
    value: function createSplitEdge(ei0, ei1) {
      var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
      var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
      var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
      if (!useIntPt1) {
        npts--;
      }
      var pts = new Array(npts).fill(null);
      var ipt = 0;
      pts[ipt++] = new Coordinate(ei0.coord);
      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
        pts[ipt++] = this._edge.getCoordinate(i);
      }
      if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);
      return new NodedSegmentString(pts, this._edge.getData());
    }
  }, {
    key: 'add',
    value: function add(intPt, segmentIndex) {
      var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
      var ei = this._nodeMap.get(eiNew);
      if (ei !== null) {
        Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');
        return ei;
      }
      this._nodeMap.put(eiNew, eiNew);
      return eiNew;
    }
  }, {
    key: 'checkSplitEdgesCorrectness',
    value: function checkSplitEdgesCorrectness(splitEdges) {
      var edgePts = this._edge.getCoordinates();
      var split0 = splitEdges.get(0);
      var pt0 = split0.getCoordinate(0);
      if (!pt0.equals2D(edgePts[0])) throw new RuntimeException('bad split edge start point at ' + pt0);
      var splitn = splitEdges.get(splitEdges.size() - 1);
      var splitnPts = splitn.getCoordinates();
      var ptn = splitnPts[splitnPts.length - 1];
      if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException('bad split edge end point at ' + ptn);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SegmentNodeList;
    }
  }]);
  return SegmentNodeList;
}();

var Octant = function () {
  function Octant() {
    classCallCheck(this, Octant);
  }

  createClass(Octant, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Octant;
    }
  }], [{
    key: 'octant',
    value: function octant() {
      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
        var dx = arguments[0];
        var dy = arguments[1];
        if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )');
        var adx = Math.abs(dx);
        var ady = Math.abs(dy);
        if (dx >= 0) {
          if (dy >= 0) {
            if (adx >= ady) return 0;else return 1;
          } else {
            if (adx >= ady) return 7;else return 6;
          }
        } else {
          if (dy >= 0) {
            if (adx >= ady) return 3;else return 2;
          } else {
            if (adx >= ady) return 4;else return 5;
          }
        }
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        var _dx = p1.x - p0.x;
        var _dy = p1.y - p0.y;
        if (_dx === 0.0 && _dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0);
        return Octant.octant(_dx, _dy);
      }
    }
  }]);
  return Octant;
}();

var SegmentString = function () {
  function SegmentString() {
    classCallCheck(this, SegmentString);
  }

  createClass(SegmentString, [{
    key: "getCoordinates",
    value: function getCoordinates() {}
  }, {
    key: "size",
    value: function size() {}
  }, {
    key: "getCoordinate",
    value: function getCoordinate(i) {}
  }, {
    key: "isClosed",
    value: function isClosed() {}
  }, {
    key: "setData",
    value: function setData(data) {}
  }, {
    key: "getData",
    value: function getData() {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return SegmentString;
    }
  }]);
  return SegmentString;
}();

var NodableSegmentString = function () {
  function NodableSegmentString() {
    classCallCheck(this, NodableSegmentString);
  }

  createClass(NodableSegmentString, [{
    key: 'addIntersection',
    value: function addIntersection(intPt, segmentIndex) {}
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [SegmentString];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NodableSegmentString;
    }
  }]);
  return NodableSegmentString;
}();

var NodedSegmentString = function () {
  function NodedSegmentString() {
    classCallCheck(this, NodedSegmentString);

    this._nodeList = new SegmentNodeList(this);
    this._pts = null;
    this._data = null;
    var pts = arguments[0];
    var data = arguments[1];
    this._pts = pts;
    this._data = data;
  }

  createClass(NodedSegmentString, [{
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this._pts;
    }
  }, {
    key: 'size',
    value: function size() {
      return this._pts.length;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate(i) {
      return this._pts[i];
    }
  }, {
    key: 'isClosed',
    value: function isClosed() {
      return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }
  }, {
    key: 'getSegmentOctant',
    value: function getSegmentOctant(index) {
      if (index === this._pts.length - 1) return -1;
      return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));
    }
  }, {
    key: 'setData',
    value: function setData(data) {
      this._data = data;
    }
  }, {
    key: 'safeOctant',
    value: function safeOctant(p0, p1) {
      if (p0.equals2D(p1)) return 0;
      return Octant.octant(p0, p1);
    }
  }, {
    key: 'getData',
    value: function getData() {
      return this._data;
    }
  }, {
    key: 'addIntersection',
    value: function addIntersection() {
      if (arguments.length === 2) {
        var _intPt = arguments[0];
        var segmentIndex = arguments[1];
        this.addIntersectionNode(_intPt, segmentIndex);
      } else if (arguments.length === 4) {
        var li = arguments[0];
        var _segmentIndex = arguments[1];
        // const geomIndex = arguments[2]
        var intIndex = arguments[3];
        var intPt = new Coordinate(li.getIntersection(intIndex));
        this.addIntersection(intPt, _segmentIndex);
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
    }
  }, {
    key: 'getNodeList',
    value: function getNodeList() {
      return this._nodeList;
    }
  }, {
    key: 'addIntersectionNode',
    value: function addIntersectionNode(intPt, segmentIndex) {
      var normalizedSegmentIndex = segmentIndex;
      var nextSegIndex = normalizedSegmentIndex + 1;
      if (nextSegIndex < this._pts.length) {
        var nextPt = this._pts[nextSegIndex];
        if (intPt.equals2D(nextPt)) {
          normalizedSegmentIndex = nextSegIndex;
        }
      }
      var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
      return ei;
    }
  }, {
    key: 'addIntersections',
    value: function addIntersections(li, segmentIndex, geomIndex) {
      for (var i = 0; i < li.getIntersectionNum(); i++) {
        this.addIntersection(li, segmentIndex, geomIndex, i);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [NodableSegmentString];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NodedSegmentString;
    }
  }], [{
    key: 'getNodedSubstrings',
    value: function getNodedSubstrings() {
      if (arguments.length === 1) {
        var segStrings = arguments[0];
        var resultEdgelist = new ArrayList();
        NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
        return resultEdgelist;
      } else if (arguments.length === 2) {
        var _segStrings = arguments[0];
        var _resultEdgelist = arguments[1];
        for (var i = _segStrings.iterator(); i.hasNext();) {
          var ss = i.next();
          ss.getNodeList().addSplitEdges(_resultEdgelist);
        }
      }
    }
  }]);
  return NodedSegmentString;
}();

var LineSegment = function () {
  function LineSegment() {
    classCallCheck(this, LineSegment);

    this.p0 = null;
    this.p1 = null;
    if (arguments.length === 0) {
      this.p0 = new Coordinate();
      this.p1 = new Coordinate();
    } else if (arguments.length === 1) {
      var ls = arguments[0];
      this.p0 = new Coordinate(ls.p0);
      this.p1 = new Coordinate(ls.p1);
    } else if (arguments.length === 2) {
      this.p0 = arguments[0];
      this.p1 = arguments[1];
    } else if (arguments.length === 4) {
      var x0 = arguments[0];
      var y0 = arguments[1];
      var x1 = arguments[2];
      var y1 = arguments[3];
      this.p0 = new Coordinate(x0, y0);
      this.p1 = new Coordinate(x1, y1);
    }
  }

  createClass(LineSegment, [{
    key: 'minX',
    value: function minX() {
      return Math.min(this.p0.x, this.p1.x);
    }
  }, {
    key: 'orientationIndex',
    value: function orientationIndex() {
      if (arguments[0] instanceof LineSegment) {
        var seg = arguments[0];
        var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
        var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
        if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);
        if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);
        return 0;
      } else if (arguments[0] instanceof Coordinate) {
        var p = arguments[0];
        return CGAlgorithms.orientationIndex(this.p0, this.p1, p);
      }
    }
  }, {
    key: 'toGeometry',
    value: function toGeometry(geomFactory) {
      return geomFactory.createLineString([this.p0, this.p1]);
    }
  }, {
    key: 'isVertical',
    value: function isVertical() {
      return this.p0.x === this.p1.x;
    }
  }, {
    key: 'equals',
    value: function equals(o) {
      if (!(o instanceof LineSegment)) {
        return false;
      }
      var other = o;
      return this.p0.equals(other.p0) && this.p1.equals(other.p1);
    }
  }, {
    key: 'intersection',
    value: function intersection(line) {
      var li = new RobustLineIntersector();
      li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
      if (li.hasIntersection()) return li.getIntersection(0);
      return null;
    }
  }, {
    key: 'project',
    value: function project() {
      if (arguments[0] instanceof Coordinate) {
        var p = arguments[0];
        if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);
        var r = this.projectionFactor(p);
        var coord = new Coordinate();
        coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
        coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
        return coord;
      } else if (arguments[0] instanceof LineSegment) {
        var seg = arguments[0];
        var pf0 = this.projectionFactor(seg.p0);
        var pf1 = this.projectionFactor(seg.p1);
        if (pf0 >= 1.0 && pf1 >= 1.0) return null;
        if (pf0 <= 0.0 && pf1 <= 0.0) return null;
        var newp0 = this.project(seg.p0);
        if (pf0 < 0.0) newp0 = this.p0;
        if (pf0 > 1.0) newp0 = this.p1;
        var newp1 = this.project(seg.p1);
        if (pf1 < 0.0) newp1 = this.p0;
        if (pf1 > 1.0) newp1 = this.p1;
        return new LineSegment(newp0, newp1);
      }
    }
  }, {
    key: 'normalize',
    value: function normalize() {
      if (this.p1.compareTo(this.p0) < 0) this.reverse();
    }
  }, {
    key: 'angle',
    value: function angle() {
      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate(i) {
      if (i === 0) return this.p0;
      return this.p1;
    }
  }, {
    key: 'distancePerpendicular',
    value: function distancePerpendicular(p) {
      return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);
    }
  }, {
    key: 'minY',
    value: function minY() {
      return Math.min(this.p0.y, this.p1.y);
    }
  }, {
    key: 'midPoint',
    value: function midPoint() {
      return LineSegment.midPoint(this.p0, this.p1);
    }
  }, {
    key: 'projectionFactor',
    value: function projectionFactor(p) {
      if (p.equals(this.p0)) return 0.0;
      if (p.equals(this.p1)) return 1.0;
      var dx = this.p1.x - this.p0.x;
      var dy = this.p1.y - this.p0.y;
      var len = dx * dx + dy * dy;
      if (len <= 0.0) return Double.NaN;
      var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
      return r;
    }
  }, {
    key: 'closestPoints',
    value: function closestPoints(line) {
      var intPt = this.intersection(line);
      if (intPt !== null) {
        return [intPt, intPt];
      }
      var closestPt = new Array(2).fill(null);
      var minDistance = Double.MAX_VALUE;
      var dist = null;
      var close00 = this.closestPoint(line.p0);
      minDistance = close00.distance(line.p0);
      closestPt[0] = close00;
      closestPt[1] = line.p0;
      var close01 = this.closestPoint(line.p1);
      dist = close01.distance(line.p1);
      if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = close01;
        closestPt[1] = line.p1;
      }
      var close10 = line.closestPoint(this.p0);
      dist = close10.distance(this.p0);
      if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = this.p0;
        closestPt[1] = close10;
      }
      var close11 = line.closestPoint(this.p1);
      dist = close11.distance(this.p1);
      if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = this.p1;
        closestPt[1] = close11;
      }
      return closestPt;
    }
  }, {
    key: 'closestPoint',
    value: function closestPoint(p) {
      var factor = this.projectionFactor(p);
      if (factor > 0 && factor < 1) {
        return this.project(p);
      }
      var dist0 = this.p0.distance(p);
      var dist1 = this.p1.distance(p);
      if (dist0 < dist1) return this.p0;
      return this.p1;
    }
  }, {
    key: 'maxX',
    value: function maxX() {
      return Math.max(this.p0.x, this.p1.x);
    }
  }, {
    key: 'getLength',
    value: function getLength() {
      return this.p0.distance(this.p1);
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var other = o;
      var comp0 = this.p0.compareTo(other.p0);
      if (comp0 !== 0) return comp0;
      return this.p1.compareTo(other.p1);
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      var temp = this.p0;
      this.p0 = this.p1;
      this.p1 = temp;
    }
  }, {
    key: 'equalsTopo',
    value: function equalsTopo(other) {
      return this.p0.equals(other.p0) && (this.p1.equals(other.p1) || this.p0.equals(other.p1)) && this.p1.equals(other.p0);
    }
  }, {
    key: 'lineIntersection',
    value: function lineIntersection(line) {
      try {
        var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
        return intPt;
      } catch (ex) {
        if (ex instanceof NotRepresentableException) {} else throw ex;
      } finally {}
      return null;
    }
  }, {
    key: 'maxY',
    value: function maxY() {
      return Math.max(this.p0.y, this.p1.y);
    }
  }, {
    key: 'pointAlongOffset',
    value: function pointAlongOffset(segmentLengthFraction, offsetDistance) {
      var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
      var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
      var dx = this.p1.x - this.p0.x;
      var dy = this.p1.y - this.p0.y;
      var len = Math.sqrt(dx * dx + dy * dy);
      var ux = 0.0;
      var uy = 0.0;
      if (offsetDistance !== 0.0) {
        if (len <= 0.0) throw new Error('Cannot compute offset from zero-length line segment');
        ux = offsetDistance * dx / len;
        uy = offsetDistance * dy / len;
      }
      var offsetx = segx - uy;
      var offsety = segy + ux;
      var coord = new Coordinate(offsetx, offsety);
      return coord;
    }
  }, {
    key: 'setCoordinates',
    value: function setCoordinates() {
      if (arguments.length === 1) {
        var ls = arguments[0];
        this.setCoordinates(ls.p0, ls.p1);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        this.p0.x = p0.x;
        this.p0.y = p0.y;
        this.p1.x = p1.x;
        this.p1.y = p1.y;
      }
    }
  }, {
    key: 'segmentFraction',
    value: function segmentFraction(inputPt) {
      var segFrac = this.projectionFactor(inputPt);
      if (segFrac < 0.0) segFrac = 0.0;else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;
      return segFrac;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')';
    }
  }, {
    key: 'isHorizontal',
    value: function isHorizontal() {
      return this.p0.y === this.p1.y;
    }
  }, {
    key: 'distance',
    value: function distance() {
      if (arguments[0] instanceof LineSegment) {
        var ls = arguments[0];
        return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);
      } else if (arguments[0] instanceof Coordinate) {
        var p = arguments[0];
        return CGAlgorithms.distancePointLine(p, this.p0, this.p1);
      }
    }
  }, {
    key: 'pointAlong',
    value: function pointAlong(segmentLengthFraction) {
      var coord = new Coordinate();
      coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
      coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
      return coord;
    }
  }, {
    key: 'hashCode',
    value: function hashCode() {
      var bits0 = Double.doubleToLongBits(this.p0.x);
      bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;
      var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
      var bits1 = Double.doubleToLongBits(this.p1.x);
      bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;
      var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
      return hash0 ^ hash1;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable, Serializable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return LineSegment;
    }
  }], [{
    key: 'midPoint',
    value: function midPoint(p0, p1) {
      return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
    }
  }, {
    key: 'serialVersionUID',
    get: function get$$1() {
      return 3252005833466256227;
    }
  }]);
  return LineSegment;
}();

var MonotoneChainOverlapAction = function () {
  function MonotoneChainOverlapAction() {
    classCallCheck(this, MonotoneChainOverlapAction);

    this.tempEnv1 = new Envelope();
    this.tempEnv2 = new Envelope();
    this._overlapSeg1 = new LineSegment();
    this._overlapSeg2 = new LineSegment();
  }

  createClass(MonotoneChainOverlapAction, [{
    key: 'overlap',
    value: function overlap() {
      if (arguments.length === 2) {
        // const seg1 = arguments[0]
        // const seg2 = arguments[1]
      } else if (arguments.length === 4) {
        var mc1 = arguments[0];
        var start1 = arguments[1];
        var mc2 = arguments[2];
        var start2 = arguments[3];
        mc1.getLineSegment(start1, this._overlapSeg1);
        mc2.getLineSegment(start2, this._overlapSeg2);
        this.overlap(this._overlapSeg1, this._overlapSeg2);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MonotoneChainOverlapAction;
    }
  }]);
  return MonotoneChainOverlapAction;
}();

var MonotoneChain = function () {
  function MonotoneChain() {
    classCallCheck(this, MonotoneChain);

    this._pts = null;
    this._start = null;
    this._end = null;
    this._env = null;
    this._context = null;
    this._id = null;
    var pts = arguments[0];
    var start = arguments[1];
    var end = arguments[2];
    var context = arguments[3];
    this._pts = pts;
    this._start = start;
    this._end = end;
    this._context = context;
  }

  createClass(MonotoneChain, [{
    key: 'getLineSegment',
    value: function getLineSegment(index, ls) {
      ls.p0 = this._pts[index];
      ls.p1 = this._pts[index + 1];
    }
  }, {
    key: 'computeSelect',
    value: function computeSelect(searchEnv, start0, end0, mcs) {
      var p0 = this._pts[start0];
      var p1 = this._pts[end0];
      mcs.tempEnv1.init(p0, p1);
      if (end0 - start0 === 1) {
        mcs.select(this, start0);
        return null;
      }
      if (!searchEnv.intersects(mcs.tempEnv1)) return null;
      var mid = Math.trunc((start0 + end0) / 2);
      if (start0 < mid) {
        this.computeSelect(searchEnv, start0, mid, mcs);
      }
      if (mid < end0) {
        this.computeSelect(searchEnv, mid, end0, mcs);
      }
    }
  }, {
    key: 'getCoordinates',
    value: function getCoordinates() {
      var coord = new Array(this._end - this._start + 1).fill(null);
      var index = 0;
      for (var i = this._start; i <= this._end; i++) {
        coord[index++] = this._pts[i];
      }
      return coord;
    }
  }, {
    key: 'computeOverlaps',
    value: function computeOverlaps(mc, mco) {
      this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);
    }
  }, {
    key: 'setId',
    value: function setId(id) {
      this._id = id;
    }
  }, {
    key: 'select',
    value: function select(searchEnv, mcs) {
      this.computeSelect(searchEnv, this._start, this._end, mcs);
    }
  }, {
    key: 'getEnvelope',
    value: function getEnvelope() {
      if (this._env === null) {
        var p0 = this._pts[this._start];
        var p1 = this._pts[this._end];
        this._env = new Envelope(p0, p1);
      }
      return this._env;
    }
  }, {
    key: 'getEndIndex',
    value: function getEndIndex() {
      return this._end;
    }
  }, {
    key: 'getStartIndex',
    value: function getStartIndex() {
      return this._start;
    }
  }, {
    key: 'getContext',
    value: function getContext() {
      return this._context;
    }
  }, {
    key: 'getId',
    value: function getId() {
      return this._id;
    }
  }, {
    key: 'computeOverlapsInternal',
    value: function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {
      var p00 = this._pts[start0];
      var p01 = this._pts[end0];
      var p10 = mc._pts[start1];
      var p11 = mc._pts[end1];
      if (end0 - start0 === 1 && end1 - start1 === 1) {
        mco.overlap(this, start0, mc, start1);
        return null;
      }
      mco.tempEnv1.init(p00, p01);
      mco.tempEnv2.init(p10, p11);
      if (!mco.tempEnv1.intersects(mco.tempEnv2)) return null;
      var mid0 = Math.trunc((start0 + end0) / 2);
      var mid1 = Math.trunc((start1 + end1) / 2);
      if (start0 < mid0) {
        if (start1 < mid1) this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);
        if (mid1 < end1) this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);
      }
      if (mid0 < end0) {
        if (start1 < mid1) this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);
        if (mid1 < end1) this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MonotoneChain;
    }
  }]);
  return MonotoneChain;
}();

var MonotoneChainBuilder = function () {
  function MonotoneChainBuilder() {
    classCallCheck(this, MonotoneChainBuilder);
  }

  createClass(MonotoneChainBuilder, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MonotoneChainBuilder;
    }
  }], [{
    key: 'getChainStartIndices',
    value: function getChainStartIndices(pts) {
      var start = 0;
      var startIndexList = new ArrayList();
      startIndexList.add(new Integer(start));
      do {
        var last = MonotoneChainBuilder.findChainEnd(pts, start);
        startIndexList.add(new Integer(last));
        start = last;
      } while (start < pts.length - 1);
      var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
      return startIndex;
    }
  }, {
    key: 'findChainEnd',
    value: function findChainEnd(pts, start) {
      var safeStart = start;
      while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
        safeStart++;
      }
      if (safeStart >= pts.length - 1) {
        return pts.length - 1;
      }
      var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
      var last = start + 1;
      while (last < pts.length) {
        if (!pts[last - 1].equals2D(pts[last])) {
          var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
          if (quad !== chainQuad) break;
        }
        last++;
      }
      return last - 1;
    }
  }, {
    key: 'getChains',
    value: function getChains() {
      if (arguments.length === 1) {
        var pts = arguments[0];
        return MonotoneChainBuilder.getChains(pts, null);
      } else if (arguments.length === 2) {
        var _pts = arguments[0];
        var context = arguments[1];
        var mcList = new ArrayList();
        var startIndex = MonotoneChainBuilder.getChainStartIndices(_pts);
        for (var i = 0; i < startIndex.length - 1; i++) {
          var mc = new MonotoneChain(_pts, startIndex[i], startIndex[i + 1], context);
          mcList.add(mc);
        }
        return mcList;
      }
    }
  }, {
    key: 'toIntArray',
    value: function toIntArray(list) {
      var array = new Array(list.size()).fill(null);
      for (var i = 0; i < array.length; i++) {
        array[i] = list.get(i).intValue();
      }
      return array;
    }
  }]);
  return MonotoneChainBuilder;
}();

var Noder = function () {
  function Noder() {
    classCallCheck(this, Noder);
  }

  createClass(Noder, [{
    key: "computeNodes",
    value: function computeNodes(segStrings) {}
  }, {
    key: "getNodedSubstrings",
    value: function getNodedSubstrings() {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return Noder;
    }
  }]);
  return Noder;
}();

var SinglePassNoder = function () {
  function SinglePassNoder() {
    classCallCheck(this, SinglePassNoder);

    this._segInt = null;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      var segInt = arguments[0];
      this.setSegmentIntersector(segInt);
    }
  }

  createClass(SinglePassNoder, [{
    key: 'setSegmentIntersector',
    value: function setSegmentIntersector(segInt) {
      this._segInt = segInt;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Noder];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SinglePassNoder;
    }
  }]);
  return SinglePassNoder;
}();

var MCIndexNoder = function (_SinglePassNoder) {
  inherits(MCIndexNoder, _SinglePassNoder);

  function MCIndexNoder(si) {
    classCallCheck(this, MCIndexNoder);

    if (si) {
      

      var _this = possibleConstructorReturn(this, (MCIndexNoder.__proto__ || Object.getPrototypeOf(MCIndexNoder)).call(this, si));
    } else {
      

      var _this = possibleConstructorReturn(this, (MCIndexNoder.__proto__ || Object.getPrototypeOf(MCIndexNoder)).call(this));
    }_this._monoChains = new ArrayList();
    _this._index = new STRtree();
    _this._idCounter = 0;
    _this._nodedSegStrings = null;
    _this._nOverlaps = 0;
    return possibleConstructorReturn(_this);
  }

  createClass(MCIndexNoder, [{
    key: 'getMonotoneChains',
    value: function getMonotoneChains() {
      return this._monoChains;
    }
  }, {
    key: 'getNodedSubstrings',
    value: function getNodedSubstrings() {
      return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
    }
  }, {
    key: 'getIndex',
    value: function getIndex() {
      return this._index;
    }
  }, {
    key: 'add',
    value: function add(segStr) {
      var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
      for (var i = segChains.iterator(); i.hasNext();) {
        var mc = i.next();
        mc.setId(this._idCounter++);
        this._index.insert(mc.getEnvelope(), mc);
        this._monoChains.add(mc);
      }
    }
  }, {
    key: 'computeNodes',
    value: function computeNodes(inputSegStrings) {
      this._nodedSegStrings = inputSegStrings;
      for (var i = inputSegStrings.iterator(); i.hasNext();) {
        this.add(i.next());
      }
      this.intersectChains();
    }
  }, {
    key: 'intersectChains',
    value: function intersectChains() {
      var overlapAction = new SegmentOverlapAction(this._segInt);
      for (var i = this._monoChains.iterator(); i.hasNext();) {
        var queryChain = i.next();
        var overlapChains = this._index.query(queryChain.getEnvelope());
        for (var j = overlapChains.iterator(); j.hasNext();) {
          var testChain = j.next();
          if (testChain.getId() > queryChain.getId()) {
            queryChain.computeOverlaps(testChain, overlapAction);
            this._nOverlaps++;
          }
          if (this._segInt.isDone()) return null;
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MCIndexNoder;
    }
  }], [{
    key: 'SegmentOverlapAction',
    get: function get$$1() {
      return SegmentOverlapAction;
    }
  }]);
  return MCIndexNoder;
}(SinglePassNoder);

var SegmentOverlapAction = function (_MonotoneChainOverlap) {
  inherits(SegmentOverlapAction, _MonotoneChainOverlap);

  function SegmentOverlapAction() {
    classCallCheck(this, SegmentOverlapAction);

    var _this2 = possibleConstructorReturn(this, (SegmentOverlapAction.__proto__ || Object.getPrototypeOf(SegmentOverlapAction)).call(this));

    _this2._si = null;
    var si = arguments[0];
    _this2._si = si;
    return _this2;
  }

  createClass(SegmentOverlapAction, [{
    key: 'overlap',
    value: function overlap() {
      if (arguments.length === 4) {
        var mc1 = arguments[0];
        var start1 = arguments[1];
        var mc2 = arguments[2];
        var start2 = arguments[3];
        var ss1 = mc1.getContext();
        var ss2 = mc2.getContext();
        this._si.processIntersections(ss1, start1, ss2, start2);
      } else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SegmentOverlapAction;
    }
  }]);
  return SegmentOverlapAction;
}(MonotoneChainOverlapAction);

var BufferParameters = function () {
  function BufferParameters() {
    classCallCheck(this, BufferParameters);

    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
    this._endCapStyle = BufferParameters.CAP_ROUND;
    this._joinStyle = BufferParameters.JOIN_ROUND;
    this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
    this._isSingleSided = false;
    this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;

    if (arguments.length === 0) {} else if (arguments.length === 1) {
      var quadrantSegments = arguments[0];
      this.setQuadrantSegments(quadrantSegments);
    } else if (arguments.length === 2) {
      var _quadrantSegments = arguments[0];
      var endCapStyle = arguments[1];
      this.setQuadrantSegments(_quadrantSegments);
      this.setEndCapStyle(endCapStyle);
    } else if (arguments.length === 4) {
      var _quadrantSegments2 = arguments[0];
      var _endCapStyle = arguments[1];
      var joinStyle = arguments[2];
      var mitreLimit = arguments[3];
      this.setQuadrantSegments(_quadrantSegments2);
      this.setEndCapStyle(_endCapStyle);
      this.setJoinStyle(joinStyle);
      this.setMitreLimit(mitreLimit);
    }
  }

  createClass(BufferParameters, [{
    key: "getEndCapStyle",
    value: function getEndCapStyle() {
      return this._endCapStyle;
    }
  }, {
    key: "isSingleSided",
    value: function isSingleSided() {
      return this._isSingleSided;
    }
  }, {
    key: "setQuadrantSegments",
    value: function setQuadrantSegments(quadSegs) {
      this._quadrantSegments = quadSegs;
      if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;
      if (this._quadrantSegments < 0) {
        this._joinStyle = BufferParameters.JOIN_MITRE;
        this._mitreLimit = Math.abs(this._quadrantSegments);
      }
      if (quadSegs <= 0) {
        this._quadrantSegments = 1;
      }
      if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
        this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
      }
    }
  }, {
    key: "getJoinStyle",
    value: function getJoinStyle() {
      return this._joinStyle;
    }
  }, {
    key: "setJoinStyle",
    value: function setJoinStyle(joinStyle) {
      this._joinStyle = joinStyle;
    }
  }, {
    key: "setSimplifyFactor",
    value: function setSimplifyFactor(simplifyFactor) {
      this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
    }
  }, {
    key: "getSimplifyFactor",
    value: function getSimplifyFactor() {
      return this._simplifyFactor;
    }
  }, {
    key: "getQuadrantSegments",
    value: function getQuadrantSegments() {
      return this._quadrantSegments;
    }
  }, {
    key: "setEndCapStyle",
    value: function setEndCapStyle(endCapStyle) {
      this._endCapStyle = endCapStyle;
    }
  }, {
    key: "getMitreLimit",
    value: function getMitreLimit() {
      return this._mitreLimit;
    }
  }, {
    key: "setMitreLimit",
    value: function setMitreLimit(mitreLimit) {
      this._mitreLimit = mitreLimit;
    }
  }, {
    key: "setSingleSided",
    value: function setSingleSided(isSingleSided) {
      this._isSingleSided = isSingleSided;
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return BufferParameters;
    }
  }], [{
    key: "bufferDistanceError",
    value: function bufferDistanceError(quadSegs) {
      var alpha = Math.PI / 2.0 / quadSegs;
      return 1 - Math.cos(alpha / 2.0);
    }
  }, {
    key: "CAP_ROUND",
    get: function get$$1() {
      return 1;
    }
  }, {
    key: "CAP_FLAT",
    get: function get$$1() {
      return 2;
    }
  }, {
    key: "CAP_SQUARE",
    get: function get$$1() {
      return 3;
    }
  }, {
    key: "JOIN_ROUND",
    get: function get$$1() {
      return 1;
    }
  }, {
    key: "JOIN_MITRE",
    get: function get$$1() {
      return 2;
    }
  }, {
    key: "JOIN_BEVEL",
    get: function get$$1() {
      return 3;
    }
  }, {
    key: "DEFAULT_QUADRANT_SEGMENTS",
    get: function get$$1() {
      return 8;
    }
  }, {
    key: "DEFAULT_MITRE_LIMIT",
    get: function get$$1() {
      return 5.0;
    }
  }, {
    key: "DEFAULT_SIMPLIFY_FACTOR",
    get: function get$$1() {
      return 0.01;
    }
  }]);
  return BufferParameters;
}();

var BufferInputLineSimplifier = function () {
  function BufferInputLineSimplifier(inputLine) {
    classCallCheck(this, BufferInputLineSimplifier);

    this._distanceTol = null;
    this._isDeleted = null;
    this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;
    this._inputLine = inputLine || null;
  }

  createClass(BufferInputLineSimplifier, [{
    key: 'isDeletable',
    value: function isDeletable(i0, i1, i2, distanceTol) {
      var p0 = this._inputLine[i0];
      var p1 = this._inputLine[i1];
      var p2 = this._inputLine[i2];
      if (!this.isConcave(p0, p1, p2)) return false;
      if (!this.isShallow(p0, p1, p2, distanceTol)) return false;
      return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
    }
  }, {
    key: 'deleteShallowConcavities',
    value: function deleteShallowConcavities() {
      var index = 1;
      // const maxIndex = this._inputLine.length - 1
      var midIndex = this.findNextNonDeletedIndex(index);
      var lastIndex = this.findNextNonDeletedIndex(midIndex);
      var isChanged = false;
      while (lastIndex < this._inputLine.length) {
        var isMiddleVertexDeleted = false;
        if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {
          this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
          isMiddleVertexDeleted = true;
          isChanged = true;
        }
        if (isMiddleVertexDeleted) index = lastIndex;else index = midIndex;
        midIndex = this.findNextNonDeletedIndex(index);
        lastIndex = this.findNextNonDeletedIndex(midIndex);
      }
      return isChanged;
    }
  }, {
    key: 'isShallowConcavity',
    value: function isShallowConcavity(p0, p1, p2, distanceTol) {
      var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
      var isAngleToSimplify = orientation === this._angleOrientation;
      if (!isAngleToSimplify) return false;
      var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
      return dist < distanceTol;
    }
  }, {
    key: 'isShallowSampled',
    value: function isShallowSampled(p0, p2, i0, i2, distanceTol) {
      var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
      if (inc <= 0) inc = 1;
      for (var i = i0; i < i2; i += inc) {
        if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;
      }
      return true;
    }
  }, {
    key: 'isConcave',
    value: function isConcave(p0, p1, p2) {
      var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);
      var isConcave = orientation === this._angleOrientation;
      return isConcave;
    }
  }, {
    key: 'simplify',
    value: function simplify(distanceTol) {
      this._distanceTol = Math.abs(distanceTol);
      if (distanceTol < 0) this._angleOrientation = CGAlgorithms.CLOCKWISE;
      this._isDeleted = new Array(this._inputLine.length).fill(null);
      var isChanged = false;
      do {
        isChanged = this.deleteShallowConcavities();
      } while (isChanged);
      return this.collapseLine();
    }
  }, {
    key: 'findNextNonDeletedIndex',
    value: function findNextNonDeletedIndex(index) {
      var next = index + 1;
      while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) {
        next++;
      }return next;
    }
  }, {
    key: 'isShallow',
    value: function isShallow(p0, p1, p2, distanceTol) {
      var dist = CGAlgorithms.distancePointLine(p1, p0, p2);
      return dist < distanceTol;
    }
  }, {
    key: 'collapseLine',
    value: function collapseLine() {
      var coordList = new CoordinateList();
      for (var i = 0; i < this._inputLine.length; i++) {
        if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);
      }
      return coordList.toCoordinateArray();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BufferInputLineSimplifier;
    }
  }], [{
    key: 'simplify',
    value: function simplify(inputLine, distanceTol) {
      var simp = new BufferInputLineSimplifier(inputLine);
      return simp.simplify(distanceTol);
    }
  }, {
    key: 'INIT',
    get: function get$$1() {
      return 0;
    }
  }, {
    key: 'DELETE',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'KEEP',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'NUM_PTS_TO_CHECK',
    get: function get$$1() {
      return 10;
    }
  }]);
  return BufferInputLineSimplifier;
}();

var OffsetSegmentString = function () {
  function OffsetSegmentString() {
    classCallCheck(this, OffsetSegmentString);

    this._ptList = null;
    this._precisionModel = null;
    this._minimimVertexDistance = 0.0;
    this._ptList = new ArrayList();
  }

  createClass(OffsetSegmentString, [{
    key: 'getCoordinates',
    value: function getCoordinates() {
      var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
      return coord;
    }
  }, {
    key: 'setPrecisionModel',
    value: function setPrecisionModel(precisionModel) {
      this._precisionModel = precisionModel;
    }
  }, {
    key: 'addPt',
    value: function addPt(pt) {
      var bufPt = new Coordinate(pt);
      this._precisionModel.makePrecise(bufPt);
      if (this.isRedundant(bufPt)) return null;
      this._ptList.add(bufPt);
    }
  }, {
    key: 'revere',
    value: function revere() {}
  }, {
    key: 'addPts',
    value: function addPts(pt, isForward) {
      if (isForward) {
        for (var i = 0; i < pt.length; i++) {
          this.addPt(pt[i]);
        }
      } else {
        for (var _i = pt.length - 1; _i >= 0; _i--) {
          this.addPt(pt[_i]);
        }
      }
    }
  }, {
    key: 'isRedundant',
    value: function isRedundant(pt) {
      if (this._ptList.size() < 1) return false;
      var lastPt = this._ptList.get(this._ptList.size() - 1);
      var ptDist = pt.distance(lastPt);
      if (ptDist < this._minimimVertexDistance) return true;
      return false;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var fact = new GeometryFactory();
      var line = fact.createLineString(this.getCoordinates());
      return line.toString();
    }
  }, {
    key: 'closeRing',
    value: function closeRing() {
      if (this._ptList.size() < 1) return null;
      var startPt = new Coordinate(this._ptList.get(0));
      var lastPt = this._ptList.get(this._ptList.size() - 1);
      // const last2Pt = null
      // if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)
      if (startPt.equals(lastPt)) return null;
      this._ptList.add(startPt);
    }
  }, {
    key: 'setMinimumVertexDistance',
    value: function setMinimumVertexDistance(minimimVertexDistance) {
      this._minimimVertexDistance = minimimVertexDistance;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OffsetSegmentString;
    }
  }], [{
    key: 'COORDINATE_ARRAY_TYPE',
    get: function get$$1() {
      return new Array(0).fill(null);
    }
  }]);
  return OffsetSegmentString;
}();

var Angle = function () {
  function Angle() {
    classCallCheck(this, Angle);
  }

  createClass(Angle, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Angle;
    }
  }], [{
    key: 'toDegrees',
    value: function toDegrees(radians) {
      return radians * 180 / Math.PI;
    }
  }, {
    key: 'normalize',
    value: function normalize(angle) {
      while (angle > Math.PI) {
        angle -= Angle.PI_TIMES_2;
      }while (angle <= -Math.PI) {
        angle += Angle.PI_TIMES_2;
      }return angle;
    }
  }, {
    key: 'angle',
    value: function angle() {
      if (arguments.length === 1) {
        var p = arguments[0];
        return Math.atan2(p.y, p.x);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        return Math.atan2(dy, dx);
      }
    }
  }, {
    key: 'isAcute',
    value: function isAcute(p0, p1, p2) {
      var dx0 = p0.x - p1.x;
      var dy0 = p0.y - p1.y;
      var dx1 = p2.x - p1.x;
      var dy1 = p2.y - p1.y;
      var dotprod = dx0 * dx1 + dy0 * dy1;
      return dotprod > 0;
    }
  }, {
    key: 'isObtuse',
    value: function isObtuse(p0, p1, p2) {
      var dx0 = p0.x - p1.x;
      var dy0 = p0.y - p1.y;
      var dx1 = p2.x - p1.x;
      var dy1 = p2.y - p1.y;
      var dotprod = dx0 * dx1 + dy0 * dy1;
      return dotprod < 0;
    }
  }, {
    key: 'interiorAngle',
    value: function interiorAngle(p0, p1, p2) {
      var anglePrev = Angle.angle(p1, p0);
      var angleNext = Angle.angle(p1, p2);
      return Math.abs(angleNext - anglePrev);
    }
  }, {
    key: 'normalizePositive',
    value: function normalizePositive(angle) {
      if (angle < 0.0) {
        while (angle < 0.0) {
          angle += Angle.PI_TIMES_2;
        }if (angle >= Angle.PI_TIMES_2) angle = 0.0;
      } else {
        while (angle >= Angle.PI_TIMES_2) {
          angle -= Angle.PI_TIMES_2;
        }if (angle < 0.0) angle = 0.0;
      }
      return angle;
    }
  }, {
    key: 'angleBetween',
    value: function angleBetween(tip1, tail, tip2) {
      var a1 = Angle.angle(tail, tip1);
      var a2 = Angle.angle(tail, tip2);
      return Angle.diff(a1, a2);
    }
  }, {
    key: 'diff',
    value: function diff(ang1, ang2) {
      var delAngle = null;
      if (ang1 < ang2) {
        delAngle = ang2 - ang1;
      } else {
        delAngle = ang1 - ang2;
      }
      if (delAngle > Math.PI) {
        delAngle = 2 * Math.PI - delAngle;
      }
      return delAngle;
    }
  }, {
    key: 'toRadians',
    value: function toRadians(angleDegrees) {
      return angleDegrees * Math.PI / 180.0;
    }
  }, {
    key: 'getTurn',
    value: function getTurn(ang1, ang2) {
      var crossproduct = Math.sin(ang2 - ang1);
      if (crossproduct > 0) {
        return Angle.COUNTERCLOCKWISE;
      }
      if (crossproduct < 0) {
        return Angle.CLOCKWISE;
      }
      return Angle.NONE;
    }
  }, {
    key: 'angleBetweenOriented',
    value: function angleBetweenOriented(tip1, tail, tip2) {
      var a1 = Angle.angle(tail, tip1);
      var a2 = Angle.angle(tail, tip2);
      var angDel = a2 - a1;
      if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;
      if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;
      return angDel;
    }
  }, {
    key: 'PI_TIMES_2',
    get: function get$$1() {
      return 2.0 * Math.PI;
    }
  }, {
    key: 'PI_OVER_2',
    get: function get$$1() {
      return Math.PI / 2.0;
    }
  }, {
    key: 'PI_OVER_4',
    get: function get$$1() {
      return Math.PI / 4.0;
    }
  }, {
    key: 'COUNTERCLOCKWISE',
    get: function get$$1() {
      return CGAlgorithms.COUNTERCLOCKWISE;
    }
  }, {
    key: 'CLOCKWISE',
    get: function get$$1() {
      return CGAlgorithms.CLOCKWISE;
    }
  }, {
    key: 'NONE',
    get: function get$$1() {
      return CGAlgorithms.COLLINEAR;
    }
  }]);
  return Angle;
}();

var OffsetSegmentGenerator = function () {
  function OffsetSegmentGenerator() {
    classCallCheck(this, OffsetSegmentGenerator);

    this._maxCurveSegmentError = 0.0;
    this._filletAngleQuantum = null;
    this._closingSegLengthFactor = 1;
    this._segList = null;
    this._distance = 0.0;
    this._precisionModel = null;
    this._bufParams = null;
    this._li = null;
    this._s0 = null;
    this._s1 = null;
    this._s2 = null;
    this._seg0 = new LineSegment();
    this._seg1 = new LineSegment();
    this._offset0 = new LineSegment();
    this._offset1 = new LineSegment();
    this._side = 0;
    this._hasNarrowConcaveAngle = false;
    var precisionModel = arguments[0];
    var bufParams = arguments[1];
    var distance = arguments[2];
    this._precisionModel = precisionModel;
    this._bufParams = bufParams;
    this._li = new RobustLineIntersector();
    this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
    if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
    this.init(distance);
  }

  createClass(OffsetSegmentGenerator, [{
    key: 'addNextSegment',
    value: function addNextSegment(p, addStartPoint) {
      this._s0 = this._s1;
      this._s1 = this._s2;
      this._s2 = p;
      this._seg0.setCoordinates(this._s0, this._s1);
      this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
      this._seg1.setCoordinates(this._s1, this._s2);
      this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
      if (this._s1.equals(this._s2)) return null;
      var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);
      var outsideTurn = orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;
      if (orientation === 0) {
        this.addCollinear(addStartPoint);
      } else if (outsideTurn) {
        this.addOutsideTurn(orientation, addStartPoint);
      } else {
        this.addInsideTurn(orientation, addStartPoint);
      }
    }
  }, {
    key: 'addLineEndCap',
    value: function addLineEndCap(p0, p1) {
      var seg = new LineSegment(p0, p1);
      var offsetL = new LineSegment();
      this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
      var offsetR = new LineSegment();
      this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;
      var angle = Math.atan2(dy, dx);
      switch (this._bufParams.getEndCapStyle()) {
        case BufferParameters.CAP_ROUND:
          this._segList.addPt(offsetL.p1);
          this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);
          this._segList.addPt(offsetR.p1);
          break;
        case BufferParameters.CAP_FLAT:
          this._segList.addPt(offsetL.p1);
          this._segList.addPt(offsetR.p1);
          break;
        case BufferParameters.CAP_SQUARE:
          var squareCapSideOffset = new Coordinate();
          squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
          squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
          var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
          var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
          this._segList.addPt(squareCapLOffset);
          this._segList.addPt(squareCapROffset);
          break;
        default:
      }
    }
  }, {
    key: 'getCoordinates',
    value: function getCoordinates() {
      var pts = this._segList.getCoordinates();
      return pts;
    }
  }, {
    key: 'addMitreJoin',
    value: function addMitreJoin(p, offset0, offset1, distance) {
      var isMitreWithinLimit = true;
      var intPt = null;
      try {
        intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
        var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
        if (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;
      } catch (ex) {
        if (ex instanceof NotRepresentableException) {
          intPt = new Coordinate(0, 0);
          isMitreWithinLimit = false;
        } else throw ex;
      } finally {}
      if (isMitreWithinLimit) {
        this._segList.addPt(intPt);
      } else {
        this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
      }
    }
  }, {
    key: 'addFilletCorner',
    value: function addFilletCorner(p, p0, p1, direction, radius) {
      var dx0 = p0.x - p.x;
      var dy0 = p0.y - p.y;
      var startAngle = Math.atan2(dy0, dx0);
      var dx1 = p1.x - p.x;
      var dy1 = p1.y - p.y;
      var endAngle = Math.atan2(dy1, dx1);
      if (direction === CGAlgorithms.CLOCKWISE) {
        if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;
      } else {
        if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;
      }
      this._segList.addPt(p0);
      this.addFilletArc(p, startAngle, endAngle, direction, radius);
      this._segList.addPt(p1);
    }
  }, {
    key: 'addOutsideTurn',
    value: function addOutsideTurn(orientation, addStartPoint) {
      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
        this._segList.addPt(this._offset0.p1);
        return null;
      }
      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
        this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
      } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
        this.addBevelJoin(this._offset0, this._offset1);
      } else {
        if (addStartPoint) this._segList.addPt(this._offset0.p1);
        this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
        this._segList.addPt(this._offset1.p0);
      }
    }
  }, {
    key: 'createSquare',
    value: function createSquare(p) {
      this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
      this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
      this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
      this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
      this._segList.closeRing();
    }
  }, {
    key: 'addSegments',
    value: function addSegments(pt, isForward) {
      this._segList.addPts(pt, isForward);
    }
  }, {
    key: 'addFirstSegment',
    value: function addFirstSegment() {
      this._segList.addPt(this._offset1.p0);
    }
  }, {
    key: 'addLastSegment',
    value: function addLastSegment() {
      this._segList.addPt(this._offset1.p1);
    }
  }, {
    key: 'initSideSegments',
    value: function initSideSegments(s1, s2, side) {
      this._s1 = s1;
      this._s2 = s2;
      this._side = side;
      this._seg1.setCoordinates(s1, s2);
      this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
    }
  }, {
    key: 'addLimitedMitreJoin',
    value: function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {
      var basePt = this._seg0.p1;
      var ang0 = Angle.angle(basePt, this._seg0.p0);
      // const ang1 = Angle.angle(basePt, this._seg1.p1)
      var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
      var angDiffHalf = angDiff / 2;
      var midAng = Angle.normalize(ang0 + angDiffHalf);
      var mitreMidAng = Angle.normalize(midAng + Math.PI);
      var mitreDist = mitreLimit * distance;
      var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
      var bevelHalfLen = distance - bevelDelta;
      var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
      var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
      var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
      var mitreMidLine = new LineSegment(basePt, bevelMidPt);
      var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
      var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
      if (this._side === Position.LEFT) {
        this._segList.addPt(bevelEndLeft);
        this._segList.addPt(bevelEndRight);
      } else {
        this._segList.addPt(bevelEndRight);
        this._segList.addPt(bevelEndLeft);
      }
    }
  }, {
    key: 'computeOffsetSegment',
    value: function computeOffsetSegment(seg, side, distance, offset) {
      var sideSign = side === Position.LEFT ? 1 : -1;
      var dx = seg.p1.x - seg.p0.x;
      var dy = seg.p1.y - seg.p0.y;
      var len = Math.sqrt(dx * dx + dy * dy);
      var ux = sideSign * distance * dx / len;
      var uy = sideSign * distance * dy / len;
      offset.p0.x = seg.p0.x - uy;
      offset.p0.y = seg.p0.y + ux;
      offset.p1.x = seg.p1.x - uy;
      offset.p1.y = seg.p1.y + ux;
    }
  }, {
    key: 'addFilletArc',
    value: function addFilletArc(p, startAngle, endAngle, direction, radius) {
      var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;
      var totalAngle = Math.abs(startAngle - endAngle);
      var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
      if (nSegs < 1) return null;
      var initAngle = 0.0;
      var currAngleInc = totalAngle / nSegs;
      var currAngle = initAngle;
      var pt = new Coordinate();
      while (currAngle < totalAngle) {
        var angle = startAngle + directionFactor * currAngle;
        pt.x = p.x + radius * Math.cos(angle);
        pt.y = p.y + radius * Math.sin(angle);
        this._segList.addPt(pt);
        currAngle += currAngleInc;
      }
    }
  }, {
    key: 'addInsideTurn',
    value: function addInsideTurn(orientation, addStartPoint) {
      this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
      if (this._li.hasIntersection()) {
        this._segList.addPt(this._li.getIntersection(0));
      } else {
        this._hasNarrowConcaveAngle = true;
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
          this._segList.addPt(this._offset0.p1);
        } else {
          this._segList.addPt(this._offset0.p1);
          if (this._closingSegLengthFactor > 0) {
            var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(mid0);
            var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
            this._segList.addPt(mid1);
          } else {
            this._segList.addPt(this._s1);
          }
          this._segList.addPt(this._offset1.p0);
        }
      }
    }
  }, {
    key: 'createCircle',
    value: function createCircle(p) {
      var pt = new Coordinate(p.x + this._distance, p.y);
      this._segList.addPt(pt);
      this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);
      this._segList.closeRing();
    }
  }, {
    key: 'addBevelJoin',
    value: function addBevelJoin(offset0, offset1) {
      this._segList.addPt(offset0.p1);
      this._segList.addPt(offset1.p0);
    }
  }, {
    key: 'init',
    value: function init(distance) {
      this._distance = distance;
      this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
      this._segList = new OffsetSegmentString();
      this._segList.setPrecisionModel(this._precisionModel);
      this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
    }
  }, {
    key: 'addCollinear',
    value: function addCollinear(addStartPoint) {
      this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
      var numInt = this._li.getIntersectionNum();
      if (numInt >= 2) {
        if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
          if (addStartPoint) this._segList.addPt(this._offset0.p1);
          this._segList.addPt(this._offset1.p0);
        } else {
          this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);
        }
      }
    }
  }, {
    key: 'closeRing',
    value: function closeRing() {
      this._segList.closeRing();
    }
  }, {
    key: 'hasNarrowConcaveAngle',
    value: function hasNarrowConcaveAngle() {
      return this._hasNarrowConcaveAngle;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OffsetSegmentGenerator;
    }
  }], [{
    key: 'OFFSET_SEGMENT_SEPARATION_FACTOR',
    get: function get$$1() {
      return 1.0E-3;
    }
  }, {
    key: 'INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR',
    get: function get$$1() {
      return 1.0E-3;
    }
  }, {
    key: 'CURVE_VERTEX_SNAP_DISTANCE_FACTOR',
    get: function get$$1() {
      return 1.0E-6;
    }
  }, {
    key: 'MAX_CLOSING_SEG_LEN_FACTOR',
    get: function get$$1() {
      return 80;
    }
  }]);
  return OffsetSegmentGenerator;
}();

var OffsetCurveBuilder = function () {
  function OffsetCurveBuilder() {
    classCallCheck(this, OffsetCurveBuilder);

    this._distance = 0.0;
    this._precisionModel = null;
    this._bufParams = null;
    var precisionModel = arguments[0];
    var bufParams = arguments[1];
    this._precisionModel = precisionModel;
    this._bufParams = bufParams;
  }

  createClass(OffsetCurveBuilder, [{
    key: 'getOffsetCurve',
    value: function getOffsetCurve(inputPts, distance) {
      this._distance = distance;
      if (distance === 0.0) return null;
      var isRightSide = distance < 0.0;
      var posDistance = Math.abs(distance);
      var segGen = this.getSegGen(posDistance);
      if (inputPts.length <= 1) {
        this.computePointCurve(inputPts[0], segGen);
      } else {
        this.computeOffsetCurve(inputPts, isRightSide, segGen);
      }
      var curvePts = segGen.getCoordinates();
      if (isRightSide) CoordinateArrays.reverse(curvePts);
      return curvePts;
    }
  }, {
    key: 'computeSingleSidedBufferCurve',
    value: function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      if (isRightSide) {
        segGen.addSegments(inputPts, true);
        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
        var n2 = simp2.length - 1;
        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
        segGen.addFirstSegment();
        for (var i = n2 - 2; i >= 0; i--) {
          segGen.addNextSegment(simp2[i], true);
        }
      } else {
        segGen.addSegments(inputPts, false);
        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
        var n1 = simp1.length - 1;
        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
        segGen.addFirstSegment();
        for (var _i = 2; _i <= n1; _i++) {
          segGen.addNextSegment(simp1[_i], true);
        }
      }
      segGen.addLastSegment();
      segGen.closeRing();
    }
  }, {
    key: 'computeRingBufferCurve',
    value: function computeRingBufferCurve(inputPts, side, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      if (side === Position.RIGHT) distTol = -distTol;
      var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
      var n = simp.length - 1;
      segGen.initSideSegments(simp[n - 1], simp[0], side);
      for (var i = 1; i <= n; i++) {
        var addStartPoint = i !== 1;
        segGen.addNextSegment(simp[i], addStartPoint);
      }
      segGen.closeRing();
    }
  }, {
    key: 'computeLineBufferCurve',
    value: function computeLineBufferCurve(inputPts, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
      var n1 = simp1.length - 1;
      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
      for (var i = 2; i <= n1; i++) {
        segGen.addNextSegment(simp1[i], true);
      }
      segGen.addLastSegment();
      segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
      var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
      var n2 = simp2.length - 1;
      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
      for (var _i2 = n2 - 2; _i2 >= 0; _i2--) {
        segGen.addNextSegment(simp2[_i2], true);
      }
      segGen.addLastSegment();
      segGen.addLineEndCap(simp2[1], simp2[0]);
      segGen.closeRing();
    }
  }, {
    key: 'computePointCurve',
    value: function computePointCurve(pt, segGen) {
      switch (this._bufParams.getEndCapStyle()) {
        case BufferParameters.CAP_ROUND:
          segGen.createCircle(pt);
          break;
        case BufferParameters.CAP_SQUARE:
          segGen.createSquare(pt);
          break;
        default:
      }
    }
  }, {
    key: 'getLineCurve',
    value: function getLineCurve(inputPts, distance) {
      this._distance = distance;
      if (distance < 0.0 && !this._bufParams.isSingleSided()) return null;
      if (distance === 0.0) return null;
      var posDistance = Math.abs(distance);
      var segGen = this.getSegGen(posDistance);
      if (inputPts.length <= 1) {
        this.computePointCurve(inputPts[0], segGen);
      } else {
        if (this._bufParams.isSingleSided()) {
          var isRightSide = distance < 0.0;
          this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
        } else this.computeLineBufferCurve(inputPts, segGen);
      }
      var lineCoord = segGen.getCoordinates();
      return lineCoord;
    }
  }, {
    key: 'getBufferParameters',
    value: function getBufferParameters() {
      return this._bufParams;
    }
  }, {
    key: 'simplifyTolerance',
    value: function simplifyTolerance(bufDistance) {
      return bufDistance * this._bufParams.getSimplifyFactor();
    }
  }, {
    key: 'getRingCurve',
    value: function getRingCurve(inputPts, side, distance) {
      this._distance = distance;
      if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);
      if (distance === 0.0) {
        return OffsetCurveBuilder.copyCoordinates(inputPts);
      }
      var segGen = this.getSegGen(distance);
      this.computeRingBufferCurve(inputPts, side, segGen);
      return segGen.getCoordinates();
    }
  }, {
    key: 'computeOffsetCurve',
    value: function computeOffsetCurve(inputPts, isRightSide, segGen) {
      var distTol = this.simplifyTolerance(this._distance);
      if (isRightSide) {
        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
        var n2 = simp2.length - 1;
        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
        segGen.addFirstSegment();
        for (var i = n2 - 2; i >= 0; i--) {
          segGen.addNextSegment(simp2[i], true);
        }
      } else {
        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
        var n1 = simp1.length - 1;
        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
        segGen.addFirstSegment();
        for (var _i3 = 2; _i3 <= n1; _i3++) {
          segGen.addNextSegment(simp1[_i3], true);
        }
      }
      segGen.addLastSegment();
    }
  }, {
    key: 'getSegGen',
    value: function getSegGen(distance) {
      return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OffsetCurveBuilder;
    }
  }], [{
    key: 'copyCoordinates',
    value: function copyCoordinates(pts) {
      var copy = new Array(pts.length).fill(null);
      for (var i = 0; i < copy.length; i++) {
        copy[i] = new Coordinate(pts[i]);
      }
      return copy;
    }
  }]);
  return OffsetCurveBuilder;
}();

var SubgraphDepthLocater = function () {
  function SubgraphDepthLocater() {
    classCallCheck(this, SubgraphDepthLocater);

    this._subgraphs = null;
    this._seg = new LineSegment();
    this._cga = new CGAlgorithms();
    var subgraphs = arguments[0];
    this._subgraphs = subgraphs;
  }

  createClass(SubgraphDepthLocater, [{
    key: 'findStabbedSegments',
    value: function findStabbedSegments() {
      if (arguments.length === 1) {
        var stabbingRayLeftPt = arguments[0];
        var stabbedSegments = new ArrayList();
        for (var i = this._subgraphs.iterator(); i.hasNext();) {
          var bsg = i.next();
          var env = bsg.getEnvelope();
          if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;
          this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
        }
        return stabbedSegments;
      } else if (arguments.length === 3) {
        if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {
          var _stabbingRayLeftPt = arguments[0];
          var dirEdge = arguments[1];
          var _stabbedSegments = arguments[2];
          var pts = dirEdge.getEdge().getCoordinates();
          for (var _i = 0; _i < pts.length - 1; _i++) {
            this._seg.p0 = pts[_i];
            this._seg.p1 = pts[_i + 1];
            if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();
            var maxx = Math.max(this._seg.p0.x, this._seg.p1.x);
            if (maxx < _stabbingRayLeftPt.x) continue;
            if (this._seg.isHorizontal()) continue;
            if (_stabbingRayLeftPt.y < this._seg.p0.y || _stabbingRayLeftPt.y > this._seg.p1.y) continue;
            if (CGAlgorithms.computeOrientation(this._seg.p0, this._seg.p1, _stabbingRayLeftPt) === CGAlgorithms.RIGHT) continue;
            var depth = dirEdge.getDepth(Position.LEFT);
            if (!this._seg.p0.equals(pts[_i])) depth = dirEdge.getDepth(Position.RIGHT);
            var ds = new DepthSegment(this._seg, depth);
            _stabbedSegments.add(ds);
          }
        } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {
          var _stabbingRayLeftPt2 = arguments[0];
          var dirEdges = arguments[1];
          var _stabbedSegments2 = arguments[2];
          for (var _i2 = dirEdges.iterator(); _i2.hasNext();) {
            var de = _i2.next();
            if (!de.isForward()) continue;
            this.findStabbedSegments(_stabbingRayLeftPt2, de, _stabbedSegments2);
          }
        }
      }
    }
  }, {
    key: 'getDepth',
    value: function getDepth(p) {
      var stabbedSegments = this.findStabbedSegments(p);
      if (stabbedSegments.size() === 0) return 0;
      var ds = Collections.min(stabbedSegments);
      return ds._leftDepth;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SubgraphDepthLocater;
    }
  }], [{
    key: 'DepthSegment',
    get: function get$$1() {
      return DepthSegment;
    }
  }]);
  return SubgraphDepthLocater;
}();

var DepthSegment = function () {
  function DepthSegment() {
    classCallCheck(this, DepthSegment);

    this._upwardSeg = null;
    this._leftDepth = null;
    var seg = arguments[0];
    var depth = arguments[1];
    this._upwardSeg = new LineSegment(seg);
    this._leftDepth = depth;
  }

  createClass(DepthSegment, [{
    key: 'compareTo',
    value: function compareTo(obj) {
      var other = obj;
      if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;
      if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;
      var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
      if (orientIndex !== 0) return orientIndex;
      orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
      if (orientIndex !== 0) return orientIndex;
      return this._upwardSeg.compareTo(other._upwardSeg);
    }
  }, {
    key: 'compareX',
    value: function compareX(seg0, seg1) {
      var compare0 = seg0.p0.compareTo(seg1.p0);
      if (compare0 !== 0) return compare0;
      return seg0.p1.compareTo(seg1.p1);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this._upwardSeg.toString();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DepthSegment;
    }
  }]);
  return DepthSegment;
}();

var Triangle = function () {
  function Triangle(p0, p1, p2) {
    classCallCheck(this, Triangle);

    this.p0 = p0 || null;
    this.p1 = p1 || null;
    this.p2 = p2 || null;
  }

  createClass(Triangle, [{
    key: 'area',
    value: function area() {
      return Triangle.area(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'signedArea',
    value: function signedArea() {
      return Triangle.signedArea(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'interpolateZ',
    value: function interpolateZ(p) {
      if (p === null) throw new IllegalArgumentException('Supplied point is null.');
      return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);
    }
  }, {
    key: 'longestSideLength',
    value: function longestSideLength() {
      return Triangle.longestSideLength(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'isAcute',
    value: function isAcute() {
      return Triangle.isAcute(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'circumcentre',
    value: function circumcentre() {
      return Triangle.circumcentre(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'area3D',
    value: function area3D() {
      return Triangle.area3D(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'centroid',
    value: function centroid() {
      return Triangle.centroid(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'inCentre',
    value: function inCentre() {
      return Triangle.inCentre(this.p0, this.p1, this.p2);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Triangle;
    }
  }], [{
    key: 'area',
    value: function area(a, b, c) {
      return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
    }
  }, {
    key: 'signedArea',
    value: function signedArea(a, b, c) {
      return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
    }
  }, {
    key: 'det',
    value: function det(m00, m01, m10, m11) {
      return m00 * m11 - m01 * m10;
    }
  }, {
    key: 'interpolateZ',
    value: function interpolateZ(p, v0, v1, v2) {
      var x0 = v0.x;
      var y0 = v0.y;
      var a = v1.x - x0;
      var b = v2.x - x0;
      var c = v1.y - y0;
      var d = v2.y - y0;
      var det = a * d - b * c;
      var dx = p.x - x0;
      var dy = p.y - y0;
      var t = (d * dx - b * dy) / det;
      var u = (-c * dx + a * dy) / det;
      var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
      return z;
    }
  }, {
    key: 'longestSideLength',
    value: function longestSideLength(a, b, c) {
      var lenAB = a.distance(b);
      var lenBC = b.distance(c);
      var lenCA = c.distance(a);
      var maxLen = lenAB;
      if (lenBC > maxLen) maxLen = lenBC;
      if (lenCA > maxLen) maxLen = lenCA;
      return maxLen;
    }
  }, {
    key: 'isAcute',
    value: function isAcute(a, b, c) {
      if (!Angle.isAcute(a, b, c)) return false;
      if (!Angle.isAcute(b, c, a)) return false;
      if (!Angle.isAcute(c, a, b)) return false;
      return true;
    }
  }, {
    key: 'circumcentre',
    value: function circumcentre(a, b, c) {
      var cx = c.x;
      var cy = c.y;
      var ax = a.x - cx;
      var ay = a.y - cy;
      var bx = b.x - cx;
      var by = b.y - cy;
      var denom = 2 * Triangle.det(ax, ay, bx, by);
      var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
      var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
      var ccx = cx - numx / denom;
      var ccy = cy + numy / denom;
      return new Coordinate(ccx, ccy);
    }
  }, {
    key: 'perpendicularBisector',
    value: function perpendicularBisector(a, b) {
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
      var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
      return new HCoordinate(l1, l2);
    }
  }, {
    key: 'angleBisector',
    value: function angleBisector(a, b, c) {
      var len0 = b.distance(a);
      var len2 = b.distance(c);
      var frac = len0 / (len0 + len2);
      var dx = c.x - a.x;
      var dy = c.y - a.y;
      var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
      return splitPt;
    }
  }, {
    key: 'area3D',
    value: function area3D(a, b, c) {
      var ux = b.x - a.x;
      var uy = b.y - a.y;
      var uz = b.z - a.z;
      var vx = c.x - a.x;
      var vy = c.y - a.y;
      var vz = c.z - a.z;
      var crossx = uy * vz - uz * vy;
      var crossy = uz * vx - ux * vz;
      var crossz = ux * vy - uy * vx;
      var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
      var area3D = Math.sqrt(absSq) / 2;
      return area3D;
    }
  }, {
    key: 'centroid',
    value: function centroid(a, b, c) {
      var x = (a.x + b.x + c.x) / 3;
      var y = (a.y + b.y + c.y) / 3;
      return new Coordinate(x, y);
    }
  }, {
    key: 'inCentre',
    value: function inCentre(a, b, c) {
      var len0 = b.distance(c);
      var len1 = a.distance(c);
      var len2 = a.distance(b);
      var circum = len0 + len1 + len2;
      var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
      var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
      return new Coordinate(inCentreX, inCentreY);
    }
  }]);
  return Triangle;
}();

var OffsetCurveSetBuilder = function () {
  function OffsetCurveSetBuilder() {
    classCallCheck(this, OffsetCurveSetBuilder);

    this._inputGeom = null;
    this._distance = null;
    this._curveBuilder = null;
    this._curveList = new ArrayList();
    var inputGeom = arguments[0];
    var distance = arguments[1];
    var curveBuilder = arguments[2];
    this._inputGeom = inputGeom;
    this._distance = distance;
    this._curveBuilder = curveBuilder;
  }

  createClass(OffsetCurveSetBuilder, [{
    key: 'addPoint',
    value: function addPoint(p) {
      if (this._distance <= 0.0) return null;
      var coord = p.getCoordinates();
      var curve = this._curveBuilder.getLineCurve(coord, this._distance);
      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
    }
  }, {
    key: 'addPolygon',
    value: function addPolygon(p) {
      var offsetDistance = this._distance;
      var offsetSide = Position.LEFT;
      if (this._distance < 0.0) {
        offsetDistance = -this._distance;
        offsetSide = Position.RIGHT;
      }
      var shell = p.getExteriorRing();
      var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
      if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;
      if (this._distance <= 0.0 && shellCoord.length < 3) return null;
      this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
      for (var i = 0; i < p.getNumInteriorRing(); i++) {
        var hole = p.getInteriorRingN(i);
        var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
        if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;
        this.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
      }
    }
  }, {
    key: 'isTriangleErodedCompletely',
    value: function isTriangleErodedCompletely(triangleCoord, bufferDistance) {
      var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
      var inCentre = tri.inCentre();
      var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);
      return distToCentre < Math.abs(bufferDistance);
    }
  }, {
    key: 'addLineString',
    value: function addLineString(line) {
      if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;
      var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
      var curve = this._curveBuilder.getLineCurve(coord, this._distance);
      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
    }
  }, {
    key: 'addCurve',
    value: function addCurve(coord, leftLoc, rightLoc) {
      if (coord === null || coord.length < 2) return null;
      var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
      this._curveList.add(e);
    }
  }, {
    key: 'getCurves',
    value: function getCurves() {
      this.add(this._inputGeom);
      return this._curveList;
    }
  }, {
    key: 'addPolygonRing',
    value: function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
      if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;
      var leftLoc = cwLeftLoc;
      var rightLoc = cwRightLoc;
      if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {
        leftLoc = cwRightLoc;
        rightLoc = cwLeftLoc;
        side = Position.opposite(side);
      }
      var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
      this.addCurve(curve, leftLoc, rightLoc);
    }
  }, {
    key: 'add',
    value: function add(g) {
      if (g.isEmpty()) return null;
      if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);
      // else throw new UnsupportedOperationException(g.getClass().getName())
    }
  }, {
    key: 'isErodedCompletely',
    value: function isErodedCompletely(ring, bufferDistance) {
      var ringCoord = ring.getCoordinates();
      // const minDiam = 0.0
      if (ringCoord.length < 4) return bufferDistance < 0;
      if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
      var env = ring.getEnvelopeInternal();
      var envMinDimension = Math.min(env.getHeight(), env.getWidth());
      if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;
      return false;
    }
  }, {
    key: 'addCollection',
    value: function addCollection(gc) {
      for (var i = 0; i < gc.getNumGeometries(); i++) {
        var g = gc.getGeometryN(i);
        this.add(g);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OffsetCurveSetBuilder;
    }
  }]);
  return OffsetCurveSetBuilder;
}();

var PointOnGeometryLocator = function () {
  function PointOnGeometryLocator() {
    classCallCheck(this, PointOnGeometryLocator);
  }

  createClass(PointOnGeometryLocator, [{
    key: "locate",
    value: function locate(p) {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return PointOnGeometryLocator;
    }
  }]);
  return PointOnGeometryLocator;
}();

var GeometryCollectionIterator = function () {
  function GeometryCollectionIterator() {
    classCallCheck(this, GeometryCollectionIterator);

    this._parent = null;
    this._atStart = null;
    this._max = null;
    this._index = null;
    this._subcollectionIterator = null;
    var parent = arguments[0];
    this._parent = parent;
    this._atStart = true;
    this._index = 0;
    this._max = parent.getNumGeometries();
  }

  createClass(GeometryCollectionIterator, [{
    key: 'next',
    value: function next() {
      if (this._atStart) {
        this._atStart = false;
        if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;
        return this._parent;
      }
      if (this._subcollectionIterator !== null) {
        if (this._subcollectionIterator.hasNext()) {
          return this._subcollectionIterator.next();
        } else {
          this._subcollectionIterator = null;
        }
      }
      if (this._index >= this._max) {
        throw new NoSuchElementException();
      }
      var obj = this._parent.getGeometryN(this._index++);
      if (obj instanceof GeometryCollection) {
        this._subcollectionIterator = new GeometryCollectionIterator(obj);
        return this._subcollectionIterator.next();
      }
      return obj;
    }
  }, {
    key: 'remove',
    value: function remove() {
      throw new Error(this.getClass().getName());
    }
  }, {
    key: 'hasNext',
    value: function hasNext() {
      if (this._atStart) {
        return true;
      }
      if (this._subcollectionIterator !== null) {
        if (this._subcollectionIterator.hasNext()) {
          return true;
        }
        this._subcollectionIterator = null;
      }
      if (this._index >= this._max) {
        return false;
      }
      return true;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Iterator];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryCollectionIterator;
    }
  }], [{
    key: 'isAtomic',
    value: function isAtomic(geom) {
      return !(geom instanceof GeometryCollection);
    }
  }]);
  return GeometryCollectionIterator;
}();

var SimplePointInAreaLocator = function () {
  function SimplePointInAreaLocator() {
    classCallCheck(this, SimplePointInAreaLocator);

    this._geom = null;
    var geom = arguments[0];
    this._geom = geom;
  }

  createClass(SimplePointInAreaLocator, [{
    key: 'locate',
    value: function locate(p) {
      return SimplePointInAreaLocator.locate(p, this._geom);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [PointOnGeometryLocator];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SimplePointInAreaLocator;
    }
  }], [{
    key: 'isPointInRing',
    value: function isPointInRing(p, ring) {
      if (!ring.getEnvelopeInternal().intersects(p)) return false;
      return CGAlgorithms.isPointInRing(p, ring.getCoordinates());
    }
  }, {
    key: 'containsPointInPolygon',
    value: function containsPointInPolygon(p, poly) {
      if (poly.isEmpty()) return false;
      var shell = poly.getExteriorRing();
      if (!SimplePointInAreaLocator.isPointInRing(p, shell)) return false;
      for (var i = 0; i < poly.getNumInteriorRing(); i++) {
        var hole = poly.getInteriorRingN(i);
        if (SimplePointInAreaLocator.isPointInRing(p, hole)) return false;
      }
      return true;
    }
  }, {
    key: 'containsPoint',
    value: function containsPoint(p, geom) {
      if (geom instanceof Polygon) {
        return SimplePointInAreaLocator.containsPointInPolygon(p, geom);
      } else if (geom instanceof GeometryCollection) {
        var geomi = new GeometryCollectionIterator(geom);
        while (geomi.hasNext()) {
          var g2 = geomi.next();
          if (g2 !== geom) if (SimplePointInAreaLocator.containsPoint(p, g2)) return true;
        }
      }
      return false;
    }
  }, {
    key: 'locate',
    value: function locate(p, geom) {
      if (geom.isEmpty()) return Location.EXTERIOR;
      if (SimplePointInAreaLocator.containsPoint(p, geom)) return Location.INTERIOR;
      return Location.EXTERIOR;
    }
  }]);
  return SimplePointInAreaLocator;
}();

var EdgeEndStar = function () {
  function EdgeEndStar() {
    classCallCheck(this, EdgeEndStar);

    this._edgeMap = new TreeMap();
    this._edgeList = null;
    this._ptInAreaLocation = [Location.NONE, Location.NONE];
  }

  createClass(EdgeEndStar, [{
    key: 'getNextCW',
    value: function getNextCW(ee) {
      this.getEdges();
      var i = this._edgeList.indexOf(ee);
      var iNextCW = i - 1;
      if (i === 0) iNextCW = this._edgeList.size() - 1;
      return this._edgeList.get(iNextCW);
    }
  }, {
    key: 'propagateSideLabels',
    value: function propagateSideLabels(geomIndex) {
      var startLoc = Location.NONE;
      for (var it = this.iterator(); it.hasNext();) {
        var e = it.next();
        var label = e.getLabel();
        if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);
      }
      if (startLoc === Location.NONE) return null;
      var currLoc = startLoc;
      for (var _it = this.iterator(); _it.hasNext();) {
        var _e = _it.next();
        var _label = _e.getLabel();
        if (_label.getLocation(geomIndex, Position.ON) === Location.NONE) _label.setLocation(geomIndex, Position.ON, currLoc);
        if (_label.isArea(geomIndex)) {
          var leftLoc = _label.getLocation(geomIndex, Position.LEFT);
          var rightLoc = _label.getLocation(geomIndex, Position.RIGHT);
          if (rightLoc !== Location.NONE) {
            if (rightLoc !== currLoc) throw new TopologyException('side location conflict', _e.getCoordinate());
            if (leftLoc === Location.NONE) {
              Assert.shouldNeverReachHere('found single null side (at ' + _e.getCoordinate() + ')');
            }
            currLoc = leftLoc;
          } else {
            Assert.isTrue(_label.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');
            _label.setLocation(geomIndex, Position.RIGHT, currLoc);
            _label.setLocation(geomIndex, Position.LEFT, currLoc);
          }
        }
      }
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      var it = this.iterator();
      if (!it.hasNext()) return null;
      var e = it.next();
      return e.getCoordinate();
    }
  }, {
    key: 'print',
    value: function print(out) {
      System.out.println('EdgeEndStar:   ' + this.getCoordinate());
      for (var it = this.iterator(); it.hasNext();) {
        var e = it.next();
        e.print(out);
      }
    }
  }, {
    key: 'isAreaLabelsConsistent',
    value: function isAreaLabelsConsistent(geomGraph) {
      this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
      return this.checkAreaLabelsConsistent(0);
    }
  }, {
    key: 'checkAreaLabelsConsistent',
    value: function checkAreaLabelsConsistent(geomIndex) {
      var edges = this.getEdges();
      if (edges.size() <= 0) return true;
      var lastEdgeIndex = edges.size() - 1;
      var startLabel = edges.get(lastEdgeIndex).getLabel();
      var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
      Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');
      var currLoc = startLoc;
      for (var it = this.iterator(); it.hasNext();) {
        var e = it.next();
        var label = e.getLabel();
        Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');
        var leftLoc = label.getLocation(geomIndex, Position.LEFT);
        var rightLoc = label.getLocation(geomIndex, Position.RIGHT);
        if (leftLoc === rightLoc) {
          return false;
        }
        if (rightLoc !== currLoc) {
          return false;
        }
        currLoc = leftLoc;
      }
      return true;
    }
  }, {
    key: 'findIndex',
    value: function findIndex(eSearch) {
      this.iterator();
      for (var i = 0; i < this._edgeList.size(); i++) {
        var e = this._edgeList.get(i);
        if (e === eSearch) return i;
      }
      return -1;
    }
  }, {
    key: 'iterator',
    value: function iterator() {
      return this.getEdges().iterator();
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      if (this._edgeList === null) {
        this._edgeList = new ArrayList(this._edgeMap.values());
      }
      return this._edgeList;
    }
  }, {
    key: 'getLocation',
    value: function getLocation(geomIndex, p, geom) {
      if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
        this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
      }
      return this._ptInAreaLocation[geomIndex];
    }
  }, {
    key: 'toString',
    value: function toString() {
      var buf = new StringBuffer();
      buf.append('EdgeEndStar:   ' + this.getCoordinate());
      buf.append('\n');
      for (var it = this.iterator(); it.hasNext();) {
        var e = it.next();
        buf.append(e);
        buf.append('\n');
      }
      return buf.toString();
    }
  }, {
    key: 'computeEdgeEndLabels',
    value: function computeEdgeEndLabels(boundaryNodeRule) {
      for (var it = this.iterator(); it.hasNext();) {
        var ee = it.next();
        ee.computeLabel(boundaryNodeRule);
      }
    }
  }, {
    key: 'computeLabelling',
    value: function computeLabelling(geomGraph) {
      this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
      this.propagateSideLabels(0);
      this.propagateSideLabels(1);
      var hasDimensionalCollapseEdge = [false, false];
      for (var it = this.iterator(); it.hasNext();) {
        var e = it.next();
        var label = e.getLabel();
        for (var geomi = 0; geomi < 2; geomi++) {
          if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;
        }
      }
      for (var _it2 = this.iterator(); _it2.hasNext();) {
        var _e2 = _it2.next();
        var _label2 = _e2.getLabel();
        for (var _geomi = 0; _geomi < 2; _geomi++) {
          if (_label2.isAnyNull(_geomi)) {
            var loc = Location.NONE;
            if (hasDimensionalCollapseEdge[_geomi]) {
              loc = Location.EXTERIOR;
            } else {
              var p = _e2.getCoordinate();
              loc = this.getLocation(_geomi, p, geomGraph);
            }
            _label2.setAllLocationsIfNull(_geomi, loc);
          }
        }
      }
    }
  }, {
    key: 'getDegree',
    value: function getDegree() {
      return this._edgeMap.size();
    }
  }, {
    key: 'insertEdgeEnd',
    value: function insertEdgeEnd(e, obj) {
      this._edgeMap.put(e, obj);
      this._edgeList = null;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeEndStar;
    }
  }]);
  return EdgeEndStar;
}();

var DirectedEdgeStar = function (_EdgeEndStar) {
  inherits(DirectedEdgeStar, _EdgeEndStar);

  function DirectedEdgeStar() {
    classCallCheck(this, DirectedEdgeStar);

    var _this = possibleConstructorReturn(this, (DirectedEdgeStar.__proto__ || Object.getPrototypeOf(DirectedEdgeStar)).call(this));

    _this._resultAreaEdgeList = null;
    _this._label = null;
    _this._SCANNING_FOR_INCOMING = 1;
    _this._LINKING_TO_OUTGOING = 2;
    return _this;
  }

  createClass(DirectedEdgeStar, [{
    key: 'linkResultDirectedEdges',
    value: function linkResultDirectedEdges() {
      this.getResultAreaEdges();
      var firstOut = null;
      var incoming = null;
      var state = this._SCANNING_FOR_INCOMING;
      for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
        var nextOut = this._resultAreaEdgeList.get(i);
        var nextIn = nextOut.getSym();
        if (!nextOut.getLabel().isArea()) continue;
        if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;
        switch (state) {
          case this._SCANNING_FOR_INCOMING:
            if (!nextIn.isInResult()) continue;
            incoming = nextIn;
            state = this._LINKING_TO_OUTGOING;
            break;
          case this._LINKING_TO_OUTGOING:
            if (!nextOut.isInResult()) continue;
            incoming.setNext(nextOut);
            state = this._SCANNING_FOR_INCOMING;
            break;
          default:
        }
      }
      if (state === this._LINKING_TO_OUTGOING) {
        if (firstOut === null) throw new TopologyException('no outgoing dirEdge found', this.getCoordinate());
        Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');
        incoming.setNext(firstOut);
      }
    }
  }, {
    key: 'insert',
    value: function insert(ee) {
      var de = ee;
      this.insertEdgeEnd(de, de);
    }
  }, {
    key: 'getRightmostEdge',
    value: function getRightmostEdge() {
      var edges = this.getEdges();
      var size = edges.size();
      if (size < 1) return null;
      var de0 = edges.get(0);
      if (size === 1) return de0;
      var deLast = edges.get(size - 1);
      var quad0 = de0.getQuadrant();
      var quad1 = deLast.getQuadrant();
      if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0;else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast;else {
        // const nonHorizontalEdge = null
        if (de0.getDy() !== 0) return de0;else if (deLast.getDy() !== 0) return deLast;
      }
      Assert.shouldNeverReachHere('found two horizontal edges incident on node');
      return null;
    }
  }, {
    key: 'print',
    value: function print(out) {
      System.out.println('DirectedEdgeStar: ' + this.getCoordinate());
      for (var it = this.iterator(); it.hasNext();) {
        var de = it.next();
        out.print('out ');
        de.print(out);
        out.println();
        out.print('in ');
        de.getSym().print(out);
        out.println();
      }
    }
  }, {
    key: 'getResultAreaEdges',
    value: function getResultAreaEdges() {
      if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
      this._resultAreaEdgeList = new ArrayList();
      for (var it = this.iterator(); it.hasNext();) {
        var de = it.next();
        if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);
      }
      return this._resultAreaEdgeList;
    }
  }, {
    key: 'updateLabelling',
    value: function updateLabelling(nodeLabel) {
      for (var it = this.iterator(); it.hasNext();) {
        var de = it.next();
        var label = de.getLabel();
        label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
        label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
      }
    }
  }, {
    key: 'linkAllDirectedEdges',
    value: function linkAllDirectedEdges() {
      this.getEdges();
      var prevOut = null;
      var firstIn = null;
      for (var i = this._edgeList.size() - 1; i >= 0; i--) {
        var nextOut = this._edgeList.get(i);
        var nextIn = nextOut.getSym();
        if (firstIn === null) firstIn = nextIn;
        if (prevOut !== null) nextIn.setNext(prevOut);
        prevOut = nextOut;
      }
      firstIn.setNext(prevOut);
    }
  }, {
    key: 'computeDepths',
    value: function computeDepths() {
      if (arguments.length === 1) {
        var de = arguments[0];
        var edgeIndex = this.findIndex(de);
        // const label = de.getLabel()
        var startDepth = de.getDepth(Position.LEFT);
        var targetLastDepth = de.getDepth(Position.RIGHT);
        var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
        var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
        if (lastDepth !== targetLastDepth) throw new TopologyException('depth mismatch at ' + de.getCoordinate());
      } else if (arguments.length === 3) {
        var startIndex = arguments[0];
        var endIndex = arguments[1];
        var _startDepth = arguments[2];
        var currDepth = _startDepth;
        for (var i = startIndex; i < endIndex; i++) {
          var nextDe = this._edgeList.get(i);
          // const label = nextDe.getLabel()
          nextDe.setEdgeDepths(Position.RIGHT, currDepth);
          currDepth = nextDe.getDepth(Position.LEFT);
        }
        return currDepth;
      }
    }
  }, {
    key: 'mergeSymLabels',
    value: function mergeSymLabels() {
      for (var it = this.iterator(); it.hasNext();) {
        var de = it.next();
        var label = de.getLabel();
        label.merge(de.getSym().getLabel());
      }
    }
  }, {
    key: 'linkMinimalDirectedEdges',
    value: function linkMinimalDirectedEdges(er) {
      var firstOut = null;
      var incoming = null;
      var state = this._SCANNING_FOR_INCOMING;
      for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
        var nextOut = this._resultAreaEdgeList.get(i);
        var nextIn = nextOut.getSym();
        if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;
        switch (state) {
          case this._SCANNING_FOR_INCOMING:
            if (nextIn.getEdgeRing() !== er) continue;
            incoming = nextIn;
            state = this._LINKING_TO_OUTGOING;
            break;
          case this._LINKING_TO_OUTGOING:
            if (nextOut.getEdgeRing() !== er) continue;
            incoming.setNextMin(nextOut);
            state = this._SCANNING_FOR_INCOMING;
            break;
          default:
        }
      }
      if (state === this._LINKING_TO_OUTGOING) {
        Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
        Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');
        incoming.setNextMin(firstOut);
      }
    }
  }, {
    key: 'getOutgoingDegree',
    value: function getOutgoingDegree() {
      if (arguments.length === 0) {
        var degree = 0;
        for (var it = this.iterator(); it.hasNext();) {
          var de = it.next();
          if (de.isInResult()) degree++;
        }
        return degree;
      } else if (arguments.length === 1) {
        var er = arguments[0];
        var _degree = 0;
        for (var _it = this.iterator(); _it.hasNext();) {
          var _de = _it.next();
          if (_de.getEdgeRing() === er) _degree++;
        }
        return _degree;
      }
    }
  }, {
    key: 'getLabel',
    value: function getLabel() {
      return this._label;
    }
  }, {
    key: 'findCoveredLineEdges',
    value: function findCoveredLineEdges() {
      var startLoc = Location.NONE;
      for (var it = this.iterator(); it.hasNext();) {
        var nextOut = it.next();
        var nextIn = nextOut.getSym();
        if (!nextOut.isLineEdge()) {
          if (nextOut.isInResult()) {
            startLoc = Location.INTERIOR;
            break;
          }
          if (nextIn.isInResult()) {
            startLoc = Location.EXTERIOR;
            break;
          }
        }
      }
      if (startLoc === Location.NONE) return null;
      var currLoc = startLoc;
      for (var _it2 = this.iterator(); _it2.hasNext();) {
        var _nextOut = _it2.next();
        var _nextIn = _nextOut.getSym();
        if (_nextOut.isLineEdge()) {
          _nextOut.getEdge().setCovered(currLoc === Location.INTERIOR);
        } else {
          if (_nextOut.isInResult()) currLoc = Location.EXTERIOR;
          if (_nextIn.isInResult()) currLoc = Location.INTERIOR;
        }
      }
    }
  }, {
    key: 'computeLabelling',
    value: function computeLabelling(geom) {
      EdgeEndStar.prototype.computeLabelling.call(this, geom);
      this._label = new Label(Location.NONE);
      for (var it = this.iterator(); it.hasNext();) {
        var ee = it.next();
        var e = ee.getEdge();
        var eLabel = e.getLabel();
        for (var i = 0; i < 2; i++) {
          var eLoc = eLabel.getLocation(i);
          if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DirectedEdgeStar;
    }
  }]);
  return DirectedEdgeStar;
}(EdgeEndStar);

var OverlayNodeFactory = function (_NodeFactory) {
  inherits(OverlayNodeFactory, _NodeFactory);

  function OverlayNodeFactory() {
    classCallCheck(this, OverlayNodeFactory);
    return possibleConstructorReturn(this, (OverlayNodeFactory.__proto__ || Object.getPrototypeOf(OverlayNodeFactory)).apply(this, arguments));
  }

  createClass(OverlayNodeFactory, [{
    key: 'createNode',
    value: function createNode(coord) {
      return new Node(coord, new DirectedEdgeStar());
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OverlayNodeFactory;
    }
  }]);
  return OverlayNodeFactory;
}(NodeFactory);

var OrientedCoordinateArray = function () {
  function OrientedCoordinateArray() {
    classCallCheck(this, OrientedCoordinateArray);

    this._pts = null;
    this._orientation = null;
    var pts = arguments[0];
    this._pts = pts;
    this._orientation = OrientedCoordinateArray.orientation(pts);
  }

  createClass(OrientedCoordinateArray, [{
    key: 'compareTo',
    value: function compareTo(o1) {
      var oca = o1;
      var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
      return comp;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OrientedCoordinateArray;
    }
  }], [{
    key: 'orientation',
    value: function orientation(pts) {
      return CoordinateArrays.increasingDirection(pts) === 1;
    }
  }, {
    key: 'compareOriented',
    value: function compareOriented(pts1, orientation1, pts2, orientation2) {
      var dir1 = orientation1 ? 1 : -1;
      var dir2 = orientation2 ? 1 : -1;
      var limit1 = orientation1 ? pts1.length : -1;
      var limit2 = orientation2 ? pts2.length : -1;
      var i1 = orientation1 ? 0 : pts1.length - 1;
      var i2 = orientation2 ? 0 : pts2.length - 1;
      // const comp = 0
      while (true) {
        var compPt = pts1[i1].compareTo(pts2[i2]);
        if (compPt !== 0) return compPt;
        i1 += dir1;
        i2 += dir2;
        var done1 = i1 === limit1;
        var done2 = i2 === limit2;
        if (done1 && !done2) return -1;
        if (!done1 && done2) return 1;
        if (done1 && done2) return 0;
      }
    }
  }]);
  return OrientedCoordinateArray;
}();

var EdgeList = function () {
  function EdgeList() {
    classCallCheck(this, EdgeList);

    this._edges = new ArrayList();
    this._ocaMap = new TreeMap();
  }

  createClass(EdgeList, [{
    key: 'print',
    value: function print(out) {
      out.print('MULTILINESTRING ( ');
      for (var j = 0; j < this._edges.size(); j++) {
        var e = this._edges.get(j);
        if (j > 0) out.print(',');
        out.print('(');
        var pts = e.getCoordinates();
        for (var i = 0; i < pts.length; i++) {
          if (i > 0) out.print(',');
          out.print(pts[i].x + ' ' + pts[i].y);
        }
        out.println(')');
      }
      out.print(')  ');
    }
  }, {
    key: 'addAll',
    value: function addAll(edgeColl) {
      for (var i = edgeColl.iterator(); i.hasNext();) {
        this.add(i.next());
      }
    }
  }, {
    key: 'findEdgeIndex',
    value: function findEdgeIndex(e) {
      for (var i = 0; i < this._edges.size(); i++) {
        if (this._edges.get(i).equals(e)) return i;
      }
      return -1;
    }
  }, {
    key: 'iterator',
    value: function iterator() {
      return this._edges.iterator();
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this._edges;
    }
  }, {
    key: 'get',
    value: function get$$1(i) {
      return this._edges.get(i);
    }
  }, {
    key: 'findEqualEdge',
    value: function findEqualEdge(e) {
      var oca = new OrientedCoordinateArray(e.getCoordinates());
      var matchEdge = this._ocaMap.get(oca);
      return matchEdge;
    }
  }, {
    key: 'add',
    value: function add(e) {
      this._edges.add(e);
      var oca = new OrientedCoordinateArray(e.getCoordinates());
      this._ocaMap.put(oca, e);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeList;
    }
  }]);
  return EdgeList;
}();

var SegmentIntersector = function () {
  function SegmentIntersector() {
    classCallCheck(this, SegmentIntersector);
  }

  createClass(SegmentIntersector, [{
    key: "processIntersections",
    value: function processIntersections(e0, segIndex0, e1, segIndex1) {}
  }, {
    key: "isDone",
    value: function isDone() {}
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return SegmentIntersector;
    }
  }]);
  return SegmentIntersector;
}();

var IntersectionAdder = function () {
  function IntersectionAdder() {
    classCallCheck(this, IntersectionAdder);

    this._hasIntersection = false;
    this._hasProper = false;
    this._hasProperInterior = false;
    this._hasInterior = false;
    this._properIntersectionPoint = null;
    this._li = null;
    this._isSelfIntersection = null;
    this.numIntersections = 0;
    this.numInteriorIntersections = 0;
    this.numProperIntersections = 0;
    this.numTests = 0;
    var li = arguments[0];
    this._li = li;
  }

  createClass(IntersectionAdder, [{
    key: 'isTrivialIntersection',
    value: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1) {
        if (this._li.getIntersectionNum() === 1) {
          if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;
          if (e0.isClosed()) {
            var maxSegIndex = e0.size() - 1;
            if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }, {
    key: 'getProperIntersectionPoint',
    value: function getProperIntersectionPoint() {
      return this._properIntersectionPoint;
    }
  }, {
    key: 'hasProperInteriorIntersection',
    value: function hasProperInteriorIntersection() {
      return this._hasProperInterior;
    }
  }, {
    key: 'getLineIntersector',
    value: function getLineIntersector() {
      return this._li;
    }
  }, {
    key: 'hasProperIntersection',
    value: function hasProperIntersection() {
      return this._hasProper;
    }
  }, {
    key: 'processIntersections',
    value: function processIntersections(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1 && segIndex0 === segIndex1) return null;
      this.numTests++;
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        this.numIntersections++;
        if (this._li.isInteriorIntersection()) {
          this.numInteriorIntersections++;
          this._hasInterior = true;
        }
        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
          this._hasIntersection = true;
          e0.addIntersections(this._li, segIndex0, 0);
          e1.addIntersections(this._li, segIndex1, 1);
          if (this._li.isProper()) {
            this.numProperIntersections++;
            this._hasProper = true;
            this._hasProperInterior = true;
          }
        }
      }
    }
  }, {
    key: 'hasIntersection',
    value: function hasIntersection() {
      return this._hasIntersection;
    }
  }, {
    key: 'isDone',
    value: function isDone() {
      return false;
    }
  }, {
    key: 'hasInteriorIntersection',
    value: function hasInteriorIntersection() {
      return this._hasInterior;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [SegmentIntersector];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return IntersectionAdder;
    }
  }], [{
    key: 'isAdjacentSegments',
    value: function isAdjacentSegments(i1, i2) {
      return Math.abs(i1 - i2) === 1;
    }
  }]);
  return IntersectionAdder;
}();

var EdgeIntersection = function () {
  function EdgeIntersection() {
    classCallCheck(this, EdgeIntersection);

    this.coord = null;
    this.segmentIndex = null;
    this.dist = null;
    var coord = arguments[0];
    var segmentIndex = arguments[1];
    var dist = arguments[2];
    this.coord = new Coordinate(coord);
    this.segmentIndex = segmentIndex;
    this.dist = dist;
  }

  createClass(EdgeIntersection, [{
    key: 'getSegmentIndex',
    value: function getSegmentIndex() {
      return this.segmentIndex;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this.coord;
    }
  }, {
    key: 'print',
    value: function print(out) {
      out.print(this.coord);
      out.print(' seg # = ' + this.segmentIndex);
      out.println(' dist = ' + this.dist);
    }
  }, {
    key: 'compareTo',
    value: function compareTo(obj) {
      var other = obj;
      return this.compare(other.segmentIndex, other.dist);
    }
  }, {
    key: 'isEndPoint',
    value: function isEndPoint(maxSegmentIndex) {
      if (this.segmentIndex === 0 && this.dist === 0.0) return true;
      if (this.segmentIndex === maxSegmentIndex) return true;
      return false;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist;
    }
  }, {
    key: 'getDistance',
    value: function getDistance() {
      return this.dist;
    }
  }, {
    key: 'compare',
    value: function compare(segmentIndex, dist) {
      if (this.segmentIndex < segmentIndex) return -1;
      if (this.segmentIndex > segmentIndex) return 1;
      if (this.dist < dist) return -1;
      if (this.dist > dist) return 1;
      return 0;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeIntersection;
    }
  }]);
  return EdgeIntersection;
}();

var EdgeIntersectionList = function () {
  function EdgeIntersectionList() {
    classCallCheck(this, EdgeIntersectionList);

    this._nodeMap = new TreeMap();
    this.edge = null;
    var edge = arguments[0];
    this.edge = edge;
  }

  createClass(EdgeIntersectionList, [{
    key: 'print',
    value: function print(out) {
      out.println('Intersections:');
      for (var it = this.iterator(); it.hasNext();) {
        var ei = it.next();
        ei.print(out);
      }
    }
  }, {
    key: 'iterator',
    value: function iterator() {
      return this._nodeMap.values().iterator();
    }
  }, {
    key: 'addSplitEdges',
    value: function addSplitEdges(edgeList) {
      this.addEndpoints();
      var it = this.iterator();
      var eiPrev = it.next();
      while (it.hasNext()) {
        var ei = it.next();
        var newEdge = this.createSplitEdge(eiPrev, ei);
        edgeList.add(newEdge);
        eiPrev = ei;
      }
    }
  }, {
    key: 'addEndpoints',
    value: function addEndpoints() {
      var maxSegIndex = this.edge.pts.length - 1;
      this.add(this.edge.pts[0], 0, 0.0);
      this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
    }
  }, {
    key: 'createSplitEdge',
    value: function createSplitEdge(ei0, ei1) {
      var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
      var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
      var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
      if (!useIntPt1) {
        npts--;
      }
      var pts = new Array(npts).fill(null);
      var ipt = 0;
      pts[ipt++] = new Coordinate(ei0.coord);
      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
        pts[ipt++] = this.edge.pts[i];
      }
      if (useIntPt1) pts[ipt] = ei1.coord;
      return new Edge(pts, new Label(this.edge._label));
    }
  }, {
    key: 'add',
    value: function add(intPt, segmentIndex, dist) {
      var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
      var ei = this._nodeMap.get(eiNew);
      if (ei !== null) {
        return ei;
      }
      this._nodeMap.put(eiNew, eiNew);
      return eiNew;
    }
  }, {
    key: 'isIntersection',
    value: function isIntersection(pt) {
      for (var it = this.iterator(); it.hasNext();) {
        var ei = it.next();
        if (ei.coord.equals(pt)) return true;
      }
      return false;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeIntersectionList;
    }
  }]);
  return EdgeIntersectionList;
}();

var MonotoneChainIndexer = function () {
  function MonotoneChainIndexer() {
    classCallCheck(this, MonotoneChainIndexer);
  }

  createClass(MonotoneChainIndexer, [{
    key: 'getChainStartIndices',
    value: function getChainStartIndices(pts) {
      var start = 0;
      var startIndexList = new ArrayList();
      startIndexList.add(new Integer(start));
      do {
        var last = this.findChainEnd(pts, start);
        startIndexList.add(new Integer(last));
        start = last;
      } while (start < pts.length - 1);
      var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
      return startIndex;
    }
  }, {
    key: 'findChainEnd',
    value: function findChainEnd(pts, start) {
      var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
      var last = start + 1;
      while (last < pts.length) {
        var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
        if (quad !== chainQuad) break;
        last++;
      }
      return last - 1;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MonotoneChainIndexer;
    }
  }], [{
    key: 'toIntArray',
    value: function toIntArray(list) {
      var array = new Array(list.size()).fill(null);
      for (var i = 0; i < array.length; i++) {
        array[i] = list.get(i).intValue();
      }
      return array;
    }
  }]);
  return MonotoneChainIndexer;
}();

var MonotoneChainEdge = function () {
  function MonotoneChainEdge() {
    classCallCheck(this, MonotoneChainEdge);

    this.e = null;
    this.pts = null;
    this.startIndex = null;
    this.env1 = new Envelope();
    this.env2 = new Envelope();
    var e = arguments[0];
    this.e = e;
    this.pts = e.getCoordinates();
    var mcb = new MonotoneChainIndexer();
    this.startIndex = mcb.getChainStartIndices(this.pts);
  }

  createClass(MonotoneChainEdge, [{
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this.pts;
    }
  }, {
    key: 'getMaxX',
    value: function getMaxX(chainIndex) {
      var x1 = this.pts[this.startIndex[chainIndex]].x;
      var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
      return x1 > x2 ? x1 : x2;
    }
  }, {
    key: 'getMinX',
    value: function getMinX(chainIndex) {
      var x1 = this.pts[this.startIndex[chainIndex]].x;
      var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
      return x1 < x2 ? x1 : x2;
    }
  }, {
    key: 'computeIntersectsForChain',
    value: function computeIntersectsForChain() {
      if (arguments.length === 4) {
        var chainIndex0 = arguments[0];
        var mce = arguments[1];
        var chainIndex1 = arguments[2];
        var si = arguments[3];
        this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
      } else if (arguments.length === 6) {
        var start0 = arguments[0];
        var end0 = arguments[1];
        var _mce = arguments[2];
        var start1 = arguments[3];
        var end1 = arguments[4];
        var ei = arguments[5];
        var p00 = this.pts[start0];
        var p01 = this.pts[end0];
        var p10 = _mce.pts[start1];
        var p11 = _mce.pts[end1];
        if (end0 - start0 === 1 && end1 - start1 === 1) {
          ei.addIntersections(this.e, start0, _mce.e, start1);
          return null;
        }
        this.env1.init(p00, p01);
        this.env2.init(p10, p11);
        if (!this.env1.intersects(this.env2)) return null;
        var mid0 = Math.trunc((start0 + end0) / 2);
        var mid1 = Math.trunc((start1 + end1) / 2);
        if (start0 < mid0) {
          if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, _mce, start1, mid1, ei);
          if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, _mce, mid1, end1, ei);
        }
        if (mid0 < end0) {
          if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, _mce, start1, mid1, ei);
          if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, _mce, mid1, end1, ei);
        }
      }
    }
  }, {
    key: 'getStartIndexes',
    value: function getStartIndexes() {
      return this.startIndex;
    }
  }, {
    key: 'computeIntersects',
    value: function computeIntersects(mce, si) {
      for (var i = 0; i < this.startIndex.length - 1; i++) {
        for (var j = 0; j < mce.startIndex.length - 1; j++) {
          this.computeIntersectsForChain(i, mce, j, si);
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MonotoneChainEdge;
    }
  }]);
  return MonotoneChainEdge;
}();

var Depth = function () {
  function Depth() {
    classCallCheck(this, Depth);

    this._depth = Array(2).fill().map(function () {
      return Array(3);
    });
    for (var i = 0; i < 2; i++) {
      for (var j = 0; j < 3; j++) {
        this._depth[i][j] = Depth.NULL_VALUE;
      }
    }
  }

  createClass(Depth, [{
    key: 'getDepth',
    value: function getDepth(geomIndex, posIndex) {
      return this._depth[geomIndex][posIndex];
    }
  }, {
    key: 'setDepth',
    value: function setDepth(geomIndex, posIndex, depthValue) {
      this._depth[geomIndex][posIndex] = depthValue;
    }
  }, {
    key: 'isNull',
    value: function isNull() {
      if (arguments.length === 0) {
        for (var i = 0; i < 2; i++) {
          for (var j = 0; j < 3; j++) {
            if (this._depth[i][j] !== Depth.NULL_VALUE) return false;
          }
        }
        return true;
      } else if (arguments.length === 1) {
        var geomIndex = arguments[0];
        return this._depth[geomIndex][1] === Depth.NULL_VALUE;
      } else if (arguments.length === 2) {
        var _geomIndex = arguments[0];
        var posIndex = arguments[1];
        return this._depth[_geomIndex][posIndex] === Depth.NULL_VALUE;
      }
    }
  }, {
    key: 'normalize',
    value: function normalize() {
      for (var i = 0; i < 2; i++) {
        if (!this.isNull(i)) {
          var minDepth = this._depth[i][1];
          if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];
          if (minDepth < 0) minDepth = 0;
          for (var j = 1; j < 3; j++) {
            var newValue = 0;
            if (this._depth[i][j] > minDepth) newValue = 1;
            this._depth[i][j] = newValue;
          }
        }
      }
    }
  }, {
    key: 'getDelta',
    value: function getDelta(geomIndex) {
      return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];
    }
  }, {
    key: 'getLocation',
    value: function getLocation(geomIndex, posIndex) {
      if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;
      return Location.INTERIOR;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2];
    }
  }, {
    key: 'add',
    value: function add() {
      if (arguments.length === 1) {
        var lbl = arguments[0];
        for (var i = 0; i < 2; i++) {
          for (var j = 1; j < 3; j++) {
            var loc = lbl.getLocation(i, j);
            if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
              if (this.isNull(i, j)) {
                this._depth[i][j] = Depth.depthAtLocation(loc);
              } else this._depth[i][j] += Depth.depthAtLocation(loc);
            }
          }
        }
      } else if (arguments.length === 3) {
        var geomIndex = arguments[0];
        var posIndex = arguments[1];
        var location = arguments[2];
        if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Depth;
    }
  }], [{
    key: 'depthAtLocation',
    value: function depthAtLocation(location) {
      if (location === Location.EXTERIOR) return 0;
      if (location === Location.INTERIOR) return 1;
      return Depth.NULL_VALUE;
    }
  }, {
    key: 'NULL_VALUE',
    get: function get$$1() {
      return -1;
    }
  }]);
  return Depth;
}();

var Edge = function (_GraphComponent) {
  inherits(Edge, _GraphComponent);

  function Edge() {
    classCallCheck(this, Edge);

    var _this = possibleConstructorReturn(this, (Edge.__proto__ || Object.getPrototypeOf(Edge)).call(this));

    _this.pts = null;
    _this._env = null;
    _this.eiList = new EdgeIntersectionList(_this);
    _this._name = null;
    _this._mce = null;
    _this._isIsolated = true;
    _this._depth = new Depth();
    _this._depthDelta = 0;
    if (arguments.length === 1) {
      var pts = arguments[0];
      Edge.call(_this, pts, null);
    } else if (arguments.length === 2) {
      var _pts = arguments[0];
      var label = arguments[1];
      _this.pts = _pts;
      _this._label = label;
    }
    return _this;
  }

  createClass(Edge, [{
    key: 'getDepth',
    value: function getDepth() {
      return this._depth;
    }
  }, {
    key: 'getCollapsedEdge',
    value: function getCollapsedEdge() {
      var newPts = new Array(2).fill(null);
      newPts[0] = this.pts[0];
      newPts[1] = this.pts[1];
      var newe = new Edge(newPts, Label.toLineLabel(this._label));
      return newe;
    }
  }, {
    key: 'isIsolated',
    value: function isIsolated() {
      return this._isIsolated;
    }
  }, {
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this.pts;
    }
  }, {
    key: 'setIsolated',
    value: function setIsolated(isIsolated) {
      this._isIsolated = isIsolated;
    }
  }, {
    key: 'setName',
    value: function setName(name) {
      this._name = name;
    }
  }, {
    key: 'equals',
    value: function equals(o) {
      if (!(o instanceof Edge)) return false;
      var e = o;
      if (this.pts.length !== e.pts.length) return false;
      var isEqualForward = true;
      var isEqualReverse = true;
      var iRev = this.pts.length;
      for (var i = 0; i < this.pts.length; i++) {
        if (!this.pts[i].equals2D(e.pts[i])) {
          isEqualForward = false;
        }
        if (!this.pts[i].equals2D(e.pts[--iRev])) {
          isEqualReverse = false;
        }
        if (!isEqualForward && !isEqualReverse) return false;
      }
      return true;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      if (arguments.length === 0) {
        if (this.pts.length > 0) return this.pts[0];
        return null;
      } else if (arguments.length === 1) {
        var i = arguments[0];
        return this.pts[i];
      }
    }
  }, {
    key: 'print',
    value: function print(out) {
      out.print('edge ' + this._name + ': ');
      out.print('LINESTRING (');
      for (var i = 0; i < this.pts.length; i++) {
        if (i > 0) out.print(',');
        out.print(this.pts[i].x + ' ' + this.pts[i].y);
      }
      out.print(')  ' + this._label + ' ' + this._depthDelta);
    }
  }, {
    key: 'computeIM',
    value: function computeIM(im) {
      Edge.updateIM(this._label, im);
    }
  }, {
    key: 'isCollapsed',
    value: function isCollapsed() {
      if (!this._label.isArea()) return false;
      if (this.pts.length !== 3) return false;
      if (this.pts[0].equals(this.pts[2])) return true;
      return false;
    }
  }, {
    key: 'isClosed',
    value: function isClosed() {
      return this.pts[0].equals(this.pts[this.pts.length - 1]);
    }
  }, {
    key: 'getMaximumSegmentIndex',
    value: function getMaximumSegmentIndex() {
      return this.pts.length - 1;
    }
  }, {
    key: 'getDepthDelta',
    value: function getDepthDelta() {
      return this._depthDelta;
    }
  }, {
    key: 'getNumPoints',
    value: function getNumPoints() {
      return this.pts.length;
    }
  }, {
    key: 'printReverse',
    value: function printReverse(out) {
      out.print('edge ' + this._name + ': ');
      for (var i = this.pts.length - 1; i >= 0; i--) {
        out.print(this.pts[i] + ' ');
      }
      out.println('');
    }
  }, {
    key: 'getMonotoneChainEdge',
    value: function getMonotoneChainEdge() {
      if (this._mce === null) this._mce = new MonotoneChainEdge(this);
      return this._mce;
    }
  }, {
    key: 'getEnvelope',
    value: function getEnvelope() {
      if (this._env === null) {
        this._env = new Envelope();
        for (var i = 0; i < this.pts.length; i++) {
          this._env.expandToInclude(this.pts[i]);
        }
      }
      return this._env;
    }
  }, {
    key: 'addIntersection',
    value: function addIntersection(li, segmentIndex, geomIndex, intIndex) {
      var intPt = new Coordinate(li.getIntersection(intIndex));
      var normalizedSegmentIndex = segmentIndex;
      var dist = li.getEdgeDistance(geomIndex, intIndex);
      var nextSegIndex = normalizedSegmentIndex + 1;
      if (nextSegIndex < this.pts.length) {
        var nextPt = this.pts[nextSegIndex];
        if (intPt.equals2D(nextPt)) {
          normalizedSegmentIndex = nextSegIndex;
          dist = 0.0;
        }
      }
      this.eiList.add(intPt, normalizedSegmentIndex, dist);
    }
  }, {
    key: 'toString',
    value: function toString() {
      var buf = new StringBuffer();
      buf.append('edge ' + this._name + ': ');
      buf.append('LINESTRING (');
      for (var i = 0; i < this.pts.length; i++) {
        if (i > 0) buf.append(',');
        buf.append(this.pts[i].x + ' ' + this.pts[i].y);
      }
      buf.append(')  ' + this._label + ' ' + this._depthDelta);
      return buf.toString();
    }
  }, {
    key: 'isPointwiseEqual',
    value: function isPointwiseEqual(e) {
      if (this.pts.length !== e.pts.length) return false;
      for (var i = 0; i < this.pts.length; i++) {
        if (!this.pts[i].equals2D(e.pts[i])) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'setDepthDelta',
    value: function setDepthDelta(depthDelta) {
      this._depthDelta = depthDelta;
    }
  }, {
    key: 'getEdgeIntersectionList',
    value: function getEdgeIntersectionList() {
      return this.eiList;
    }
  }, {
    key: 'addIntersections',
    value: function addIntersections(li, segmentIndex, geomIndex) {
      for (var i = 0; i < li.getIntersectionNum(); i++) {
        this.addIntersection(li, segmentIndex, geomIndex, i);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Edge;
    }
  }], [{
    key: 'updateIM',
    value: function updateIM() {
      if (arguments.length === 2) {
        var label = arguments[0];
        var im = arguments[1];
        im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
        if (label.isArea()) {
          im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
          im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
        }
      } else return GraphComponent.prototype.updateIM.apply(this, arguments);
    }
  }]);
  return Edge;
}(GraphComponent);

var BufferBuilder = function () {
  function BufferBuilder(bufParams) {
    classCallCheck(this, BufferBuilder);

    this._workingPrecisionModel = null;
    this._workingNoder = null;
    this._geomFact = null;
    this._graph = null;
    this._edgeList = new EdgeList();
    this._bufParams = bufParams || null;
  }

  createClass(BufferBuilder, [{
    key: 'setWorkingPrecisionModel',
    value: function setWorkingPrecisionModel(pm) {
      this._workingPrecisionModel = pm;
    }
  }, {
    key: 'insertUniqueEdge',
    value: function insertUniqueEdge(e) {
      var existingEdge = this._edgeList.findEqualEdge(e);
      if (existingEdge !== null) {
        var existingLabel = existingEdge.getLabel();
        var labelToMerge = e.getLabel();
        if (!existingEdge.isPointwiseEqual(e)) {
          labelToMerge = new Label(e.getLabel());
          labelToMerge.flip();
        }
        existingLabel.merge(labelToMerge);
        var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
        var existingDelta = existingEdge.getDepthDelta();
        var newDelta = existingDelta + mergeDelta;
        existingEdge.setDepthDelta(newDelta);
      } else {
        this._edgeList.add(e);
        e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
      }
    }
  }, {
    key: 'buildSubgraphs',
    value: function buildSubgraphs(subgraphList, polyBuilder) {
      var processedGraphs = new ArrayList();
      for (var i = subgraphList.iterator(); i.hasNext();) {
        var subgraph = i.next();
        var p = subgraph.getRightmostCoordinate();
        var locater = new SubgraphDepthLocater(processedGraphs);
        var outsideDepth = locater.getDepth(p);
        subgraph.computeDepth(outsideDepth);
        subgraph.findResultEdges();
        processedGraphs.add(subgraph);
        polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
      }
    }
  }, {
    key: 'createSubgraphs',
    value: function createSubgraphs(graph) {
      var subgraphList = new ArrayList();
      for (var i = graph.getNodes().iterator(); i.hasNext();) {
        var node = i.next();
        if (!node.isVisited()) {
          var subgraph = new BufferSubgraph();
          subgraph.create(node);
          subgraphList.add(subgraph);
        }
      }
      Collections.sort(subgraphList, Collections.reverseOrder());
      return subgraphList;
    }
  }, {
    key: 'createEmptyResultGeometry',
    value: function createEmptyResultGeometry() {
      var emptyGeom = this._geomFact.createPolygon();
      return emptyGeom;
    }
  }, {
    key: 'getNoder',
    value: function getNoder(precisionModel) {
      if (this._workingNoder !== null) return this._workingNoder;
      var noder = new MCIndexNoder();
      var li = new RobustLineIntersector();
      li.setPrecisionModel(precisionModel);
      noder.setSegmentIntersector(new IntersectionAdder(li));
      return noder;
    }
  }, {
    key: 'buffer',
    value: function buffer(g, distance) {
      var precisionModel = this._workingPrecisionModel;
      if (precisionModel === null) precisionModel = g.getPrecisionModel();
      this._geomFact = g.getFactory();
      var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
      var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);
      var bufferSegStrList = curveSetBuilder.getCurves();
      if (bufferSegStrList.size() <= 0) {
        return this.createEmptyResultGeometry();
      }
      this.computeNodedEdges(bufferSegStrList, precisionModel);
      this._graph = new PlanarGraph(new OverlayNodeFactory());
      this._graph.addEdges(this._edgeList.getEdges());
      var subgraphList = this.createSubgraphs(this._graph);
      var polyBuilder = new PolygonBuilder(this._geomFact);
      this.buildSubgraphs(subgraphList, polyBuilder);
      var resultPolyList = polyBuilder.getPolygons();
      if (resultPolyList.size() <= 0) {
        return this.createEmptyResultGeometry();
      }
      var resultGeom = this._geomFact.buildGeometry(resultPolyList);
      return resultGeom;
    }
  }, {
    key: 'computeNodedEdges',
    value: function computeNodedEdges(bufferSegStrList, precisionModel) {
      var noder = this.getNoder(precisionModel);
      noder.computeNodes(bufferSegStrList);
      var nodedSegStrings = noder.getNodedSubstrings();
      for (var i = nodedSegStrings.iterator(); i.hasNext();) {
        var segStr = i.next();
        var pts = segStr.getCoordinates();
        if (pts.length === 2 && pts[0].equals2D(pts[1])) continue;
        var oldLabel = segStr.getData();
        var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));
        this.insertUniqueEdge(edge);
      }
    }
  }, {
    key: 'setNoder',
    value: function setNoder(noder) {
      this._workingNoder = noder;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BufferBuilder;
    }
  }], [{
    key: 'depthDelta',
    value: function depthDelta(label) {
      var lLoc = label.getLocation(0, Position.LEFT);
      var rLoc = label.getLocation(0, Position.RIGHT);
      if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1;else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;
      return 0;
    }
  }, {
    key: 'convertSegStrings',
    value: function convertSegStrings(it) {
      var fact = new GeometryFactory();
      var lines = new ArrayList();
      while (it.hasNext()) {
        var ss = it.next();
        var line = fact.createLineString(ss.getCoordinates());
        lines.add(line);
      }
      return fact.buildGeometry(lines);
    }
  }]);
  return BufferBuilder;
}();

var ScaledNoder = function () {
  function ScaledNoder() {
    classCallCheck(this, ScaledNoder);

    this._noder = null;
    this._scaleFactor = null;
    this._offsetX = null;
    this._offsetY = null;
    this._isScaled = false;
    if (arguments.length === 2) {
      var noder = arguments[0];
      var scaleFactor = arguments[1];
      this._noder = noder;
      this._scaleFactor = scaleFactor;
      this._offsetX = 0.0;
      this._offsetY = 0.0;
      this._isScaled = !this.isIntegerPrecision();
    } else if (arguments.length === 4) {
      var _noder = arguments[0];
      var _scaleFactor = arguments[1];
      var offsetX = arguments[2];
      var offsetY = arguments[3];
      this._noder = _noder;
      this._scaleFactor = _scaleFactor;
      this._offsetX = offsetX;
      this._offsetY = offsetY;
      this._isScaled = !this.isIntegerPrecision();
    }
  }

  createClass(ScaledNoder, [{
    key: 'rescale',
    value: function rescale() {
      if (hasInterface(arguments[0], Collection)) {
        var segStrings = arguments[0];
        for (var i = segStrings.iterator(); i.hasNext();) {
          var ss = i.next();
          this.rescale(ss.getCoordinates());
        }
      } else if (arguments[0] instanceof Array) {
        var pts = arguments[0];
        // let p0 = null
        // let p1 = null
        // if (pts.length === 2) {
        //   p0 = new Coordinate(pts[0])
        //   p1 = new Coordinate(pts[1])
        // }
        for (var _i = 0; _i < pts.length; _i++) {
          pts[_i].x = pts[_i].x / this._scaleFactor + this._offsetX;
          pts[_i].y = pts[_i].y / this._scaleFactor + this._offsetY;
        }
        if (pts.length === 2 && pts[0].equals2D(pts[1])) {
          System.out.println(pts);
        }
      }
    }
  }, {
    key: 'scale',
    value: function scale() {
      if (hasInterface(arguments[0], Collection)) {
        var segStrings = arguments[0];
        var nodedSegmentStrings = new ArrayList();
        for (var i = segStrings.iterator(); i.hasNext();) {
          var ss = i.next();
          nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));
        }
        return nodedSegmentStrings;
      } else if (arguments[0] instanceof Array) {
        var pts = arguments[0];
        var roundPts = new Array(pts.length).fill(null);
        for (var _i2 = 0; _i2 < pts.length; _i2++) {
          roundPts[_i2] = new Coordinate(Math.round((pts[_i2].x - this._offsetX) * this._scaleFactor), Math.round((pts[_i2].y - this._offsetY) * this._scaleFactor), pts[_i2].z);
        }
        var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
        return roundPtsNoDup;
      }
    }
  }, {
    key: 'isIntegerPrecision',
    value: function isIntegerPrecision() {
      return this._scaleFactor === 1.0;
    }
  }, {
    key: 'getNodedSubstrings',
    value: function getNodedSubstrings() {
      var splitSS = this._noder.getNodedSubstrings();
      if (this._isScaled) this.rescale(splitSS);
      return splitSS;
    }
  }, {
    key: 'computeNodes',
    value: function computeNodes(inputSegStrings) {
      var intSegStrings = inputSegStrings;
      if (this._isScaled) intSegStrings = this.scale(inputSegStrings);
      this._noder.computeNodes(intSegStrings);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Noder];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return ScaledNoder;
    }
  }]);
  return ScaledNoder;
}();

var NodingValidator = function () {
  function NodingValidator() {
    classCallCheck(this, NodingValidator);

    this._li = new RobustLineIntersector();
    this._segStrings = null;
    var segStrings = arguments[0];
    this._segStrings = segStrings;
  }

  createClass(NodingValidator, [{
    key: 'checkEndPtVertexIntersections',
    value: function checkEndPtVertexIntersections() {
      if (arguments.length === 0) {
        for (var i = this._segStrings.iterator(); i.hasNext();) {
          var ss = i.next();
          var pts = ss.getCoordinates();
          this.checkEndPtVertexIntersections(pts[0], this._segStrings);
          this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);
        }
      } else if (arguments.length === 2) {
        var testPt = arguments[0];
        var segStrings = arguments[1];
        for (var _i = segStrings.iterator(); _i.hasNext();) {
          var _ss = _i.next();
          var _pts = _ss.getCoordinates();
          for (var j = 1; j < _pts.length - 1; j++) {
            if (_pts[j].equals(testPt)) throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt);
          }
        }
      }
    }
  }, {
    key: 'checkInteriorIntersections',
    value: function checkInteriorIntersections() {
      if (arguments.length === 0) {
        for (var i = this._segStrings.iterator(); i.hasNext();) {
          var ss0 = i.next();
          for (var j = this._segStrings.iterator(); j.hasNext();) {
            var ss1 = j.next();
            this.checkInteriorIntersections(ss0, ss1);
          }
        }
      } else if (arguments.length === 2) {
        var _ss2 = arguments[0];
        var _ss3 = arguments[1];
        var pts0 = _ss2.getCoordinates();
        var pts1 = _ss3.getCoordinates();
        for (var i0 = 0; i0 < pts0.length - 1; i0++) {
          for (var i1 = 0; i1 < pts1.length - 1; i1++) {
            this.checkInteriorIntersections(_ss2, i0, _ss3, i1);
          }
        }
      } else if (arguments.length === 4) {
        var e0 = arguments[0];
        var segIndex0 = arguments[1];
        var e1 = arguments[2];
        var segIndex1 = arguments[3];
        if (e0 === e1 && segIndex0 === segIndex1) return null;
        var p00 = e0.getCoordinates()[segIndex0];
        var p01 = e0.getCoordinates()[segIndex0 + 1];
        var p10 = e1.getCoordinates()[segIndex1];
        var p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
          if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
            throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11);
          }
        }
      }
    }
  }, {
    key: 'checkValid',
    value: function checkValid() {
      this.checkEndPtVertexIntersections();
      this.checkInteriorIntersections();
      this.checkCollapses();
    }
  }, {
    key: 'checkCollapses',
    value: function checkCollapses() {
      if (arguments.length === 0) {
        for (var i = this._segStrings.iterator(); i.hasNext();) {
          var ss = i.next();
          this.checkCollapses(ss);
        }
      } else if (arguments.length === 1) {
        var _ss4 = arguments[0];
        var pts = _ss4.getCoordinates();
        for (var _i2 = 0; _i2 < pts.length - 2; _i2++) {
          this.checkCollapse(pts[_i2], pts[_i2 + 1], pts[_i2 + 2]);
        }
      }
    }
  }, {
    key: 'hasInteriorIntersection',
    value: function hasInteriorIntersection(li, p0, p1) {
      for (var i = 0; i < li.getIntersectionNum(); i++) {
        var intPt = li.getIntersection(i);
        if (!(intPt.equals(p0) || intPt.equals(p1))) return true;
      }
      return false;
    }
  }, {
    key: 'checkCollapse',
    value: function checkCollapse(p0, p1, p2) {
      if (p0.equals(p2)) throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2]));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NodingValidator;
    }
  }], [{
    key: 'fact',
    get: function get$$1() {
      return new GeometryFactory();
    }
  }]);
  return NodingValidator;
}();

var HotPixel = function () {
  function HotPixel() {
    classCallCheck(this, HotPixel);

    this._li = null;
    this._pt = null;
    this._originalPt = null;
    this._ptScaled = null;
    this._p0Scaled = null;
    this._p1Scaled = null;
    this._scaleFactor = null;
    this._minx = null;
    this._maxx = null;
    this._miny = null;
    this._maxy = null;
    this._corner = new Array(4).fill(null);
    this._safeEnv = null;
    var pt = arguments[0];
    var scaleFactor = arguments[1];
    var li = arguments[2];
    this._originalPt = pt;
    this._pt = pt;
    this._scaleFactor = scaleFactor;
    this._li = li;
    if (scaleFactor <= 0) throw new IllegalArgumentException('Scale factor must be non-zero');
    if (scaleFactor !== 1.0) {
      this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
      this._p0Scaled = new Coordinate();
      this._p1Scaled = new Coordinate();
    }
    this.initCorners(this._pt);
  }

  createClass(HotPixel, [{
    key: 'intersectsScaled',
    value: function intersectsScaled(p0, p1) {
      var segMinx = Math.min(p0.x, p1.x);
      var segMaxx = Math.max(p0.x, p1.x);
      var segMiny = Math.min(p0.y, p1.y);
      var segMaxy = Math.max(p0.y, p1.y);
      var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
      if (isOutsidePixelEnv) return false;
      var intersects = this.intersectsToleranceSquare(p0, p1);
      Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');
      return intersects;
    }
  }, {
    key: 'initCorners',
    value: function initCorners(pt) {
      var tolerance = 0.5;
      this._minx = pt.x - tolerance;
      this._maxx = pt.x + tolerance;
      this._miny = pt.y - tolerance;
      this._maxy = pt.y + tolerance;
      this._corner[0] = new Coordinate(this._maxx, this._maxy);
      this._corner[1] = new Coordinate(this._minx, this._maxy);
      this._corner[2] = new Coordinate(this._minx, this._miny);
      this._corner[3] = new Coordinate(this._maxx, this._miny);
    }
  }, {
    key: 'intersects',
    value: function intersects(p0, p1) {
      if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);
      this.copyScaled(p0, this._p0Scaled);
      this.copyScaled(p1, this._p1Scaled);
      return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
    }
  }, {
    key: 'scale',
    value: function scale(val) {
      return Math.round(val * this._scaleFactor);
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate() {
      return this._originalPt;
    }
  }, {
    key: 'copyScaled',
    value: function copyScaled(p, pScaled) {
      pScaled.x = this.scale(p.x);
      pScaled.y = this.scale(p.y);
    }
  }, {
    key: 'getSafeEnvelope',
    value: function getSafeEnvelope() {
      if (this._safeEnv === null) {
        var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
        this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
      }
      return this._safeEnv;
    }
  }, {
    key: 'intersectsPixelClosure',
    value: function intersectsPixelClosure(p0, p1) {
      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
      if (this._li.hasIntersection()) return true;
      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
      if (this._li.hasIntersection()) return true;
      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
      if (this._li.hasIntersection()) return true;
      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
      if (this._li.hasIntersection()) return true;
      return false;
    }
  }, {
    key: 'intersectsToleranceSquare',
    value: function intersectsToleranceSquare(p0, p1) {
      var intersectsLeft = false;
      var intersectsBottom = false;
      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
      if (this._li.isProper()) return true;
      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
      if (this._li.isProper()) return true;
      if (this._li.hasIntersection()) intersectsLeft = true;
      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
      if (this._li.isProper()) return true;
      if (this._li.hasIntersection()) intersectsBottom = true;
      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
      if (this._li.isProper()) return true;
      if (intersectsLeft && intersectsBottom) return true;
      if (p0.equals(this._pt)) return true;
      if (p1.equals(this._pt)) return true;
      return false;
    }
  }, {
    key: 'addSnappedNode',
    value: function addSnappedNode(segStr, segIndex) {
      var p0 = segStr.getCoordinate(segIndex);
      var p1 = segStr.getCoordinate(segIndex + 1);
      if (this.intersects(p0, p1)) {
        segStr.addIntersection(this.getCoordinate(), segIndex);
        return true;
      }
      return false;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return HotPixel;
    }
  }], [{
    key: 'SAFE_ENV_EXPANSION_FACTOR',
    get: function get$$1() {
      return 0.75;
    }
  }]);
  return HotPixel;
}();

var MonotoneChainSelectAction = function () {
  function MonotoneChainSelectAction() {
    classCallCheck(this, MonotoneChainSelectAction);

    this.tempEnv1 = new Envelope();
    this.selectedSegment = new LineSegment();
  }

  createClass(MonotoneChainSelectAction, [{
    key: 'select',
    value: function select() {
      if (arguments.length === 1) {
        // const seg = arguments[0]
      } else if (arguments.length === 2) {
        var mc = arguments[0];
        var startIndex = arguments[1];
        mc.getLineSegment(startIndex, this.selectedSegment);
        this.select(this.selectedSegment);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MonotoneChainSelectAction;
    }
  }]);
  return MonotoneChainSelectAction;
}();

var MCIndexPointSnapper = function () {
  function MCIndexPointSnapper() {
    classCallCheck(this, MCIndexPointSnapper);

    this._index = null;
    var index = arguments[0];
    this._index = index;
  }

  createClass(MCIndexPointSnapper, [{
    key: 'snap',
    value: function snap() {
      if (arguments.length === 1) {
        var hotPixel = arguments[0];
        return this.snap(hotPixel, null, -1);
      } else if (arguments.length === 3) {
        var _hotPixel = arguments[0];
        var parentEdge = arguments[1];
        var hotPixelVertexIndex = arguments[2];
        var pixelEnv = _hotPixel.getSafeEnvelope();
        var hotPixelSnapAction = new HotPixelSnapAction(_hotPixel, parentEdge, hotPixelVertexIndex);
        this._index.query(pixelEnv, {
          interfaces_: function interfaces_() {
            return [ItemVisitor];
          },
          visitItem: function visitItem(item) {
            var testChain = item;
            testChain.select(pixelEnv, hotPixelSnapAction);
          }
        });
        return hotPixelSnapAction.isNodeAdded();
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MCIndexPointSnapper;
    }
  }], [{
    key: 'HotPixelSnapAction',
    get: function get$$1() {
      return HotPixelSnapAction;
    }
  }]);
  return MCIndexPointSnapper;
}();

var HotPixelSnapAction = function (_MonotoneChainSelectA) {
  inherits(HotPixelSnapAction, _MonotoneChainSelectA);

  function HotPixelSnapAction() {
    classCallCheck(this, HotPixelSnapAction);

    var _this = possibleConstructorReturn(this, (HotPixelSnapAction.__proto__ || Object.getPrototypeOf(HotPixelSnapAction)).call(this));

    _this._hotPixel = null;
    _this._parentEdge = null;
    _this._hotPixelVertexIndex = null;
    _this._isNodeAdded = false;
    var hotPixel = arguments[0];
    var parentEdge = arguments[1];
    var hotPixelVertexIndex = arguments[2];
    _this._hotPixel = hotPixel;
    _this._parentEdge = parentEdge;
    _this._hotPixelVertexIndex = hotPixelVertexIndex;
    return _this;
  }

  createClass(HotPixelSnapAction, [{
    key: 'isNodeAdded',
    value: function isNodeAdded() {
      return this._isNodeAdded;
    }
  }, {
    key: 'select',
    value: function select() {
      if (arguments.length === 2) {
        var mc = arguments[0];
        var startIndex = arguments[1];
        var ss = mc.getContext();
        if (this._parentEdge !== null) {
          if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;
        }
        this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
      } else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return HotPixelSnapAction;
    }
  }]);
  return HotPixelSnapAction;
}(MonotoneChainSelectAction);

var InteriorIntersectionFinderAdder = function () {
  function InteriorIntersectionFinderAdder() {
    classCallCheck(this, InteriorIntersectionFinderAdder);

    this._li = null;
    this._interiorIntersections = null;
    var li = arguments[0];
    this._li = li;
    this._interiorIntersections = new ArrayList();
  }

  createClass(InteriorIntersectionFinderAdder, [{
    key: 'processIntersections',
    value: function processIntersections(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1 && segIndex0 === segIndex1) return null;
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._li.isInteriorIntersection()) {
          for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
            this._interiorIntersections.add(this._li.getIntersection(intIndex));
          }
          e0.addIntersections(this._li, segIndex0, 0);
          e1.addIntersections(this._li, segIndex1, 1);
        }
      }
    }
  }, {
    key: 'isDone',
    value: function isDone() {
      return false;
    }
  }, {
    key: 'getInteriorIntersections',
    value: function getInteriorIntersections() {
      return this._interiorIntersections;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [SegmentIntersector];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return InteriorIntersectionFinderAdder;
    }
  }]);
  return InteriorIntersectionFinderAdder;
}();

var MCIndexSnapRounder = function () {
  function MCIndexSnapRounder() {
    classCallCheck(this, MCIndexSnapRounder);

    this._pm = null;
    this._li = null;
    this._scaleFactor = null;
    this._noder = null;
    this._pointSnapper = null;
    this._nodedSegStrings = null;
    var pm = arguments[0];
    this._pm = pm;
    this._li = new RobustLineIntersector();
    this._li.setPrecisionModel(pm);
    this._scaleFactor = pm.getScale();
  }

  createClass(MCIndexSnapRounder, [{
    key: 'checkCorrectness',
    value: function checkCorrectness(inputSegmentStrings) {
      var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
      var nv = new NodingValidator(resultSegStrings);
      try {
        nv.checkValid();
      } catch (ex) {
        if (ex instanceof Exception) {
          ex.printStackTrace();
        } else throw ex;
      } finally {}
    }
  }, {
    key: 'getNodedSubstrings',
    value: function getNodedSubstrings() {
      return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
    }
  }, {
    key: 'snapRound',
    value: function snapRound(segStrings, li) {
      var intersections = this.findInteriorIntersections(segStrings, li);
      this.computeIntersectionSnaps(intersections);
      this.computeVertexSnaps(segStrings);
    }
  }, {
    key: 'findInteriorIntersections',
    value: function findInteriorIntersections(segStrings, li) {
      var intFinderAdder = new InteriorIntersectionFinderAdder(li);
      this._noder.setSegmentIntersector(intFinderAdder);
      this._noder.computeNodes(segStrings);
      return intFinderAdder.getInteriorIntersections();
    }
  }, {
    key: 'computeVertexSnaps',
    value: function computeVertexSnaps() {
      if (hasInterface(arguments[0], Collection)) {
        var edges = arguments[0];
        for (var i0 = edges.iterator(); i0.hasNext();) {
          var edge0 = i0.next();
          this.computeVertexSnaps(edge0);
        }
      } else if (arguments[0] instanceof NodedSegmentString) {
        var e = arguments[0];
        var pts0 = e.getCoordinates();
        for (var i = 0; i < pts0.length; i++) {
          var hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);
          var isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);
          if (isNodeAdded) {
            e.addIntersection(pts0[i], i);
          }
        }
      }
    }
  }, {
    key: 'computeNodes',
    value: function computeNodes(inputSegmentStrings) {
      this._nodedSegStrings = inputSegmentStrings;
      this._noder = new MCIndexNoder();
      this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
      this.snapRound(inputSegmentStrings, this._li);
    }
  }, {
    key: 'computeIntersectionSnaps',
    value: function computeIntersectionSnaps(snapPts) {
      for (var it = snapPts.iterator(); it.hasNext();) {
        var snapPt = it.next();
        var hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);
        this._pointSnapper.snap(hotPixel);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Noder];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MCIndexSnapRounder;
    }
  }]);
  return MCIndexSnapRounder;
}();

var BufferOp = function () {
  function BufferOp() {
    classCallCheck(this, BufferOp);

    this._argGeom = null;
    this._distance = null;
    this._bufParams = new BufferParameters();
    this._resultGeometry = null;
    this._saveException = null;
    if (arguments.length === 1) {
      var g = arguments[0];
      this._argGeom = g;
    } else if (arguments.length === 2) {
      var _g = arguments[0];
      var bufParams = arguments[1];
      this._argGeom = _g;
      this._bufParams = bufParams;
    }
  }

  createClass(BufferOp, [{
    key: 'bufferFixedPrecision',
    value: function bufferFixedPrecision(fixedPM) {
      var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());
      var bufBuilder = new BufferBuilder(this._bufParams);
      bufBuilder.setWorkingPrecisionModel(fixedPM);
      bufBuilder.setNoder(noder);
      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
    }
  }, {
    key: 'bufferReducedPrecision',
    value: function bufferReducedPrecision() {
      if (arguments.length === 0) {
        for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
          try {
            this.bufferReducedPrecision(precDigits);
          } catch (ex) {
            if (ex instanceof TopologyException) {
              this._saveException = ex;
            } else throw ex;
          } finally {}
          if (this._resultGeometry !== null) return null;
        }
        throw this._saveException;
      } else if (arguments.length === 1) {
        var precisionDigits = arguments[0];
        var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
        var fixedPM = new PrecisionModel(sizeBasedScaleFactor);
        this.bufferFixedPrecision(fixedPM);
      }
    }
  }, {
    key: 'computeGeometry',
    value: function computeGeometry() {
      this.bufferOriginalPrecision();
      if (this._resultGeometry !== null) return null;
      var argPM = this._argGeom.getFactory().getPrecisionModel();
      if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM);else this.bufferReducedPrecision();
    }
  }, {
    key: 'setQuadrantSegments',
    value: function setQuadrantSegments(quadrantSegments) {
      this._bufParams.setQuadrantSegments(quadrantSegments);
    }
  }, {
    key: 'bufferOriginalPrecision',
    value: function bufferOriginalPrecision() {
      try {
        var bufBuilder = new BufferBuilder(this._bufParams);
        this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
      } catch (ex) {
        if (ex instanceof RuntimeException) {
          this._saveException = ex;
        } else throw ex;
      } finally {}
    }
  }, {
    key: 'getResultGeometry',
    value: function getResultGeometry(distance) {
      this._distance = distance;
      this.computeGeometry();
      return this._resultGeometry;
    }
  }, {
    key: 'setEndCapStyle',
    value: function setEndCapStyle(endCapStyle) {
      this._bufParams.setEndCapStyle(endCapStyle);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BufferOp;
    }
  }], [{
    key: 'bufferOp',
    value: function bufferOp() {
      if (arguments.length === 2) {
        var g = arguments[0];
        var distance = arguments[1];
        var gBuf = new BufferOp(g);
        var geomBuf = gBuf.getResultGeometry(distance);
        return geomBuf;
      } else if (arguments.length === 3) {
        if (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === 'number') {
          var _g2 = arguments[0];
          var _distance = arguments[1];
          var quadrantSegments = arguments[2];
          var bufOp = new BufferOp(_g2);
          bufOp.setQuadrantSegments(quadrantSegments);
          var _geomBuf = bufOp.getResultGeometry(_distance);
          return _geomBuf;
        } else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === 'number') {
          var _g3 = arguments[0];
          var _distance2 = arguments[1];
          var params = arguments[2];
          var _bufOp = new BufferOp(_g3, params);
          var _geomBuf2 = _bufOp.getResultGeometry(_distance2);
          return _geomBuf2;
        }
      } else if (arguments.length === 4) {
        var _g4 = arguments[0];
        var _distance3 = arguments[1];
        var _quadrantSegments = arguments[2];
        var endCapStyle = arguments[3];
        var _bufOp2 = new BufferOp(_g4);
        _bufOp2.setQuadrantSegments(_quadrantSegments);
        _bufOp2.setEndCapStyle(endCapStyle);
        var _geomBuf3 = _bufOp2.getResultGeometry(_distance3);
        return _geomBuf3;
      }
    }
  }, {
    key: 'precisionScaleFactor',
    value: function precisionScaleFactor(g, distance, maxPrecisionDigits) {
      var env = g.getEnvelopeInternal();
      var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
      var expandByDistance = distance > 0.0 ? distance : 0.0;
      var bufEnvMax = envMax + 2 * expandByDistance;
      var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
      var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
      var scaleFactor = Math.pow(10.0, minUnitLog10);
      return scaleFactor;
    }
  }, {
    key: 'CAP_ROUND',
    get: function get$$1() {
      return BufferParameters.CAP_ROUND;
    }
  }, {
    key: 'CAP_BUTT',
    get: function get$$1() {
      return BufferParameters.CAP_FLAT;
    }
  }, {
    key: 'CAP_FLAT',
    get: function get$$1() {
      return BufferParameters.CAP_FLAT;
    }
  }, {
    key: 'CAP_SQUARE',
    get: function get$$1() {
      return BufferParameters.CAP_SQUARE;
    }
  }, {
    key: 'MAX_PRECISION_DIGITS',
    get: function get$$1() {
      return 12;
    }
  }]);
  return BufferOp;
}();

var PointPairDistance = function () {
  function PointPairDistance() {
    classCallCheck(this, PointPairDistance);

    this._pt = [new Coordinate(), new Coordinate()];
    this._distance = Double.NaN;
    this._isNull = true;
  }

  createClass(PointPairDistance, [{
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this._pt;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate(i) {
      return this._pt[i];
    }
  }, {
    key: 'setMinimum',
    value: function setMinimum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist < this._distance) this.initialize(p0, p1, dist);
      }
    }
  }, {
    key: 'initialize',
    value: function initialize() {
      if (arguments.length === 0) {
        this._isNull = true;
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        this._pt[0].setCoordinate(p0);
        this._pt[1].setCoordinate(p1);
        this._distance = p0.distance(p1);
        this._isNull = false;
      } else if (arguments.length === 3) {
        var _p = arguments[0];
        var _p2 = arguments[1];
        var distance = arguments[2];
        this._pt[0].setCoordinate(_p);
        this._pt[1].setCoordinate(_p2);
        this._distance = distance;
        this._isNull = false;
      }
    }
  }, {
    key: 'getDistance',
    value: function getDistance() {
      return this._distance;
    }
  }, {
    key: 'setMaximum',
    value: function setMaximum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist > this._distance) this.initialize(p0, p1, dist);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PointPairDistance;
    }
  }]);
  return PointPairDistance;
}();

var DistanceToPointFinder = function () {
  function DistanceToPointFinder() {
    classCallCheck(this, DistanceToPointFinder);
  }

  createClass(DistanceToPointFinder, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DistanceToPointFinder;
    }
  }], [{
    key: 'computeDistance',
    value: function computeDistance() {
      if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineString && arguments[1] instanceof Coordinate) {
        var line = arguments[0];
        var pt = arguments[1];
        var ptDist = arguments[2];
        var coords = line.getCoordinates();
        var tempSegment = new LineSegment();
        for (var i = 0; i < coords.length - 1; i++) {
          tempSegment.setCoordinates(coords[i], coords[i + 1]);
          var closestPt = tempSegment.closestPoint(pt);
          ptDist.setMinimum(closestPt, pt);
        }
      } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate) {
        var poly = arguments[0];
        var _pt = arguments[1];
        var _ptDist = arguments[2];
        DistanceToPointFinder.computeDistance(poly.getExteriorRing(), _pt, _ptDist);
        for (var _i = 0; _i < poly.getNumInteriorRing(); _i++) {
          DistanceToPointFinder.computeDistance(poly.getInteriorRingN(_i), _pt, _ptDist);
        }
      } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate) {
        var geom = arguments[0];
        var _pt2 = arguments[1];
        var _ptDist2 = arguments[2];
        if (geom instanceof LineString) {
          DistanceToPointFinder.computeDistance(geom, _pt2, _ptDist2);
        } else if (geom instanceof Polygon) {
          DistanceToPointFinder.computeDistance(geom, _pt2, _ptDist2);
        } else if (geom instanceof GeometryCollection) {
          var gc = geom;
          for (var _i2 = 0; _i2 < gc.getNumGeometries(); _i2++) {
            var g = gc.getGeometryN(_i2);
            DistanceToPointFinder.computeDistance(g, _pt2, _ptDist2);
          }
        } else {
          _ptDist2.setMinimum(geom.getCoordinate(), _pt2);
        }
      } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate) {
        var segment = arguments[0];
        var _pt3 = arguments[1];
        var _ptDist3 = arguments[2];
        var _closestPt = segment.closestPoint(_pt3);
        _ptDist3.setMinimum(_closestPt, _pt3);
      }
    }
  }]);
  return DistanceToPointFinder;
}();

var BufferCurveMaximumDistanceFinder = function () {
  function BufferCurveMaximumDistanceFinder(inputGeom) {
    classCallCheck(this, BufferCurveMaximumDistanceFinder);

    this._maxPtDist = new PointPairDistance();
    this._inputGeom = inputGeom || null;
  }

  createClass(BufferCurveMaximumDistanceFinder, [{
    key: 'computeMaxMidpointDistance',
    value: function computeMaxMidpointDistance(curve) {
      var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);
      curve.apply(distFilter);
      this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
    }
  }, {
    key: 'computeMaxVertexDistance',
    value: function computeMaxVertexDistance(curve) {
      var distFilter = new MaxPointDistanceFilter(this._inputGeom);
      curve.apply(distFilter);
      this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());
    }
  }, {
    key: 'findDistance',
    value: function findDistance(bufferCurve) {
      this.computeMaxVertexDistance(bufferCurve);
      this.computeMaxMidpointDistance(bufferCurve);
      return this._maxPtDist.getDistance();
    }
  }, {
    key: 'getDistancePoints',
    value: function getDistancePoints() {
      return this._maxPtDist;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BufferCurveMaximumDistanceFinder;
    }
  }], [{
    key: 'MaxPointDistanceFilter',
    get: function get$$1() {
      return MaxPointDistanceFilter;
    }
  }, {
    key: 'MaxMidpointDistanceFilter',
    get: function get$$1() {
      return MaxMidpointDistanceFilter;
    }
  }]);
  return BufferCurveMaximumDistanceFinder;
}();

var MaxPointDistanceFilter = function () {
  function MaxPointDistanceFilter(geom) {
    classCallCheck(this, MaxPointDistanceFilter);

    this._maxPtDist = new PointPairDistance();
    this._minPtDist = new PointPairDistance();
    this._geom = geom || null;
  }

  createClass(MaxPointDistanceFilter, [{
    key: 'filter',
    value: function filter(pt) {
      this._minPtDist.initialize();
      DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);
      this._maxPtDist.setMaximum(this._minPtDist);
    }
  }, {
    key: 'getMaxPointDistance',
    value: function getMaxPointDistance() {
      return this._maxPtDist;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MaxPointDistanceFilter;
    }
  }]);
  return MaxPointDistanceFilter;
}();

var MaxMidpointDistanceFilter = function () {
  function MaxMidpointDistanceFilter(geom) {
    classCallCheck(this, MaxMidpointDistanceFilter);

    this._maxPtDist = new PointPairDistance();
    this._minPtDist = new PointPairDistance();
    this._geom = geom || null;
  }

  createClass(MaxMidpointDistanceFilter, [{
    key: 'filter',
    value: function filter(seq, index) {
      if (index === 0) return null;
      var p0 = seq.getCoordinate(index - 1);
      var p1 = seq.getCoordinate(index);
      var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
      this._minPtDist.initialize();
      DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);
      this._maxPtDist.setMaximum(this._minPtDist);
    }
  }, {
    key: 'isDone',
    value: function isDone() {
      return false;
    }
  }, {
    key: 'isGeometryChanged',
    value: function isGeometryChanged() {
      return false;
    }
  }, {
    key: 'getMaxPointDistance',
    value: function getMaxPointDistance() {
      return this._maxPtDist;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateSequenceFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MaxMidpointDistanceFilter;
    }
  }]);
  return MaxMidpointDistanceFilter;
}();

var PolygonExtracter = function () {
  function PolygonExtracter(comps) {
    classCallCheck(this, PolygonExtracter);

    this._comps = comps || null;
  }

  createClass(PolygonExtracter, [{
    key: 'filter',
    value: function filter(geom) {
      if (geom instanceof Polygon) this._comps.add(geom);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PolygonExtracter;
    }
  }], [{
    key: 'getPolygons',
    value: function getPolygons() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        return PolygonExtracter.getPolygons(geom, new ArrayList());
      } else if (arguments.length === 2) {
        var _geom = arguments[0];
        var list = arguments[1];
        if (_geom instanceof Polygon) {
          list.add(_geom);
        } else if (_geom instanceof GeometryCollection) {
          _geom.apply(new PolygonExtracter(list));
        }
        return list;
      }
    }
  }]);
  return PolygonExtracter;
}();

var LinearComponentExtracter = function () {
  function LinearComponentExtracter() {
    classCallCheck(this, LinearComponentExtracter);

    this._lines = null;
    this._isForcedToLineString = false;
    if (arguments.length === 1) {
      var lines = arguments[0];
      this._lines = lines;
    } else if (arguments.length === 2) {
      var _lines = arguments[0];
      var isForcedToLineString = arguments[1];
      this._lines = _lines;
      this._isForcedToLineString = isForcedToLineString;
    }
  }

  createClass(LinearComponentExtracter, [{
    key: 'filter',
    value: function filter(geom) {
      if (this._isForcedToLineString && geom instanceof LinearRing) {
        var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
        this._lines.add(line);
        return null;
      }
      if (geom instanceof LineString) this._lines.add(geom);
    }
  }, {
    key: 'setForceToLineString',
    value: function setForceToLineString(isForcedToLineString) {
      this._isForcedToLineString = isForcedToLineString;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryComponentFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return LinearComponentExtracter;
    }
  }], [{
    key: 'getGeometry',
    value: function getGeometry() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
      } else if (arguments.length === 2) {
        var _geom = arguments[0];
        var forceToLineString = arguments[1];
        return _geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(_geom, forceToLineString));
      }
    }
  }, {
    key: 'getLines',
    value: function getLines() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        return LinearComponentExtracter.getLines(geom, false);
      } else if (arguments.length === 2) {
        if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
          var geoms = arguments[0];
          var _lines2 = arguments[1];
          for (var i = geoms.iterator(); i.hasNext();) {
            var g = i.next();
            LinearComponentExtracter.getLines(g, _lines2);
          }
          return _lines2;
        } else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {
          var _geom2 = arguments[0];
          var forceToLineString = arguments[1];
          var lines = new ArrayList();
          _geom2.apply(new LinearComponentExtracter(lines, forceToLineString));
          return lines;
        } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
          var _geom3 = arguments[0];
          var _lines3 = arguments[1];
          if (_geom3 instanceof LineString) {
            _lines3.add(_geom3);
          } else {
            _geom3.apply(new LinearComponentExtracter(_lines3));
          }
          return _lines3;
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[2] === 'boolean' && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
          var _geoms = arguments[0];
          var _lines4 = arguments[1];
          var _forceToLineString = arguments[2];
          for (var _i = _geoms.iterator(); _i.hasNext();) {
            var _g = _i.next();
            LinearComponentExtracter.getLines(_g, _lines4, _forceToLineString);
          }
          return _lines4;
        } else if (typeof arguments[2] === 'boolean' && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
          var _geom4 = arguments[0];
          var _lines5 = arguments[1];
          var _forceToLineString2 = arguments[2];
          _geom4.apply(new LinearComponentExtracter(_lines5, _forceToLineString2));
          return _lines5;
        }
      }
    }
  }]);
  return LinearComponentExtracter;
}();

var PointLocator = function () {
  function PointLocator() {
    classCallCheck(this, PointLocator);

    this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
    this._isIn = null;
    this._numBoundaries = null;
    if (arguments.length === 0) {} else if (arguments.length === 1) {
      var boundaryRule = arguments[0];
      if (boundaryRule === null) throw new IllegalArgumentException('Rule must be non-null');
      this._boundaryRule = boundaryRule;
    }
  }

  createClass(PointLocator, [{
    key: 'locateInternal',
    value: function locateInternal() {
      if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {
        var p = arguments[0];
        var poly = arguments[1];
        if (poly.isEmpty()) return Location.EXTERIOR;
        var shell = poly.getExteriorRing();
        var shellLoc = this.locateInPolygonRing(p, shell);
        if (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;
        if (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;
        for (var i = 0; i < poly.getNumInteriorRing(); i++) {
          var hole = poly.getInteriorRingN(i);
          var holeLoc = this.locateInPolygonRing(p, hole);
          if (holeLoc === Location.INTERIOR) return Location.EXTERIOR;
          if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;
        }
        return Location.INTERIOR;
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {
        var _p = arguments[0];
        var l = arguments[1];
        if (!l.getEnvelopeInternal().intersects(_p)) return Location.EXTERIOR;
        var pt = l.getCoordinates();
        if (!l.isClosed()) {
          if (_p.equals(pt[0]) || _p.equals(pt[pt.length - 1])) {
            return Location.BOUNDARY;
          }
        }
        if (CGAlgorithms.isOnLine(_p, pt)) return Location.INTERIOR;
        return Location.EXTERIOR;
      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {
        var _p2 = arguments[0];
        var _pt = arguments[1];
        var ptCoord = _pt.getCoordinate();
        if (ptCoord.equals2D(_p2)) return Location.INTERIOR;
        return Location.EXTERIOR;
      }
    }
  }, {
    key: 'locateInPolygonRing',
    value: function locateInPolygonRing(p, ring) {
      if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;
      return CGAlgorithms.locatePointInRing(p, ring.getCoordinates());
    }
  }, {
    key: 'intersects',
    value: function intersects(p, geom) {
      return this.locate(p, geom) !== Location.EXTERIOR;
    }
  }, {
    key: 'updateLocationInfo',
    value: function updateLocationInfo(loc) {
      if (loc === Location.INTERIOR) this._isIn = true;
      if (loc === Location.BOUNDARY) this._numBoundaries++;
    }
  }, {
    key: 'computeLocation',
    value: function computeLocation(p, geom) {
      if (geom instanceof Point) {
        this.updateLocationInfo(this.locateInternal(p, geom));
      }
      if (geom instanceof LineString) {
        this.updateLocationInfo(this.locateInternal(p, geom));
      } else if (geom instanceof Polygon) {
        this.updateLocationInfo(this.locateInternal(p, geom));
      } else if (geom instanceof MultiLineString) {
        var ml = geom;
        for (var i = 0; i < ml.getNumGeometries(); i++) {
          var l = ml.getGeometryN(i);
          this.updateLocationInfo(this.locateInternal(p, l));
        }
      } else if (geom instanceof MultiPolygon) {
        var mpoly = geom;
        for (var _i = 0; _i < mpoly.getNumGeometries(); _i++) {
          var poly = mpoly.getGeometryN(_i);
          this.updateLocationInfo(this.locateInternal(p, poly));
        }
      } else if (geom instanceof GeometryCollection) {
        var geomi = new GeometryCollectionIterator(geom);
        while (geomi.hasNext()) {
          var g2 = geomi.next();
          if (g2 !== geom) this.computeLocation(p, g2);
        }
      }
    }
  }, {
    key: 'locate',
    value: function locate(p, geom) {
      if (geom.isEmpty()) return Location.EXTERIOR;
      if (geom instanceof LineString) {
        return this.locateInternal(p, geom);
      } else if (geom instanceof Polygon) {
        return this.locateInternal(p, geom);
      }
      this._isIn = false;
      this._numBoundaries = 0;
      this.computeLocation(p, geom);
      if (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;
      if (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;
      return Location.EXTERIOR;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PointLocator;
    }
  }]);
  return PointLocator;
}();

var GeometryLocation = function () {
  function GeometryLocation() {
    classCallCheck(this, GeometryLocation);

    this._component = null;
    this._segIndex = null;
    this._pt = null;
    if (arguments.length === 2) {
      var component = arguments[0];
      var pt = arguments[1];
      GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);
    } else if (arguments.length === 3) {
      var _component = arguments[0];
      var segIndex = arguments[1];
      var _pt = arguments[2];
      this._component = _component;
      this._segIndex = segIndex;
      this._pt = _pt;
    }
  }

  createClass(GeometryLocation, [{
    key: "isInsideArea",
    value: function isInsideArea() {
      return this._segIndex === GeometryLocation.INSIDE_AREA;
    }
  }, {
    key: "getCoordinate",
    value: function getCoordinate() {
      return this._pt;
    }
  }, {
    key: "getGeometryComponent",
    value: function getGeometryComponent() {
      return this._component;
    }
  }, {
    key: "getSegmentIndex",
    value: function getSegmentIndex() {
      return this._segIndex;
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return GeometryLocation;
    }
  }], [{
    key: "INSIDE_AREA",
    get: function get$$1() {
      return -1;
    }
  }]);
  return GeometryLocation;
}();

var PointExtracter = function () {
  function PointExtracter(pts) {
    classCallCheck(this, PointExtracter);

    this._pts = pts || null;
  }

  createClass(PointExtracter, [{
    key: 'filter',
    value: function filter(geom) {
      if (geom instanceof Point) this._pts.add(geom);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PointExtracter;
    }
  }], [{
    key: 'getPoints',
    value: function getPoints() {
      if (arguments.length === 1) {
        var geom = arguments[0];
        if (geom instanceof Point) {
          return Collections.singletonList(geom);
        }
        return PointExtracter.getPoints(geom, new ArrayList());
      } else if (arguments.length === 2) {
        var _geom = arguments[0];
        var list = arguments[1];
        if (_geom instanceof Point) {
          list.add(_geom);
        } else if (_geom instanceof GeometryCollection) {
          _geom.apply(new PointExtracter(list));
        }
        return list;
      }
    }
  }]);
  return PointExtracter;
}();

var ConnectedElementLocationFilter = function () {
  function ConnectedElementLocationFilter() {
    classCallCheck(this, ConnectedElementLocationFilter);

    this._locations = null;
    var locations = arguments[0];
    this._locations = locations;
  }

  createClass(ConnectedElementLocationFilter, [{
    key: 'filter',
    value: function filter(geom) {
      if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return ConnectedElementLocationFilter;
    }
  }], [{
    key: 'getLocations',
    value: function getLocations(geom) {
      var locations = new ArrayList();
      geom.apply(new ConnectedElementLocationFilter(locations));
      return locations;
    }
  }]);
  return ConnectedElementLocationFilter;
}();

var DistanceOp = function () {
  function DistanceOp() {
    classCallCheck(this, DistanceOp);

    this._geom = null;
    this._terminateDistance = 0.0;
    this._ptLocator = new PointLocator();
    this._minDistanceLocation = null;
    this._minDistance = Double.MAX_VALUE;
    if (arguments.length === 2) {
      var g0 = arguments[0];
      var g1 = arguments[1];
      this._geom = [g0, g1];
      this._terminateDistance = 0.0;
    } else if (arguments.length === 3) {
      var _g = arguments[0];
      var _g2 = arguments[1];
      var terminateDistance = arguments[2];
      this._geom = new Array(2).fill(null);
      this._geom[0] = _g;
      this._geom[1] = _g2;
      this._terminateDistance = terminateDistance;
    }
  }

  createClass(DistanceOp, [{
    key: 'computeContainmentDistance',
    value: function computeContainmentDistance() {
      if (arguments.length === 0) {
        var locPtPoly = new Array(2).fill(null);
        this.computeContainmentDistance(0, locPtPoly);
        if (this._minDistance <= this._terminateDistance) return null;
        this.computeContainmentDistance(1, locPtPoly);
      } else if (arguments.length === 2) {
        var polyGeomIndex = arguments[0];
        var _locPtPoly = arguments[1];
        var locationsIndex = 1 - polyGeomIndex;
        var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);
        if (polys.size() > 0) {
          var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);
          this.computeContainmentDistance(insideLocs, polys, _locPtPoly);
          if (this._minDistance <= this._terminateDistance) {
            this._minDistanceLocation[locationsIndex] = _locPtPoly[0];
            this._minDistanceLocation[polyGeomIndex] = _locPtPoly[1];
            return null;
          }
        }
      } else if (arguments.length === 3) {
        if (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {
          var locs = arguments[0];
          var _polys = arguments[1];
          var _locPtPoly2 = arguments[2];
          for (var i = 0; i < locs.size(); i++) {
            var loc = locs.get(i);
            for (var j = 0; j < _polys.size(); j++) {
              this.computeContainmentDistance(loc, _polys.get(j), _locPtPoly2);
              if (this._minDistance <= this._terminateDistance) return null;
            }
          }
        } else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {
          var ptLoc = arguments[0];
          var poly = arguments[1];
          var _locPtPoly3 = arguments[2];
          var pt = ptLoc.getCoordinate();
          if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {
            this._minDistance = 0.0;
            _locPtPoly3[0] = ptLoc;
            _locPtPoly3[1] = new GeometryLocation(poly, pt);

            return null;
          }
        }
      }
    }
  }, {
    key: 'computeMinDistanceLinesPoints',
    value: function computeMinDistanceLinesPoints(lines, points, locGeom) {
      for (var i = 0; i < lines.size(); i++) {
        var line = lines.get(i);
        for (var j = 0; j < points.size(); j++) {
          var pt = points.get(j);
          this.computeMinDistance(line, pt, locGeom);
          if (this._minDistance <= this._terminateDistance) return null;
        }
      }
    }
  }, {
    key: 'computeFacetDistance',
    value: function computeFacetDistance() {
      var locGeom = new Array(2).fill(null);
      var lines0 = LinearComponentExtracter.getLines(this._geom[0]);
      var lines1 = LinearComponentExtracter.getLines(this._geom[1]);
      var pts0 = PointExtracter.getPoints(this._geom[0]);
      var pts1 = PointExtracter.getPoints(this._geom[1]);
      this.computeMinDistanceLines(lines0, lines1, locGeom);
      this.updateMinDistance(locGeom, false);
      if (this._minDistance <= this._terminateDistance) return null;
      locGeom[0] = null;
      locGeom[1] = null;
      this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
      this.updateMinDistance(locGeom, false);
      if (this._minDistance <= this._terminateDistance) return null;
      locGeom[0] = null;
      locGeom[1] = null;
      this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
      this.updateMinDistance(locGeom, true);
      if (this._minDistance <= this._terminateDistance) return null;
      locGeom[0] = null;
      locGeom[1] = null;
      this.computeMinDistancePoints(pts0, pts1, locGeom);
      this.updateMinDistance(locGeom, false);
    }
  }, {
    key: 'nearestLocations',
    value: function nearestLocations() {
      this.computeMinDistance();
      return this._minDistanceLocation;
    }
  }, {
    key: 'updateMinDistance',
    value: function updateMinDistance(locGeom, flip) {
      if (locGeom[0] === null) return null;
      if (flip) {
        this._minDistanceLocation[0] = locGeom[1];
        this._minDistanceLocation[1] = locGeom[0];
      } else {
        this._minDistanceLocation[0] = locGeom[0];
        this._minDistanceLocation[1] = locGeom[1];
      }
    }
  }, {
    key: 'nearestPoints',
    value: function nearestPoints() {
      this.computeMinDistance();
      var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
      return nearestPts;
    }
  }, {
    key: 'computeMinDistance',
    value: function computeMinDistance() {
      if (arguments.length === 0) {
        if (this._minDistanceLocation !== null) return null;
        this._minDistanceLocation = new Array(2).fill(null);
        this.computeContainmentDistance();
        if (this._minDistance <= this._terminateDistance) return null;
        this.computeFacetDistance();
      } else if (arguments.length === 3) {
        if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {
          var line = arguments[0];
          var pt = arguments[1];
          var locGeom = arguments[2];
          if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;
          var coord0 = line.getCoordinates();
          var coord = pt.getCoordinate();
          for (var i = 0; i < coord0.length - 1; i++) {
            var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
            if (dist < this._minDistance) {
              this._minDistance = dist;
              var seg = new LineSegment(coord0[i], coord0[i + 1]);
              var segClosestPoint = seg.closestPoint(coord);
              locGeom[0] = new GeometryLocation(line, i, segClosestPoint);
              locGeom[1] = new GeometryLocation(pt, 0, coord);
            }
            if (this._minDistance <= this._terminateDistance) return null;
          }
        } else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {
          var line0 = arguments[0];
          var line1 = arguments[1];
          var _locGeom = arguments[2];
          if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;
          var _coord = line0.getCoordinates();
          var coord1 = line1.getCoordinates();
          for (var _i = 0; _i < _coord.length - 1; _i++) {
            for (var j = 0; j < coord1.length - 1; j++) {
              var _dist = CGAlgorithms.distanceLineLine(_coord[_i], _coord[_i + 1], coord1[j], coord1[j + 1]);
              if (_dist < this._minDistance) {
                this._minDistance = _dist;
                var seg0 = new LineSegment(_coord[_i], _coord[_i + 1]);
                var seg1 = new LineSegment(coord1[j], coord1[j + 1]);
                var closestPt = seg0.closestPoints(seg1);
                _locGeom[0] = new GeometryLocation(line0, _i, closestPt[0]);
                _locGeom[1] = new GeometryLocation(line1, j, closestPt[1]);
              }
              if (this._minDistance <= this._terminateDistance) return null;
            }
          }
        }
      }
    }
  }, {
    key: 'computeMinDistancePoints',
    value: function computeMinDistancePoints(points0, points1, locGeom) {
      for (var i = 0; i < points0.size(); i++) {
        var pt0 = points0.get(i);
        for (var j = 0; j < points1.size(); j++) {
          var pt1 = points1.get(j);
          var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
          if (dist < this._minDistance) {
            this._minDistance = dist;
            locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());
            locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());
          }
          if (this._minDistance <= this._terminateDistance) return null;
        }
      }
    }
  }, {
    key: 'distance',
    value: function distance() {
      if (this._geom[0] === null || this._geom[1] === null) throw new IllegalArgumentException('null geometries are not supported');
      if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;
      this.computeMinDistance();
      return this._minDistance;
    }
  }, {
    key: 'computeMinDistanceLines',
    value: function computeMinDistanceLines(lines0, lines1, locGeom) {
      for (var i = 0; i < lines0.size(); i++) {
        var line0 = lines0.get(i);
        for (var j = 0; j < lines1.size(); j++) {
          var line1 = lines1.get(j);
          this.computeMinDistance(line0, line1, locGeom);
          if (this._minDistance <= this._terminateDistance) return null;
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DistanceOp;
    }
  }], [{
    key: 'distance',
    value: function distance(g0, g1) {
      var distOp = new DistanceOp(g0, g1);
      return distOp.distance();
    }
  }, {
    key: 'isWithinDistance',
    value: function isWithinDistance(g0, g1, distance) {
      var distOp = new DistanceOp(g0, g1, distance);
      return distOp.distance() <= distance;
    }
  }, {
    key: 'nearestPoints',
    value: function nearestPoints(g0, g1) {
      var distOp = new DistanceOp(g0, g1);
      return distOp.nearestPoints();
    }
  }]);
  return DistanceOp;
}();

var PointPairDistance$2 = function () {
  function PointPairDistance() {
    classCallCheck(this, PointPairDistance);

    this._pt = [new Coordinate(), new Coordinate()];
    this._distance = Double.NaN;
    this._isNull = true;
  }

  createClass(PointPairDistance, [{
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this._pt;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate(i) {
      return this._pt[i];
    }
  }, {
    key: 'setMinimum',
    value: function setMinimum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist < this._distance) this.initialize(p0, p1, dist);
      }
    }
  }, {
    key: 'initialize',
    value: function initialize() {
      if (arguments.length === 0) {
        this._isNull = true;
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        this._pt[0].setCoordinate(p0);
        this._pt[1].setCoordinate(p1);
        this._distance = p0.distance(p1);
        this._isNull = false;
      } else if (arguments.length === 3) {
        var _p = arguments[0];
        var _p2 = arguments[1];
        var distance = arguments[2];
        this._pt[0].setCoordinate(_p);
        this._pt[1].setCoordinate(_p2);
        this._distance = distance;
        this._isNull = false;
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      return WKTWriter.toLineString(this._pt[0], this._pt[1]);
    }
  }, {
    key: 'getDistance',
    value: function getDistance() {
      return this._distance;
    }
  }, {
    key: 'setMaximum',
    value: function setMaximum() {
      if (arguments.length === 1) {
        var ptDist = arguments[0];
        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
      } else if (arguments.length === 2) {
        var p0 = arguments[0];
        var p1 = arguments[1];
        if (this._isNull) {
          this.initialize(p0, p1);
          return null;
        }
        var dist = p0.distance(p1);
        if (dist > this._distance) this.initialize(p0, p1, dist);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PointPairDistance;
    }
  }]);
  return PointPairDistance;
}();

var DistanceToPoint = function () {
  function DistanceToPoint() {
    classCallCheck(this, DistanceToPoint);
  }

  createClass(DistanceToPoint, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DistanceToPoint;
    }
  }], [{
    key: 'computeDistance',
    value: function computeDistance() {
      if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof LineString && arguments[1] instanceof Coordinate) {
        var line = arguments[0];
        var pt = arguments[1];
        var ptDist = arguments[2];
        var tempSegment = new LineSegment();
        var coords = line.getCoordinates();
        for (var i = 0; i < coords.length - 1; i++) {
          tempSegment.setCoordinates(coords[i], coords[i + 1]);
          var closestPt = tempSegment.closestPoint(pt);
          ptDist.setMinimum(closestPt, pt);
        }
      } else if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate) {
        var poly = arguments[0];
        var _pt = arguments[1];
        var _ptDist = arguments[2];
        DistanceToPoint.computeDistance(poly.getExteriorRing(), _pt, _ptDist);
        for (var _i = 0; _i < poly.getNumInteriorRing(); _i++) {
          DistanceToPoint.computeDistance(poly.getInteriorRingN(_i), _pt, _ptDist);
        }
      } else if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate) {
        var geom = arguments[0];
        var _pt2 = arguments[1];
        var _ptDist2 = arguments[2];
        if (geom instanceof LineString) {
          DistanceToPoint.computeDistance(geom, _pt2, _ptDist2);
        } else if (geom instanceof Polygon) {
          DistanceToPoint.computeDistance(geom, _pt2, _ptDist2);
        } else if (geom instanceof GeometryCollection) {
          var gc = geom;
          for (var _i2 = 0; _i2 < gc.getNumGeometries(); _i2++) {
            var g = gc.getGeometryN(_i2);
            DistanceToPoint.computeDistance(g, _pt2, _ptDist2);
          }
        } else {
          _ptDist2.setMinimum(geom.getCoordinate(), _pt2);
        }
      } else if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate) {
        var segment = arguments[0];
        var _pt3 = arguments[1];
        var _ptDist3 = arguments[2];
        var _closestPt = segment.closestPoint(_pt3);
        _ptDist3.setMinimum(_closestPt, _pt3);
      }
    }
  }]);
  return DistanceToPoint;
}();

var DiscreteHausdorffDistance = function () {
  function DiscreteHausdorffDistance() {
    classCallCheck(this, DiscreteHausdorffDistance);

    this._g0 = null;
    this._g1 = null;
    this._ptDist = new PointPairDistance$2();
    this._densifyFrac = 0.0;
    var g0 = arguments[0];
    var g1 = arguments[1];
    this._g0 = g0;
    this._g1 = g1;
  }

  createClass(DiscreteHausdorffDistance, [{
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this._ptDist.getCoordinates();
    }
  }, {
    key: 'setDensifyFraction',
    value: function setDensifyFraction(densifyFrac) {
      if (densifyFrac > 1.0 || densifyFrac <= 0.0) throw new IllegalArgumentException('Fraction is not in range (0.0 - 1.0]');
      this._densifyFrac = densifyFrac;
    }
  }, {
    key: 'compute',
    value: function compute(g0, g1) {
      this.computeOrientedDistance(g0, g1, this._ptDist);
      this.computeOrientedDistance(g1, g0, this._ptDist);
    }
  }, {
    key: 'distance',
    value: function distance() {
      this.compute(this._g0, this._g1);
      return this._ptDist.getDistance();
    }
  }, {
    key: 'computeOrientedDistance',
    value: function computeOrientedDistance(discreteGeom, geom, ptDist) {
      var distFilter = new MaxPointDistanceFilter$1(geom);
      discreteGeom.apply(distFilter);
      ptDist.setMaximum(distFilter.getMaxPointDistance());
      if (this._densifyFrac > 0) {
        var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);
        discreteGeom.apply(fracFilter);
        ptDist.setMaximum(fracFilter.getMaxPointDistance());
      }
    }
  }, {
    key: 'orientedDistance',
    value: function orientedDistance() {
      this.computeOrientedDistance(this._g0, this._g1, this._ptDist);
      return this._ptDist.getDistance();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return DiscreteHausdorffDistance;
    }
  }], [{
    key: 'distance',
    value: function distance() {
      if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        var dist = new DiscreteHausdorffDistance(g0, g1);
        return dist.distance();
      } else if (arguments.length === 3) {
        var _g = arguments[0];
        var _g2 = arguments[1];
        var densifyFrac = arguments[2];
        var _dist = new DiscreteHausdorffDistance(_g, _g2);
        _dist.setDensifyFraction(densifyFrac);
        return _dist.distance();
      }
    }
  }, {
    key: 'MaxPointDistanceFilter',
    get: function get$$1() {
      return MaxPointDistanceFilter$1;
    }
  }, {
    key: 'MaxDensifiedByFractionDistanceFilter',
    get: function get$$1() {
      return MaxDensifiedByFractionDistanceFilter;
    }
  }]);
  return DiscreteHausdorffDistance;
}();

var MaxPointDistanceFilter$1 = function () {
  function MaxPointDistanceFilter() {
    classCallCheck(this, MaxPointDistanceFilter);

    this._maxPtDist = new PointPairDistance$2();
    this._minPtDist = new PointPairDistance$2();
    this._euclideanDist = new DistanceToPoint();
    this._geom = null;
    var geom = arguments[0];
    this._geom = geom;
  }

  createClass(MaxPointDistanceFilter, [{
    key: 'filter',
    value: function filter(pt) {
      this._minPtDist.initialize();
      DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
      this._maxPtDist.setMaximum(this._minPtDist);
    }
  }, {
    key: 'getMaxPointDistance',
    value: function getMaxPointDistance() {
      return this._maxPtDist;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MaxPointDistanceFilter;
    }
  }]);
  return MaxPointDistanceFilter;
}();

var MaxDensifiedByFractionDistanceFilter = function () {
  function MaxDensifiedByFractionDistanceFilter() {
    classCallCheck(this, MaxDensifiedByFractionDistanceFilter);

    this._maxPtDist = new PointPairDistance$2();
    this._minPtDist = new PointPairDistance$2();
    this._geom = null;
    this._numSubSegs = 0;
    var geom = arguments[0];
    var fraction = arguments[1];
    this._geom = geom;
    this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));
  }

  createClass(MaxDensifiedByFractionDistanceFilter, [{
    key: 'filter',
    value: function filter(seq, index) {
      if (index === 0) return null;
      var p0 = seq.getCoordinate(index - 1);
      var p1 = seq.getCoordinate(index);
      var delx = (p1.x - p0.x) / this._numSubSegs;
      var dely = (p1.y - p0.y) / this._numSubSegs;
      for (var i = 0; i < this._numSubSegs; i++) {
        var x = p0.x + i * delx;
        var y = p0.y + i * dely;
        var pt = new Coordinate(x, y);
        this._minPtDist.initialize();
        DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
        this._maxPtDist.setMaximum(this._minPtDist);
      }
    }
  }, {
    key: 'isDone',
    value: function isDone() {
      return false;
    }
  }, {
    key: 'isGeometryChanged',
    value: function isGeometryChanged() {
      return false;
    }
  }, {
    key: 'getMaxPointDistance',
    value: function getMaxPointDistance() {
      return this._maxPtDist;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateSequenceFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return MaxDensifiedByFractionDistanceFilter;
    }
  }]);
  return MaxDensifiedByFractionDistanceFilter;
}();

var BufferDistanceValidator = function () {
  function BufferDistanceValidator(input, bufDistance, result) {
    classCallCheck(this, BufferDistanceValidator);

    this._minValidDistance = null;
    this._maxValidDistance = null;
    this._minDistanceFound = null;
    this._maxDistanceFound = null;
    this._isValid = true;
    this._errMsg = null;
    this._errorLocation = null;
    this._errorIndicator = null;
    this._input = input || null;
    this._bufDistance = bufDistance || null;
    this._result = result || null;
  }

  createClass(BufferDistanceValidator, [{
    key: 'checkMaximumDistance',
    value: function checkMaximumDistance(input, bufCurve, maxDist) {
      var haus = new DiscreteHausdorffDistance(bufCurve, input);
      haus.setDensifyFraction(0.25);
      this._maxDistanceFound = haus.orientedDistance();
      if (this._maxDistanceFound > maxDist) {
        this._isValid = false;
        var pts = haus.getCoordinates();
        this._errorLocation = pts[1];
        this._errorIndicator = input.getFactory().createLineString(pts);
        this._errMsg = 'Distance between buffer curve and input is too large (' + this._maxDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ')';
      }
    }
  }, {
    key: 'isValid',
    value: function isValid() {
      var posDistance = Math.abs(this._bufDistance);
      var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;
      this._minValidDistance = posDistance - distDelta;
      this._maxValidDistance = posDistance + distDelta;
      if (this._input.isEmpty() || this._result.isEmpty()) return true;
      if (this._bufDistance > 0.0) {
        this.checkPositiveValid();
      } else {
        this.checkNegativeValid();
      }
      if (BufferDistanceValidator.VERBOSE) {
        System.out.println('Min Dist= ' + this._minDistanceFound + '  err= ' + (1.0 - this._minDistanceFound / this._bufDistance) + '  Max Dist= ' + this._maxDistanceFound + '  err= ' + (this._maxDistanceFound / this._bufDistance - 1.0));
      }
      return this._isValid;
    }
  }, {
    key: 'checkNegativeValid',
    value: function checkNegativeValid() {
      if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {
        return null;
      }
      var inputCurve = this.getPolygonLines(this._input);
      this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);
      if (!this._isValid) return null;
      this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);
    }
  }, {
    key: 'getErrorIndicator',
    value: function getErrorIndicator() {
      return this._errorIndicator;
    }
  }, {
    key: 'checkMinimumDistance',
    value: function checkMinimumDistance(g1, g2, minDist) {
      var distOp = new DistanceOp(g1, g2, minDist);
      this._minDistanceFound = distOp.distance();
      if (this._minDistanceFound < minDist) {
        this._isValid = false;
        var pts = distOp.nearestPoints();
        this._errorLocation = distOp.nearestPoints()[1];
        this._errorIndicator = g1.getFactory().createLineString(pts);
        this._errMsg = 'Distance between buffer curve and input is too small (' + this._minDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ' )';
      }
    }
  }, {
    key: 'checkPositiveValid',
    value: function checkPositiveValid() {
      var bufCurve = this._result.getBoundary();
      this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);
      if (!this._isValid) return null;
      this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);
    }
  }, {
    key: 'getErrorLocation',
    value: function getErrorLocation() {
      return this._errorLocation;
    }
  }, {
    key: 'getPolygonLines',
    value: function getPolygonLines(g) {
      var lines = new ArrayList();
      var lineExtracter = new LinearComponentExtracter(lines);
      var polys = PolygonExtracter.getPolygons(g);
      for (var i = polys.iterator(); i.hasNext();) {
        var poly = i.next();
        poly.apply(lineExtracter);
      }
      return g.getFactory().buildGeometry(lines);
    }
  }, {
    key: 'getErrorMessage',
    value: function getErrorMessage() {
      return this._errMsg;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BufferDistanceValidator;
    }
  }], [{
    key: 'VERBOSE',
    get: function get$$1() {
      return false;
    }
  }, {
    key: 'MAX_DISTANCE_DIFF_FRAC',
    get: function get$$1() {
      return 0.012;
    }
  }]);
  return BufferDistanceValidator;
}();

var BufferResultValidator = function () {
  function BufferResultValidator(input, distance, result) {
    classCallCheck(this, BufferResultValidator);

    this._isValid = true;
    this._errorMsg = null;
    this._errorLocation = null;
    this._errorIndicator = null;
    this._input = input || null;
    this._distance = distance || null;
    this._result = result || null;
  }

  createClass(BufferResultValidator, [{
    key: 'isValid',
    value: function isValid() {
      this.checkPolygonal();
      if (!this._isValid) return this._isValid;
      this.checkExpectedEmpty();
      if (!this._isValid) return this._isValid;
      this.checkEnvelope();
      if (!this._isValid) return this._isValid;
      this.checkArea();
      if (!this._isValid) return this._isValid;
      this.checkDistance();
      return this._isValid;
    }
  }, {
    key: 'checkEnvelope',
    value: function checkEnvelope() {
      if (this._distance < 0.0) return null;
      var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;
      if (padding === 0.0) padding = 0.001;
      var expectedEnv = new Envelope(this._input.getEnvelopeInternal());
      expectedEnv.expandBy(this._distance);
      var bufEnv = new Envelope(this._result.getEnvelopeInternal());
      bufEnv.expandBy(padding);
      if (!bufEnv.contains(expectedEnv)) {
        this._isValid = false;
        this._errorMsg = 'Buffer envelope is incorrect';
        this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);
      }
      this.report('Envelope');
    }
  }, {
    key: 'checkDistance',
    value: function checkDistance() {
      var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);
      if (!distValid.isValid()) {
        this._isValid = false;
        this._errorMsg = distValid.getErrorMessage();
        this._errorLocation = distValid.getErrorLocation();
        this._errorIndicator = distValid.getErrorIndicator();
      }
      this.report('Distance');
    }
  }, {
    key: 'checkArea',
    value: function checkArea() {
      var inputArea = this._input.getArea();
      var resultArea = this._result.getArea();
      if (this._distance > 0.0 && inputArea > resultArea) {
        this._isValid = false;
        this._errorMsg = 'Area of positive buffer is smaller than input';
        this._errorIndicator = this._result;
      }
      if (this._distance < 0.0 && inputArea < resultArea) {
        this._isValid = false;
        this._errorMsg = 'Area of negative buffer is larger than input';
        this._errorIndicator = this._result;
      }
      this.report('Area');
    }
  }, {
    key: 'checkPolygonal',
    value: function checkPolygonal() {
      if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) this._isValid = false;
      this._errorMsg = 'Result is not polygonal';
      this._errorIndicator = this._result;
      this.report('Polygonal');
    }
  }, {
    key: 'getErrorIndicator',
    value: function getErrorIndicator() {
      return this._errorIndicator;
    }
  }, {
    key: 'getErrorLocation',
    value: function getErrorLocation() {
      return this._errorLocation;
    }
  }, {
    key: 'checkExpectedEmpty',
    value: function checkExpectedEmpty() {
      if (this._input.getDimension() >= 2) return null;
      if (this._distance > 0.0) return null;
      if (!this._result.isEmpty()) {
        this._isValid = false;
        this._errorMsg = 'Result is non-empty';
        this._errorIndicator = this._result;
      }
      this.report('ExpectedEmpty');
    }
  }, {
    key: 'report',
    value: function report(checkName) {
      if (!BufferResultValidator.VERBOSE) return null;
      System.out.println('Check ' + checkName + ': ' + (this._isValid ? 'passed' : 'FAILED'));
    }
  }, {
    key: 'getErrorMessage',
    value: function getErrorMessage() {
      return this._errorMsg;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BufferResultValidator;
    }
  }], [{
    key: 'isValidMsg',
    value: function isValidMsg(g, distance, result) {
      var validator = new BufferResultValidator(g, distance, result);
      if (!validator.isValid()) return validator.getErrorMessage();
      return null;
    }
  }, {
    key: 'isValid',
    value: function isValid(g, distance, result) {
      var validator = new BufferResultValidator(g, distance, result);
      if (validator.isValid()) return true;
      return false;
    }
  }, {
    key: 'VERBOSE',
    get: function get$$1() {
      return false;
    }
  }, {
    key: 'MAX_ENV_DIFF_FRAC',
    get: function get$$1() {
      return 0.012;
    }
  }]);
  return BufferResultValidator;
}();

// operation.buffer

var BasicSegmentString = function () {
  function BasicSegmentString() {
    classCallCheck(this, BasicSegmentString);

    this._pts = null;
    this._data = null;
    var pts = arguments[0];
    var data = arguments[1];
    this._pts = pts;
    this._data = data;
  }

  createClass(BasicSegmentString, [{
    key: 'getCoordinates',
    value: function getCoordinates() {
      return this._pts;
    }
  }, {
    key: 'size',
    value: function size() {
      return this._pts.length;
    }
  }, {
    key: 'getCoordinate',
    value: function getCoordinate(i) {
      return this._pts[i];
    }
  }, {
    key: 'isClosed',
    value: function isClosed() {
      return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }
  }, {
    key: 'getSegmentOctant',
    value: function getSegmentOctant(index) {
      if (index === this._pts.length - 1) return -1;
      return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));
    }
  }, {
    key: 'setData',
    value: function setData(data) {
      this._data = data;
    }
  }, {
    key: 'getData',
    value: function getData() {
      return this._data;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [SegmentString];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return BasicSegmentString;
    }
  }]);
  return BasicSegmentString;
}();

var InteriorIntersectionFinder = function () {
  function InteriorIntersectionFinder() {
    classCallCheck(this, InteriorIntersectionFinder);

    this._findAllIntersections = false;
    this._isCheckEndSegmentsOnly = false;
    this._li = null;
    this._interiorIntersection = null;
    this._intSegments = null;
    this._intersections = new ArrayList();
    this._intersectionCount = 0;
    this._keepIntersections = true;
    var li = arguments[0];
    this._li = li;
    this._interiorIntersection = null;
  }

  createClass(InteriorIntersectionFinder, [{
    key: 'getInteriorIntersection',
    value: function getInteriorIntersection() {
      return this._interiorIntersection;
    }
  }, {
    key: 'setCheckEndSegmentsOnly',
    value: function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
      this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
    }
  }, {
    key: 'getIntersectionSegments',
    value: function getIntersectionSegments() {
      return this._intSegments;
    }
  }, {
    key: 'count',
    value: function count() {
      return this._intersectionCount;
    }
  }, {
    key: 'getIntersections',
    value: function getIntersections() {
      return this._intersections;
    }
  }, {
    key: 'setFindAllIntersections',
    value: function setFindAllIntersections(findAllIntersections) {
      this._findAllIntersections = findAllIntersections;
    }
  }, {
    key: 'setKeepIntersections',
    value: function setKeepIntersections(keepIntersections) {
      this._keepIntersections = keepIntersections;
    }
  }, {
    key: 'processIntersections',
    value: function processIntersections(e0, segIndex0, e1, segIndex1) {
      if (!this._findAllIntersections && this.hasIntersection()) return null;
      if (e0 === e1 && segIndex0 === segIndex1) return null;
      if (this._isCheckEndSegmentsOnly) {
        var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
        if (!isEndSegPresent) return null;
      }
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._li.isInteriorIntersection()) {
          this._intSegments = new Array(4).fill(null);
          this._intSegments[0] = p00;
          this._intSegments[1] = p01;
          this._intSegments[2] = p10;
          this._intSegments[3] = p11;
          this._interiorIntersection = this._li.getIntersection(0);
          if (this._keepIntersections) this._intersections.add(this._interiorIntersection);
          this._intersectionCount++;
        }
      }
    }
  }, {
    key: 'isEndSegment',
    value: function isEndSegment(segStr, index) {
      if (index === 0) return true;
      if (index >= segStr.size() - 2) return true;
      return false;
    }
  }, {
    key: 'hasIntersection',
    value: function hasIntersection() {
      return this._interiorIntersection !== null;
    }
  }, {
    key: 'isDone',
    value: function isDone() {
      if (this._findAllIntersections) return false;
      return this._interiorIntersection !== null;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [SegmentIntersector];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return InteriorIntersectionFinder;
    }
  }], [{
    key: 'createAllIntersectionsFinder',
    value: function createAllIntersectionsFinder(li) {
      var finder = new InteriorIntersectionFinder(li);
      finder.setFindAllIntersections(true);
      return finder;
    }
  }, {
    key: 'createAnyIntersectionFinder',
    value: function createAnyIntersectionFinder(li) {
      return new InteriorIntersectionFinder(li);
    }
  }, {
    key: 'createIntersectionCounter',
    value: function createIntersectionCounter(li) {
      var finder = new InteriorIntersectionFinder(li);
      finder.setFindAllIntersections(true);
      finder.setKeepIntersections(false);
      return finder;
    }
  }]);
  return InteriorIntersectionFinder;
}();

var FastNodingValidator = function () {
  function FastNodingValidator() {
    classCallCheck(this, FastNodingValidator);

    this._li = new RobustLineIntersector();
    this._segStrings = null;
    this._findAllIntersections = false;
    this._segInt = null;
    this._isValid = true;
    var segStrings = arguments[0];
    this._segStrings = segStrings;
  }

  createClass(FastNodingValidator, [{
    key: 'execute',
    value: function execute() {
      if (this._segInt !== null) return null;
      this.checkInteriorIntersections();
    }
  }, {
    key: 'getIntersections',
    value: function getIntersections() {
      return this._segInt.getIntersections();
    }
  }, {
    key: 'isValid',
    value: function isValid() {
      this.execute();
      return this._isValid;
    }
  }, {
    key: 'setFindAllIntersections',
    value: function setFindAllIntersections(findAllIntersections) {
      this._findAllIntersections = findAllIntersections;
    }
  }, {
    key: 'checkInteriorIntersections',
    value: function checkInteriorIntersections() {
      this._isValid = true;
      this._segInt = new InteriorIntersectionFinder(this._li);
      this._segInt.setFindAllIntersections(this._findAllIntersections);
      var noder = new MCIndexNoder();
      noder.setSegmentIntersector(this._segInt);
      noder.computeNodes(this._segStrings);
      if (this._segInt.hasIntersection()) {
        this._isValid = false;
        return null;
      }
    }
  }, {
    key: 'checkValid',
    value: function checkValid() {
      this.execute();
      if (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());
    }
  }, {
    key: 'getErrorMessage',
    value: function getErrorMessage() {
      if (this._isValid) return 'no intersections found';
      var intSegs = this._segInt.getIntersectionSegments();
      return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3]);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return FastNodingValidator;
    }
  }], [{
    key: 'computeIntersections',
    value: function computeIntersections(segStrings) {
      var nv = new FastNodingValidator(segStrings);
      nv.setFindAllIntersections(true);
      nv.isValid();
      return nv.getIntersections();
    }
  }]);
  return FastNodingValidator;
}();

var EdgeNodingValidator = function () {
  function EdgeNodingValidator() {
    classCallCheck(this, EdgeNodingValidator);

    this._nv = null;
    var edges = arguments[0];
    this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));
  }

  createClass(EdgeNodingValidator, [{
    key: 'checkValid',
    value: function checkValid() {
      this._nv.checkValid();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeNodingValidator;
    }
  }], [{
    key: 'toSegmentStrings',
    value: function toSegmentStrings(edges) {
      var segStrings = new ArrayList();
      for (var i = edges.iterator(); i.hasNext();) {
        var e = i.next();
        segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
      }
      return segStrings;
    }
  }, {
    key: 'checkValid',
    value: function checkValid(edges) {
      var validator = new EdgeNodingValidator(edges);
      validator.checkValid();
    }
  }]);
  return EdgeNodingValidator;
}();

var GeometryCollectionMapper = function () {
  function GeometryCollectionMapper(mapOp) {
    classCallCheck(this, GeometryCollectionMapper);

    this._mapOp = mapOp;
  }

  createClass(GeometryCollectionMapper, [{
    key: 'map',
    value: function map(gc) {
      var mapped = new ArrayList();
      for (var i = 0; i < gc.getNumGeometries(); i++) {
        var g = this._mapOp.map(gc.getGeometryN(i));
        if (!g.isEmpty()) mapped.add(g);
      }
      return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryCollectionMapper;
    }
  }], [{
    key: 'map',
    value: function map(gc, op) {
      var mapper = new GeometryCollectionMapper(op);
      return mapper.map(gc);
    }
  }]);
  return GeometryCollectionMapper;
}();

var LineBuilder = function () {
  function LineBuilder() {
    classCallCheck(this, LineBuilder);

    this._op = null;
    this._geometryFactory = null;
    this._ptLocator = null;
    this._lineEdgesList = new ArrayList();
    this._resultLineList = new ArrayList();
    var op = arguments[0];
    var geometryFactory = arguments[1];
    var ptLocator = arguments[2];
    this._op = op;
    this._geometryFactory = geometryFactory;
    this._ptLocator = ptLocator;
  }

  createClass(LineBuilder, [{
    key: 'collectLines',
    value: function collectLines(opCode) {
      for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
        var de = it.next();
        this.collectLineEdge(de, opCode, this._lineEdgesList);
        this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);
      }
    }
  }, {
    key: 'labelIsolatedLine',
    value: function labelIsolatedLine(e, targetIndex) {
      var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
      e.getLabel().setLocation(targetIndex, loc);
    }
  }, {
    key: 'build',
    value: function build(opCode) {
      this.findCoveredLineEdges();
      this.collectLines(opCode);
      this.buildLines(opCode);
      return this._resultLineList;
    }
  }, {
    key: 'collectLineEdge',
    value: function collectLineEdge(de, opCode, edges) {
      var label = de.getLabel();
      var e = de.getEdge();
      if (de.isLineEdge()) {
        if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {
          edges.add(e);
          de.setVisitedEdge(true);
        }
      }
    }
  }, {
    key: 'findCoveredLineEdges',
    value: function findCoveredLineEdges() {
      for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        node.getEdges().findCoveredLineEdges();
      }
      for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
        var de = it.next();
        var e = de.getEdge();
        if (de.isLineEdge() && !e.isCoveredSet()) {
          var isCovered = this._op.isCoveredByA(de.getCoordinate());
          e.setCovered(isCovered);
        }
      }
    }
  }, {
    key: 'labelIsolatedLines',
    value: function labelIsolatedLines(edgesList) {
      for (var it = edgesList.iterator(); it.hasNext();) {
        var e = it.next();
        var label = e.getLabel();
        if (e.isIsolated()) {
          if (label.isNull(0)) this.labelIsolatedLine(e, 0);else this.labelIsolatedLine(e, 1);
        }
      }
    }
  }, {
    key: 'buildLines',
    value: function buildLines(opCode) {
      for (var it = this._lineEdgesList.iterator(); it.hasNext();) {
        var e = it.next();
        // const label = e.getLabel()
        var line = this._geometryFactory.createLineString(e.getCoordinates());
        this._resultLineList.add(line);
        e.setInResult(true);
      }
    }
  }, {
    key: 'collectBoundaryTouchEdge',
    value: function collectBoundaryTouchEdge(de, opCode, edges) {
      var label = de.getLabel();
      if (de.isLineEdge()) return null;
      if (de.isVisited()) return null;
      if (de.isInteriorAreaEdge()) return null;
      if (de.getEdge().isInResult()) return null;
      Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
      if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
        edges.add(de.getEdge());
        de.setVisitedEdge(true);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return LineBuilder;
    }
  }]);
  return LineBuilder;
}();

var PointBuilder = function () {
  function PointBuilder() {
    classCallCheck(this, PointBuilder);

    this._op = null;
    this._geometryFactory = null;
    this._resultPointList = new ArrayList();
    var op = arguments[0];
    var geometryFactory = arguments[1];
    // const ptLocator = arguments[2]
    this._op = op;
    this._geometryFactory = geometryFactory;
  }

  createClass(PointBuilder, [{
    key: 'filterCoveredNodeToPoint',
    value: function filterCoveredNodeToPoint(n) {
      var coord = n.getCoordinate();
      if (!this._op.isCoveredByLA(coord)) {
        var pt = this._geometryFactory.createPoint(coord);
        this._resultPointList.add(pt);
      }
    }
  }, {
    key: 'extractNonCoveredResultNodes',
    value: function extractNonCoveredResultNodes(opCode) {
      for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
        var n = nodeit.next();
        if (n.isInResult()) continue;
        if (n.isIncidentEdgeInResult()) continue;
        if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
          var label = n.getLabel();
          if (OverlayOp.isResultOfOp(label, opCode)) {
            this.filterCoveredNodeToPoint(n);
          }
        }
      }
    }
  }, {
    key: 'build',
    value: function build(opCode) {
      this.extractNonCoveredResultNodes(opCode);
      return this._resultPointList;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PointBuilder;
    }
  }]);
  return PointBuilder;
}();

var GeometryTransformer = function () {
  function GeometryTransformer() {
    classCallCheck(this, GeometryTransformer);

    this._inputGeom = null;
    this._factory = null;
    this._pruneEmptyGeometry = true;
    this._preserveGeometryCollectionType = true;
    this._preserveCollections = false;
    this._preserveType = false;
  }

  createClass(GeometryTransformer, [{
    key: 'transformPoint',
    value: function transformPoint(geom, parent) {
      return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    }
  }, {
    key: 'transformPolygon',
    value: function transformPolygon(geom, parent) {
      var isAllValidLinearRings = true;
      var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
      if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;
      var holes = new ArrayList();
      for (var i = 0; i < geom.getNumInteriorRing(); i++) {
        var hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
        if (hole === null || hole.isEmpty()) {
          continue;
        }
        if (!(hole instanceof LinearRing)) isAllValidLinearRings = false;
        holes.add(hole);
      }
      if (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));else {
        var components = new ArrayList();
        if (shell !== null) components.add(shell);
        components.addAll(holes);
        return this._factory.buildGeometry(components);
      }
    }
  }, {
    key: 'createCoordinateSequence',
    value: function createCoordinateSequence(coords) {
      return this._factory.getCoordinateSequenceFactory().create(coords);
    }
  }, {
    key: 'getInputGeometry',
    value: function getInputGeometry() {
      return this._inputGeom;
    }
  }, {
    key: 'transformMultiLineString',
    value: function transformMultiLineString(geom, parent) {
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
        if (transformGeom === null) continue;
        if (transformGeom.isEmpty()) continue;
        transGeomList.add(transformGeom);
      }
      return this._factory.buildGeometry(transGeomList);
    }
  }, {
    key: 'transformCoordinates',
    value: function transformCoordinates(coords, parent) {
      return this.copy(coords);
    }
  }, {
    key: 'transformLineString',
    value: function transformLineString(geom, parent) {
      return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    }
  }, {
    key: 'transformMultiPoint',
    value: function transformMultiPoint(geom, parent) {
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
        if (transformGeom === null) continue;
        if (transformGeom.isEmpty()) continue;
        transGeomList.add(transformGeom);
      }
      return this._factory.buildGeometry(transGeomList);
    }
  }, {
    key: 'transformMultiPolygon',
    value: function transformMultiPolygon(geom, parent) {
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
        if (transformGeom === null) continue;
        if (transformGeom.isEmpty()) continue;
        transGeomList.add(transformGeom);
      }
      return this._factory.buildGeometry(transGeomList);
    }
  }, {
    key: 'copy',
    value: function copy(seq) {
      return seq.copy();
    }
  }, {
    key: 'transformGeometryCollection',
    value: function transformGeometryCollection(geom, parent) {
      var transGeomList = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var transformGeom = this.transform(geom.getGeometryN(i));
        if (transformGeom === null) continue;
        if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;
        transGeomList.add(transformGeom);
      }
      if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));
      return this._factory.buildGeometry(transGeomList);
    }
  }, {
    key: 'transform',
    value: function transform(inputGeom) {
      this._inputGeom = inputGeom;
      this._factory = inputGeom.getFactory();
      if (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);
      if (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);
      if (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);
      if (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);
      if (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);
      if (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);
      if (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);
      if (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);
      throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getClass().getName());
    }
  }, {
    key: 'transformLinearRing',
    value: function transformLinearRing(geom, parent) {
      var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
      if (seq === null) return this._factory.createLinearRing(null);
      var seqSize = seq.size();
      if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);
      return this._factory.createLinearRing(seq);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryTransformer;
    }
  }]);
  return GeometryTransformer;
}();

var LineStringSnapper = function () {
  function LineStringSnapper() {
    classCallCheck(this, LineStringSnapper);

    this._snapTolerance = 0.0;
    this._srcPts = null;
    this._seg = new LineSegment();
    this._allowSnappingToSourceVertices = false;
    this._isClosed = false;
    if (arguments[0] instanceof LineString && typeof arguments[1] === 'number') {
      var srcLine = arguments[0];
      var snapTolerance = arguments[1];
      LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);
    } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {
      var srcPts = arguments[0];
      var _snapTolerance = arguments[1];
      this._srcPts = srcPts;
      this._isClosed = LineStringSnapper.isClosed(srcPts);
      this._snapTolerance = _snapTolerance;
    }
  }

  createClass(LineStringSnapper, [{
    key: 'snapVertices',
    value: function snapVertices(srcCoords, snapPts) {
      var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
      for (var i = 0; i < end; i++) {
        var srcPt = srcCoords.get(i);
        var snapVert = this.findSnapForVertex(srcPt, snapPts);
        if (snapVert !== null) {
          srcCoords.set(i, new Coordinate(snapVert));
          if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));
        }
      }
    }
  }, {
    key: 'findSnapForVertex',
    value: function findSnapForVertex(pt, snapPts) {
      for (var i = 0; i < snapPts.length; i++) {
        if (pt.equals2D(snapPts[i])) return null;
        if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];
      }
      return null;
    }
  }, {
    key: 'snapTo',
    value: function snapTo(snapPts) {
      var coordList = new CoordinateList(this._srcPts);
      this.snapVertices(coordList, snapPts);
      this.snapSegments(coordList, snapPts);
      var newPts = coordList.toCoordinateArray();
      return newPts;
    }
  }, {
    key: 'snapSegments',
    value: function snapSegments(srcCoords, snapPts) {
      if (snapPts.length === 0) return null;
      var distinctPtCount = snapPts.length;
      if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;
      for (var i = 0; i < distinctPtCount; i++) {
        var snapPt = snapPts[i];
        var index = this.findSegmentIndexToSnap(snapPt, srcCoords);
        if (index >= 0) {
          srcCoords.add(index + 1, new Coordinate(snapPt), false);
        }
      }
    }
  }, {
    key: 'findSegmentIndexToSnap',
    value: function findSegmentIndexToSnap(snapPt, srcCoords) {
      var minDist = Double.MAX_VALUE;
      var snapIndex = -1;
      for (var i = 0; i < srcCoords.size() - 1; i++) {
        this._seg.p0 = srcCoords.get(i);
        this._seg.p1 = srcCoords.get(i + 1);
        if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {
          if (this._allowSnappingToSourceVertices) continue;else return -1;
        }
        var dist = this._seg.distance(snapPt);
        if (dist < this._snapTolerance && dist < minDist) {
          minDist = dist;
          snapIndex = i;
        }
      }
      return snapIndex;
    }
  }, {
    key: 'setAllowSnappingToSourceVertices',
    value: function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
      this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return LineStringSnapper;
    }
  }], [{
    key: 'isClosed',
    value: function isClosed(pts) {
      if (pts.length <= 1) return false;
      return pts[0].equals2D(pts[pts.length - 1]);
    }
  }]);
  return LineStringSnapper;
}();

var GeometrySnapper = function () {
  function GeometrySnapper(srcGeom) {
    classCallCheck(this, GeometrySnapper);

    this._srcGeom = srcGeom || null;
  }

  createClass(GeometrySnapper, [{
    key: 'snapTo',
    value: function snapTo(snapGeom, snapTolerance) {
      var snapPts = this.extractTargetCoordinates(snapGeom);
      var snapTrans = new SnapTransformer(snapTolerance, snapPts);
      return snapTrans.transform(this._srcGeom);
    }
  }, {
    key: 'snapToSelf',
    value: function snapToSelf(snapTolerance, cleanResult) {
      var snapPts = this.extractTargetCoordinates(this._srcGeom);
      var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
      var snappedGeom = snapTrans.transform(this._srcGeom);
      var result = snappedGeom;
      if (cleanResult && hasInterface(result, Polygonal)) {
        result = snappedGeom.buffer(0);
      }
      return result;
    }
  }, {
    key: 'computeSnapTolerance',
    value: function computeSnapTolerance(ringPts) {
      var minSegLen = this.computeMinimumSegmentLength(ringPts);
      var snapTol = minSegLen / 10;
      return snapTol;
    }
  }, {
    key: 'extractTargetCoordinates',
    value: function extractTargetCoordinates(g) {
      var ptSet = new TreeSet();
      var pts = g.getCoordinates();
      for (var i = 0; i < pts.length; i++) {
        ptSet.add(pts[i]);
      }
      return ptSet.toArray(new Array(0).fill(null));
    }
  }, {
    key: 'computeMinimumSegmentLength',
    value: function computeMinimumSegmentLength(pts) {
      var minSegLen = Double.MAX_VALUE;
      for (var i = 0; i < pts.length - 1; i++) {
        var segLen = pts[i].distance(pts[i + 1]);
        if (segLen < minSegLen) minSegLen = segLen;
      }
      return minSegLen;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometrySnapper;
    }
  }], [{
    key: 'snap',
    value: function snap(g0, g1, snapTolerance) {
      var snapGeom = new Array(2).fill(null);
      var snapper0 = new GeometrySnapper(g0);
      snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
      var snapper1 = new GeometrySnapper(g1);
      snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
      return snapGeom;
    }
  }, {
    key: 'computeOverlaySnapTolerance',
    value: function computeOverlaySnapTolerance() {
      if (arguments.length === 1) {
        var g = arguments[0];
        var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
        var pm = g.getPrecisionModel();
        if (pm.getType() === PrecisionModel.FIXED) {
          var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
          if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;
        }
        return snapTolerance;
      } else if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
      }
    }
  }, {
    key: 'computeSizeBasedSnapTolerance',
    value: function computeSizeBasedSnapTolerance(g) {
      var env = g.getEnvelopeInternal();
      var minDimension = Math.min(env.getHeight(), env.getWidth());
      var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
      return snapTol;
    }
  }, {
    key: 'snapToSelf',
    value: function snapToSelf(geom, snapTolerance, cleanResult) {
      var snapper0 = new GeometrySnapper(geom);
      return snapper0.snapToSelf(snapTolerance, cleanResult);
    }
  }, {
    key: 'SNAP_PRECISION_FACTOR',
    get: function get$$1() {
      return 1e-9;
    }
  }]);
  return GeometrySnapper;
}();

var SnapTransformer = function (_GeometryTransformer) {
  inherits(SnapTransformer, _GeometryTransformer);

  function SnapTransformer(snapTolerance, snapPts, isSelfSnap) {
    classCallCheck(this, SnapTransformer);

    var _this = possibleConstructorReturn(this, (SnapTransformer.__proto__ || Object.getPrototypeOf(SnapTransformer)).call(this));

    _this._snapTolerance = snapTolerance || null;
    _this._snapPts = snapPts || null;
    _this._isSelfSnap = isSelfSnap !== undefined ? isSelfSnap : false;
    return _this;
  }

  createClass(SnapTransformer, [{
    key: 'snapLine',
    value: function snapLine(srcPts, snapPts) {
      var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
      snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
      return snapper.snapTo(snapPts);
    }
  }, {
    key: 'transformCoordinates',
    value: function transformCoordinates(coords, parent) {
      var srcPts = coords.toCoordinateArray();
      var newPts = this.snapLine(srcPts, this._snapPts);
      return this._factory.getCoordinateSequenceFactory().create(newPts);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SnapTransformer;
    }
  }]);
  return SnapTransformer;
}(GeometryTransformer);

var CommonBits = function () {
  function CommonBits() {
    classCallCheck(this, CommonBits);

    this._isFirst = true;
    this._commonMantissaBitsCount = 53;
    this._commonBits = 0;
    this._commonSignExp = null;
  }

  createClass(CommonBits, [{
    key: 'getCommon',
    value: function getCommon() {
      return Double.longBitsToDouble(this._commonBits);
    }
  }, {
    key: 'add',
    value: function add(num) {
      var numBits = Double.doubleToLongBits(num);
      if (this._isFirst) {
        this._commonBits = numBits;
        this._commonSignExp = CommonBits.signExpBits(this._commonBits);
        this._isFirst = false;
        return null;
      }
      var numSignExp = CommonBits.signExpBits(numBits);
      if (numSignExp !== this._commonSignExp) {
        this._commonBits = 0;
        return null;
      }
      this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
      this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
    }
  }, {
    key: 'toString',
    value: function toString() {
      if (arguments.length === 1) {
        var bits = arguments[0];
        var x = Double.longBitsToDouble(bits);
        var numStr = Double.toBinaryString(bits);
        var padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;
        var bitStr = padStr.substring(padStr.length - 64);
        var str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';
        return str;
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CommonBits;
    }
  }], [{
    key: 'getBit',
    value: function getBit(bits, i) {
      var mask = 1 << i;
      return (bits & mask) !== 0 ? 1 : 0;
    }
  }, {
    key: 'signExpBits',
    value: function signExpBits(num) {
      return num >> 52;
    }
  }, {
    key: 'zeroLowerBits',
    value: function zeroLowerBits(bits, nBits) {
      var invMask = (1 << nBits) - 1;
      var mask = ~invMask;
      var zeroed = bits & mask;
      return zeroed;
    }
  }, {
    key: 'numCommonMostSigMantissaBits',
    value: function numCommonMostSigMantissaBits(num1, num2) {
      var count = 0;
      for (var i = 52; i >= 0; i--) {
        if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;
        count++;
      }
      return 52;
    }
  }]);
  return CommonBits;
}();

var CommonBitsRemover = function () {
  function CommonBitsRemover() {
    classCallCheck(this, CommonBitsRemover);

    this._commonCoord = null;
    this._ccFilter = new CommonCoordinateFilter();
  }

  createClass(CommonBitsRemover, [{
    key: 'addCommonBits',
    value: function addCommonBits(geom) {
      var trans = new Translater(this._commonCoord);
      geom.apply(trans);
      geom.geometryChanged();
    }
  }, {
    key: 'removeCommonBits',
    value: function removeCommonBits(geom) {
      if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;
      var invCoord = new Coordinate(this._commonCoord);
      invCoord.x = -invCoord.x;
      invCoord.y = -invCoord.y;
      var trans = new Translater(invCoord);
      geom.apply(trans);
      geom.geometryChanged();
      return geom;
    }
  }, {
    key: 'getCommonCoordinate',
    value: function getCommonCoordinate() {
      return this._commonCoord;
    }
  }, {
    key: 'add',
    value: function add(geom) {
      geom.apply(this._ccFilter);
      this._commonCoord = this._ccFilter.getCommonCoordinate();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CommonBitsRemover;
    }
  }], [{
    key: 'CommonCoordinateFilter',
    get: function get$$1() {
      return CommonCoordinateFilter;
    }
  }, {
    key: 'Translater',
    get: function get$$1() {
      return Translater;
    }
  }]);
  return CommonBitsRemover;
}();

var CommonCoordinateFilter = function () {
  function CommonCoordinateFilter() {
    classCallCheck(this, CommonCoordinateFilter);

    this._commonBitsX = new CommonBits();
    this._commonBitsY = new CommonBits();
  }

  createClass(CommonCoordinateFilter, [{
    key: 'filter',
    value: function filter(coord) {
      this._commonBitsX.add(coord.x);
      this._commonBitsY.add(coord.y);
    }
  }, {
    key: 'getCommonCoordinate',
    value: function getCommonCoordinate() {
      return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CommonCoordinateFilter;
    }
  }]);
  return CommonCoordinateFilter;
}();

var Translater = function () {
  function Translater() {
    classCallCheck(this, Translater);

    this.trans = null;
    var trans = arguments[0];
    this.trans = trans;
  }

  createClass(Translater, [{
    key: 'filter',
    value: function filter(seq, i) {
      var xp = seq.getOrdinate(i, 0) + this.trans.x;
      var yp = seq.getOrdinate(i, 1) + this.trans.y;
      seq.setOrdinate(i, 0, xp);
      seq.setOrdinate(i, 1, yp);
    }
  }, {
    key: 'isDone',
    value: function isDone() {
      return false;
    }
  }, {
    key: 'isGeometryChanged',
    value: function isGeometryChanged() {
      return true;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [CoordinateSequenceFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return Translater;
    }
  }]);
  return Translater;
}();

var SnapOverlayOp = function () {
  function SnapOverlayOp(g1, g2) {
    classCallCheck(this, SnapOverlayOp);

    this._geom = new Array(2).fill(null);
    this._snapTolerance = null;
    this._cbr = null;
    this._geom[0] = g1;
    this._geom[1] = g2;
    this.computeSnapTolerance();
  }

  createClass(SnapOverlayOp, [{
    key: 'selfSnap',
    value: function selfSnap(geom) {
      var snapper0 = new GeometrySnapper(geom);
      var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
      return snapGeom;
    }
  }, {
    key: 'removeCommonBits',
    value: function removeCommonBits(geom) {
      this._cbr = new CommonBitsRemover();
      this._cbr.add(geom[0]);
      this._cbr.add(geom[1]);
      var remGeom = new Array(2).fill(null);
      remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
      remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
      return remGeom;
    }
  }, {
    key: 'prepareResult',
    value: function prepareResult(geom) {
      this._cbr.addCommonBits(geom);
      return geom;
    }
  }, {
    key: 'getResultGeometry',
    value: function getResultGeometry(opCode) {
      var prepGeom = this.snap(this._geom);
      var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
      return this.prepareResult(result);
    }
  }, {
    key: 'checkValid',
    value: function checkValid(g) {
      if (!g.isValid()) {
        System.out.println('Snapped geometry is invalid');
      }
    }
  }, {
    key: 'computeSnapTolerance',
    value: function computeSnapTolerance() {
      this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
    }
  }, {
    key: 'snap',
    value: function snap(geom) {
      var remGeom = this.removeCommonBits(geom);
      var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
      return snapGeom;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SnapOverlayOp;
    }
  }], [{
    key: 'overlayOp',
    value: function overlayOp(g0, g1, opCode) {
      var op = new SnapOverlayOp(g0, g1);
      return op.getResultGeometry(opCode);
    }
  }, {
    key: 'union',
    value: function union(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
    }
  }, {
    key: 'intersection',
    value: function intersection(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
    }
  }, {
    key: 'symDifference',
    value: function symDifference(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
    }
  }, {
    key: 'difference',
    value: function difference(g0, g1) {
      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
    }
  }]);
  return SnapOverlayOp;
}();

var SnapIfNeededOverlayOp = function () {
  function SnapIfNeededOverlayOp(g1, g2) {
    classCallCheck(this, SnapIfNeededOverlayOp);

    this._geom = new Array(2).fill(null);
    this._geom[0] = g1;
    this._geom[1] = g2;
  }

  createClass(SnapIfNeededOverlayOp, [{
    key: 'getResultGeometry',
    value: function getResultGeometry(opCode) {
      var result = null;
      var isSuccess = false;
      var savedException = null;
      try {
        result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
        var isValid = true;
        if (isValid) isSuccess = true;
      } catch (ex) {
        if (ex instanceof RuntimeException) {
          savedException = ex;
        } else throw ex;
      } finally {}
      if (!isSuccess) {
        try {
          result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
        } catch (ex) {
          if (ex instanceof RuntimeException) {
            throw savedException;
          } else throw ex;
        } finally {}
      }
      return result;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SnapIfNeededOverlayOp;
    }
  }], [{
    key: 'overlayOp',
    value: function overlayOp(g0, g1, opCode) {
      var op = new SnapIfNeededOverlayOp(g0, g1);
      return op.getResultGeometry(opCode);
    }
  }, {
    key: 'union',
    value: function union(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
    }
  }, {
    key: 'intersection',
    value: function intersection(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
    }
  }, {
    key: 'symDifference',
    value: function symDifference(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
    }
  }, {
    key: 'difference',
    value: function difference(g0, g1) {
      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
    }
  }]);
  return SnapIfNeededOverlayOp;
}();

var MonotoneChain$2 = function () {
  function MonotoneChain() {
    classCallCheck(this, MonotoneChain);

    this.mce = null;
    this.chainIndex = null;
    var mce = arguments[0];
    var chainIndex = arguments[1];
    this.mce = mce;
    this.chainIndex = chainIndex;
  }

  createClass(MonotoneChain, [{
    key: "computeIntersections",
    value: function computeIntersections(mc, si) {
      this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return MonotoneChain;
    }
  }]);
  return MonotoneChain;
}();

var SweepLineEvent = function () {
  function SweepLineEvent() {
    classCallCheck(this, SweepLineEvent);

    this._label = null;
    this._xValue = null;
    this._eventType = null;
    this._insertEvent = null;
    this._deleteEventIndex = null;
    this._obj = null;
    if (arguments.length === 2) {
      var x = arguments[0];
      var insertEvent = arguments[1];
      this._eventType = SweepLineEvent.DELETE;
      this._xValue = x;
      this._insertEvent = insertEvent;
    } else if (arguments.length === 3) {
      var label = arguments[0];
      var _x = arguments[1];
      var obj = arguments[2];
      this._eventType = SweepLineEvent.INSERT;
      this._label = label;
      this._xValue = _x;
      this._obj = obj;
    }
  }

  createClass(SweepLineEvent, [{
    key: 'isDelete',
    value: function isDelete() {
      return this._eventType === SweepLineEvent.DELETE;
    }
  }, {
    key: 'setDeleteEventIndex',
    value: function setDeleteEventIndex(deleteEventIndex) {
      this._deleteEventIndex = deleteEventIndex;
    }
  }, {
    key: 'getObject',
    value: function getObject() {
      return this._obj;
    }
  }, {
    key: 'compareTo',
    value: function compareTo(o) {
      var pe = o;
      if (this._xValue < pe._xValue) return -1;
      if (this._xValue > pe._xValue) return 1;
      if (this._eventType < pe._eventType) return -1;
      if (this._eventType > pe._eventType) return 1;
      return 0;
    }
  }, {
    key: 'getInsertEvent',
    value: function getInsertEvent() {
      return this._insertEvent;
    }
  }, {
    key: 'isInsert',
    value: function isInsert() {
      return this._eventType === SweepLineEvent.INSERT;
    }
  }, {
    key: 'isSameLabel',
    value: function isSameLabel(ev) {
      if (this._label === null) return false;
      return this._label === ev._label;
    }
  }, {
    key: 'getDeleteEventIndex',
    value: function getDeleteEventIndex() {
      return this._deleteEventIndex;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparable];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SweepLineEvent;
    }
  }], [{
    key: 'INSERT',
    get: function get$$1() {
      return 1;
    }
  }, {
    key: 'DELETE',
    get: function get$$1() {
      return 2;
    }
  }]);
  return SweepLineEvent;
}();

var EdgeSetIntersector = function () {
  function EdgeSetIntersector() {
    classCallCheck(this, EdgeSetIntersector);
  }

  createClass(EdgeSetIntersector, [{
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return EdgeSetIntersector;
    }
  }]);
  return EdgeSetIntersector;
}();

var SegmentIntersector$2 = function () {
  function SegmentIntersector() {
    classCallCheck(this, SegmentIntersector);

    this._hasIntersection = false;
    this._hasProper = false;
    this._hasProperInterior = false;
    this._properIntersectionPoint = null;
    this._li = null;
    this._includeProper = null;
    this._recordIsolated = null;
    this._isSelfIntersection = null;
    this._numIntersections = 0;
    this.numTests = 0;
    this._bdyNodes = null;
    this._isDone = false;
    this._isDoneWhenProperInt = false;
    var li = arguments[0];
    var includeProper = arguments[1];
    var recordIsolated = arguments[2];
    this._li = li;
    this._includeProper = includeProper;
    this._recordIsolated = recordIsolated;
  }

  createClass(SegmentIntersector, [{
    key: "isTrivialIntersection",
    value: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1) {
        if (this._li.getIntersectionNum() === 1) {
          if (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;
          if (e0.isClosed()) {
            var maxSegIndex = e0.getNumPoints() - 1;
            if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }, {
    key: "getProperIntersectionPoint",
    value: function getProperIntersectionPoint() {
      return this._properIntersectionPoint;
    }
  }, {
    key: "setIsDoneIfProperInt",
    value: function setIsDoneIfProperInt(isDoneWhenProperInt) {
      this._isDoneWhenProperInt = isDoneWhenProperInt;
    }
  }, {
    key: "hasProperInteriorIntersection",
    value: function hasProperInteriorIntersection() {
      return this._hasProperInterior;
    }
  }, {
    key: "isBoundaryPointInternal",
    value: function isBoundaryPointInternal(li, bdyNodes) {
      for (var i = bdyNodes.iterator(); i.hasNext();) {
        var node = i.next();
        var pt = node.getCoordinate();
        if (li.isIntersection(pt)) return true;
      }
      return false;
    }
  }, {
    key: "hasProperIntersection",
    value: function hasProperIntersection() {
      return this._hasProper;
    }
  }, {
    key: "hasIntersection",
    value: function hasIntersection() {
      return this._hasIntersection;
    }
  }, {
    key: "isDone",
    value: function isDone() {
      return this._isDone;
    }
  }, {
    key: "isBoundaryPoint",
    value: function isBoundaryPoint(li, bdyNodes) {
      if (bdyNodes === null) return false;
      if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;
      if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;
      return false;
    }
  }, {
    key: "setBoundaryNodes",
    value: function setBoundaryNodes(bdyNodes0, bdyNodes1) {
      this._bdyNodes = new Array(2).fill(null);
      this._bdyNodes[0] = bdyNodes0;
      this._bdyNodes[1] = bdyNodes1;
    }
  }, {
    key: "addIntersections",
    value: function addIntersections(e0, segIndex0, e1, segIndex1) {
      if (e0 === e1 && segIndex0 === segIndex1) return null;
      this.numTests++;
      var p00 = e0.getCoordinates()[segIndex0];
      var p01 = e0.getCoordinates()[segIndex0 + 1];
      var p10 = e1.getCoordinates()[segIndex1];
      var p11 = e1.getCoordinates()[segIndex1 + 1];
      this._li.computeIntersection(p00, p01, p10, p11);
      if (this._li.hasIntersection()) {
        if (this._recordIsolated) {
          e0.setIsolated(false);
          e1.setIsolated(false);
        }
        this._numIntersections++;
        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
          this._hasIntersection = true;
          if (this._includeProper || !this._li.isProper()) {
            e0.addIntersections(this._li, segIndex0, 0);
            e1.addIntersections(this._li, segIndex1, 1);
          }
          if (this._li.isProper()) {
            this._properIntersectionPoint = this._li.getIntersection(0).copy();
            this._hasProper = true;
            if (this._isDoneWhenProperInt) {
              this._isDone = true;
            }
            if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;
          }
        }
      }
    }
  }, {
    key: "interfaces_",
    value: function interfaces_() {
      return [];
    }
  }, {
    key: "getClass",
    value: function getClass() {
      return SegmentIntersector;
    }
  }], [{
    key: "isAdjacentSegments",
    value: function isAdjacentSegments(i1, i2) {
      return Math.abs(i1 - i2) === 1;
    }
  }]);
  return SegmentIntersector;
}();

var SimpleMCSweepLineIntersector = function (_EdgeSetIntersector) {
  inherits(SimpleMCSweepLineIntersector, _EdgeSetIntersector);

  function SimpleMCSweepLineIntersector() {
    classCallCheck(this, SimpleMCSweepLineIntersector);

    var _this = possibleConstructorReturn(this, (SimpleMCSweepLineIntersector.__proto__ || Object.getPrototypeOf(SimpleMCSweepLineIntersector)).call(this));

    _this.events = new ArrayList();
    _this.nOverlaps = null;
    return _this;
  }

  createClass(SimpleMCSweepLineIntersector, [{
    key: 'prepareEvents',
    value: function prepareEvents() {
      Collections.sort(this.events);
      for (var i = 0; i < this.events.size(); i++) {
        var ev = this.events.get(i);
        if (ev.isDelete()) {
          ev.getInsertEvent().setDeleteEventIndex(i);
        }
      }
    }
  }, {
    key: 'computeIntersections',
    value: function computeIntersections() {
      if (arguments.length === 1) {
        var si = arguments[0];
        this.nOverlaps = 0;
        this.prepareEvents();
        for (var i = 0; i < this.events.size(); i++) {
          var ev = this.events.get(i);
          if (ev.isInsert()) {
            this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
          }
          if (si.isDone()) {
            break;
          }
        }
      } else if (arguments.length === 3) {
        if (arguments[2] instanceof SegmentIntersector$2 && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {
          var edges0 = arguments[0];
          var edges1 = arguments[1];
          var _si = arguments[2];
          this.addEdges(edges0, edges0);
          this.addEdges(edges1, edges1);
          this.computeIntersections(_si);
        } else if (typeof arguments[2] === 'boolean' && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2) {
          var edges = arguments[0];
          var _si2 = arguments[1];
          var testAllSegments = arguments[2];
          if (testAllSegments) this.addEdges(edges, null);else this.addEdges(edges);
          this.computeIntersections(_si2);
        }
      }
    }
  }, {
    key: 'addEdge',
    value: function addEdge(edge, edgeSet) {
      var mce = edge.getMonotoneChainEdge();
      var startIndex = mce.getStartIndexes();
      for (var i = 0; i < startIndex.length - 1; i++) {
        var mc = new MonotoneChain$2(mce, i);
        var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
        this.events.add(insertEvent);
        this.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
      }
    }
  }, {
    key: 'processOverlaps',
    value: function processOverlaps(start, end, ev0, si) {
      var mc0 = ev0.getObject();
      for (var i = start; i < end; i++) {
        var ev1 = this.events.get(i);
        if (ev1.isInsert()) {
          var mc1 = ev1.getObject();
          if (!ev0.isSameLabel(ev1)) {
            mc0.computeIntersections(mc1, si);
            this.nOverlaps++;
          }
        }
      }
    }
  }, {
    key: 'addEdges',
    value: function addEdges() {
      if (arguments.length === 1) {
        var edges = arguments[0];
        for (var i = edges.iterator(); i.hasNext();) {
          var edge = i.next();
          this.addEdge(edge, edge);
        }
      } else if (arguments.length === 2) {
        var _edges = arguments[0];
        var edgeSet = arguments[1];
        for (var _i = _edges.iterator(); _i.hasNext();) {
          var _edge = _i.next();
          this.addEdge(_edge, edgeSet);
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SimpleMCSweepLineIntersector;
    }
  }]);
  return SimpleMCSweepLineIntersector;
}(EdgeSetIntersector);

var IntervalRTreeNode = function () {
  function IntervalRTreeNode() {
    classCallCheck(this, IntervalRTreeNode);

    this._min = Double.POSITIVE_INFINITY;
    this._max = Double.NEGATIVE_INFINITY;
  }

  createClass(IntervalRTreeNode, [{
    key: 'getMin',
    value: function getMin() {
      return this._min;
    }
  }, {
    key: 'intersects',
    value: function intersects(queryMin, queryMax) {
      if (this._min > queryMax || this._max < queryMin) return false;
      return true;
    }
  }, {
    key: 'getMax',
    value: function getMax() {
      return this._max;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return IntervalRTreeNode;
    }
  }], [{
    key: 'NodeComparator',
    get: function get$$1() {
      return NodeComparator;
    }
  }]);
  return IntervalRTreeNode;
}();

var NodeComparator = function () {
  function NodeComparator() {
    classCallCheck(this, NodeComparator);
  }

  createClass(NodeComparator, [{
    key: 'compare',
    value: function compare(o1, o2) {
      var n1 = o1;
      var n2 = o2;
      var mid1 = (n1._min + n1._max) / 2;
      var mid2 = (n2._min + n2._max) / 2;
      if (mid1 < mid2) return -1;
      if (mid1 > mid2) return 1;
      return 0;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [Comparator];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return NodeComparator;
    }
  }]);
  return NodeComparator;
}();

var IntervalRTreeLeafNode = function (_IntervalRTreeNode) {
  inherits(IntervalRTreeLeafNode, _IntervalRTreeNode);

  function IntervalRTreeLeafNode() {
    classCallCheck(this, IntervalRTreeLeafNode);

    var _this = possibleConstructorReturn(this, (IntervalRTreeLeafNode.__proto__ || Object.getPrototypeOf(IntervalRTreeLeafNode)).call(this));

    _this._item = null;
    var min = arguments[0];
    var max = arguments[1];
    var item = arguments[2];
    _this._min = min;
    _this._max = max;
    _this._item = item;
    return _this;
  }

  createClass(IntervalRTreeLeafNode, [{
    key: 'query',
    value: function query(queryMin, queryMax, visitor) {
      if (!this.intersects(queryMin, queryMax)) return null;
      visitor.visitItem(this._item);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return IntervalRTreeLeafNode;
    }
  }]);
  return IntervalRTreeLeafNode;
}(IntervalRTreeNode);

var IntervalRTreeBranchNode = function (_IntervalRTreeNode) {
  inherits(IntervalRTreeBranchNode, _IntervalRTreeNode);

  function IntervalRTreeBranchNode() {
    classCallCheck(this, IntervalRTreeBranchNode);

    var _this = possibleConstructorReturn(this, (IntervalRTreeBranchNode.__proto__ || Object.getPrototypeOf(IntervalRTreeBranchNode)).call(this));

    _this._node1 = null;
    _this._node2 = null;
    var n1 = arguments[0];
    var n2 = arguments[1];
    _this._node1 = n1;
    _this._node2 = n2;
    _this.buildExtent(_this._node1, _this._node2);
    return _this;
  }

  createClass(IntervalRTreeBranchNode, [{
    key: 'buildExtent',
    value: function buildExtent(n1, n2) {
      this._min = Math.min(n1._min, n2._min);
      this._max = Math.max(n1._max, n2._max);
    }
  }, {
    key: 'query',
    value: function query(queryMin, queryMax, visitor) {
      if (!this.intersects(queryMin, queryMax)) {
        return null;
      }
      if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);
      if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return IntervalRTreeBranchNode;
    }
  }]);
  return IntervalRTreeBranchNode;
}(IntervalRTreeNode);

var SortedPackedIntervalRTree = function () {
  function SortedPackedIntervalRTree() {
    classCallCheck(this, SortedPackedIntervalRTree);

    this._leaves = new ArrayList();
    this._root = null;
    this._level = 0;
  }

  createClass(SortedPackedIntervalRTree, [{
    key: 'buildTree',
    value: function buildTree() {
      Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
      var src = this._leaves;
      var temp = null;
      var dest = new ArrayList();
      while (true) {
        this.buildLevel(src, dest);
        if (dest.size() === 1) return dest.get(0);
        temp = src;
        src = dest;
        dest = temp;
      }
    }
  }, {
    key: 'insert',
    value: function insert(min, max, item) {
      if (this._root !== null) throw new Error('Index cannot be added to once it has been queried');
      this._leaves.add(new IntervalRTreeLeafNode(min, max, item));
    }
  }, {
    key: 'query',
    value: function query(min, max, visitor) {
      this.init();
      this._root.query(min, max, visitor);
    }
  }, {
    key: 'buildRoot',
    value: function buildRoot() {
      if (this._root !== null) return null;
      this._root = this.buildTree();
    }
  }, {
    key: 'printNode',
    value: function printNode(node) {
      System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
    }
  }, {
    key: 'init',
    value: function init() {
      if (this._root !== null) return null;
      this.buildRoot();
    }
  }, {
    key: 'buildLevel',
    value: function buildLevel(src, dest) {
      this._level++;
      dest.clear();
      for (var i = 0; i < src.size(); i += 2) {
        var n1 = src.get(i);
        var n2 = i + 1 < src.size() ? src.get(i) : null;
        if (n2 === null) {
          dest.add(n1);
        } else {
          var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));
          dest.add(node);
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SortedPackedIntervalRTree;
    }
  }]);
  return SortedPackedIntervalRTree;
}();

var ArrayListVisitor = function () {
  function ArrayListVisitor() {
    classCallCheck(this, ArrayListVisitor);

    this._items = new ArrayList();
  }

  createClass(ArrayListVisitor, [{
    key: 'visitItem',
    value: function visitItem(item) {
      this._items.add(item);
    }
  }, {
    key: 'getItems',
    value: function getItems() {
      return this._items;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [ItemVisitor];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return ArrayListVisitor;
    }
  }]);
  return ArrayListVisitor;
}();

var IndexedPointInAreaLocator = function () {
  function IndexedPointInAreaLocator() {
    classCallCheck(this, IndexedPointInAreaLocator);

    this._index = null;
    var g = arguments[0];
    if (!hasInterface(g, Polygonal)) throw new IllegalArgumentException('Argument must be Polygonal');
    this._index = new IntervalIndexedGeometry(g);
  }

  createClass(IndexedPointInAreaLocator, [{
    key: 'locate',
    value: function locate(p) {
      var rcc = new RayCrossingCounter(p);
      var visitor = new SegmentVisitor(rcc);
      this._index.query(p.y, p.y, visitor);
      return rcc.getLocation();
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [PointOnGeometryLocator];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return IndexedPointInAreaLocator;
    }
  }], [{
    key: 'SegmentVisitor',
    get: function get$$1() {
      return SegmentVisitor;
    }
  }, {
    key: 'IntervalIndexedGeometry',
    get: function get$$1() {
      return IntervalIndexedGeometry;
    }
  }]);
  return IndexedPointInAreaLocator;
}();

var SegmentVisitor = function () {
  function SegmentVisitor() {
    classCallCheck(this, SegmentVisitor);

    this._counter = null;
    var counter = arguments[0];
    this._counter = counter;
  }

  createClass(SegmentVisitor, [{
    key: 'visitItem',
    value: function visitItem(item) {
      var seg = item;
      this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [ItemVisitor];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return SegmentVisitor;
    }
  }]);
  return SegmentVisitor;
}();

var IntervalIndexedGeometry = function () {
  function IntervalIndexedGeometry() {
    classCallCheck(this, IntervalIndexedGeometry);

    this._index = new SortedPackedIntervalRTree();
    var geom = arguments[0];
    this.init(geom);
  }

  createClass(IntervalIndexedGeometry, [{
    key: 'init',
    value: function init(geom) {
      var lines = LinearComponentExtracter.getLines(geom);
      for (var i = lines.iterator(); i.hasNext();) {
        var line = i.next();
        var pts = line.getCoordinates();
        this.addLine(pts);
      }
    }
  }, {
    key: 'addLine',
    value: function addLine(pts) {
      for (var i = 1; i < pts.length; i++) {
        var seg = new LineSegment(pts[i - 1], pts[i]);
        var min = Math.min(seg.p0.y, seg.p1.y);
        var max = Math.max(seg.p0.y, seg.p1.y);
        this._index.insert(min, max, seg);
      }
    }
  }, {
    key: 'query',
    value: function query() {
      if (arguments.length === 2) {
        var min = arguments[0];
        var max = arguments[1];
        var visitor = new ArrayListVisitor();
        this._index.query(min, max, visitor);
        return visitor.getItems();
      } else if (arguments.length === 3) {
        var _min = arguments[0];
        var _max = arguments[1];
        var _visitor = arguments[2];
        this._index.query(_min, _max, _visitor);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return IntervalIndexedGeometry;
    }
  }]);
  return IntervalIndexedGeometry;
}();

var GeometryGraph = function (_PlanarGraph) {
  inherits(GeometryGraph, _PlanarGraph);

  function GeometryGraph() {
    classCallCheck(this, GeometryGraph);

    var _this = possibleConstructorReturn(this, (GeometryGraph.__proto__ || Object.getPrototypeOf(GeometryGraph)).call(this));

    _this._parentGeom = null;
    _this._lineEdgeMap = new HashMap();
    _this._boundaryNodeRule = null;
    _this._useBoundaryDeterminationRule = true;
    _this._argIndex = null;
    _this._boundaryNodes = null;
    _this._hasTooFewPoints = false;
    _this._invalidPoint = null;
    _this._areaPtLocator = null;
    _this._ptLocator = new PointLocator();
    if (arguments.length === 2) {
      var argIndex = arguments[0];
      var parentGeom = arguments[1];
      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
      _this._argIndex = argIndex;
      _this._parentGeom = parentGeom;
      _this._boundaryNodeRule = boundaryNodeRule;
      if (parentGeom !== null) {
        _this.add(parentGeom);
      }
    } else if (arguments.length === 3) {
      var _argIndex = arguments[0];
      var _parentGeom = arguments[1];
      var _boundaryNodeRule = arguments[2];
      _this._argIndex = _argIndex;
      _this._parentGeom = _parentGeom;
      _this._boundaryNodeRule = _boundaryNodeRule;
      if (_parentGeom !== null) {
        _this.add(_parentGeom);
      }
    }
    return _this;
  }

  createClass(GeometryGraph, [{
    key: 'insertBoundaryPoint',
    value: function insertBoundaryPoint(argIndex, coord) {
      var n = this._nodes.addNode(coord);
      var lbl = n.getLabel();
      var boundaryCount = 1;
      var loc = Location.NONE;
      loc = lbl.getLocation(argIndex, Position.ON);
      if (loc === Location.BOUNDARY) boundaryCount++;
      var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
      lbl.setLocation(argIndex, newLoc);
    }
  }, {
    key: 'computeSelfNodes',
    value: function computeSelfNodes() {
      if (arguments.length === 2) {
        var li = arguments[0];
        var computeRingSelfNodes = arguments[1];
        return this.computeSelfNodes(li, computeRingSelfNodes, false);
      } else if (arguments.length === 3) {
        var _li = arguments[0];
        var _computeRingSelfNodes = arguments[1];
        var isDoneIfProperInt = arguments[2];
        var si = new SegmentIntersector$2(_li, true, false);
        si.setIsDoneIfProperInt(isDoneIfProperInt);
        var esi = this.createEdgeSetIntersector();
        var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;
        var computeAllSegments = _computeRingSelfNodes || !isRings;
        esi.computeIntersections(this._edges, si, computeAllSegments);
        this.addSelfIntersectionNodes(this._argIndex);
        return si;
      }
    }
  }, {
    key: 'computeSplitEdges',
    value: function computeSplitEdges(edgelist) {
      for (var i = this._edges.iterator(); i.hasNext();) {
        var e = i.next();
        e.eiList.addSplitEdges(edgelist);
      }
    }
  }, {
    key: 'computeEdgeIntersections',
    value: function computeEdgeIntersections(g, li, includeProper) {
      var si = new SegmentIntersector$2(li, includeProper, true);
      si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
      var esi = this.createEdgeSetIntersector();
      esi.computeIntersections(this._edges, g._edges, si);
      return si;
    }
  }, {
    key: 'getGeometry',
    value: function getGeometry() {
      return this._parentGeom;
    }
  }, {
    key: 'getBoundaryNodeRule',
    value: function getBoundaryNodeRule() {
      return this._boundaryNodeRule;
    }
  }, {
    key: 'hasTooFewPoints',
    value: function hasTooFewPoints() {
      return this._hasTooFewPoints;
    }
  }, {
    key: 'addPoint',
    value: function addPoint() {
      if (arguments[0] instanceof Point) {
        var p = arguments[0];
        var coord = p.getCoordinate();
        this.insertPoint(this._argIndex, coord, Location.INTERIOR);
      } else if (arguments[0] instanceof Coordinate) {
        var pt = arguments[0];
        this.insertPoint(this._argIndex, pt, Location.INTERIOR);
      }
    }
  }, {
    key: 'addPolygon',
    value: function addPolygon(p) {
      this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
      for (var i = 0; i < p.getNumInteriorRing(); i++) {
        var hole = p.getInteriorRingN(i);
        this.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
      }
    }
  }, {
    key: 'addEdge',
    value: function addEdge(e) {
      this.insertEdge(e);
      var coord = e.getCoordinates();
      this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
      this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
    }
  }, {
    key: 'addLineString',
    value: function addLineString(line) {
      var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
      if (coord.length < 2) {
        this._hasTooFewPoints = true;
        this._invalidPoint = coord[0];
        return null;
      }
      var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));
      this._lineEdgeMap.put(line, e);
      this.insertEdge(e);
      Assert.isTrue(coord.length >= 2, 'found LineString with single point');
      this.insertBoundaryPoint(this._argIndex, coord[0]);
      this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
    }
  }, {
    key: 'getInvalidPoint',
    value: function getInvalidPoint() {
      return this._invalidPoint;
    }
  }, {
    key: 'getBoundaryPoints',
    value: function getBoundaryPoints() {
      var coll = this.getBoundaryNodes();
      var pts = new Array(coll.size()).fill(null);
      var i = 0;
      for (var it = coll.iterator(); it.hasNext();) {
        var node = it.next();
        pts[i++] = node.getCoordinate().copy();
      }
      return pts;
    }
  }, {
    key: 'getBoundaryNodes',
    value: function getBoundaryNodes() {
      if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
      return this._boundaryNodes;
    }
  }, {
    key: 'addSelfIntersectionNode',
    value: function addSelfIntersectionNode(argIndex, coord, loc) {
      if (this.isBoundaryNode(argIndex, coord)) return null;
      if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);else this.insertPoint(argIndex, coord, loc);
    }
  }, {
    key: 'addPolygonRing',
    value: function addPolygonRing(lr, cwLeft, cwRight) {
      if (lr.isEmpty()) return null;
      var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
      if (coord.length < 4) {
        this._hasTooFewPoints = true;
        this._invalidPoint = coord[0];
        return null;
      }
      var left = cwLeft;
      var right = cwRight;
      if (CGAlgorithms.isCCW(coord)) {
        left = cwRight;
        right = cwLeft;
      }
      var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
      this._lineEdgeMap.put(lr, e);
      this.insertEdge(e);
      this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
    }
  }, {
    key: 'insertPoint',
    value: function insertPoint(argIndex, coord, onLocation) {
      var n = this._nodes.addNode(coord);
      var lbl = n.getLabel();
      if (lbl === null) {
        n._label = new Label(argIndex, onLocation);
      } else lbl.setLocation(argIndex, onLocation);
    }
  }, {
    key: 'createEdgeSetIntersector',
    value: function createEdgeSetIntersector() {
      return new SimpleMCSweepLineIntersector();
    }
  }, {
    key: 'addSelfIntersectionNodes',
    value: function addSelfIntersectionNodes(argIndex) {
      for (var i = this._edges.iterator(); i.hasNext();) {
        var e = i.next();
        var eLoc = e.getLabel().getLocation(argIndex);
        for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {
          var ei = eiIt.next();
          this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
        }
      }
    }
  }, {
    key: 'add',
    value: function add() {
      if (arguments.length === 1) {
        var g = arguments[0];
        if (g.isEmpty()) return null;
        if (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;
        if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new Error(g.getClass().getName());
      } else return PlanarGraph.prototype.add.apply(this, arguments);
    }
  }, {
    key: 'addCollection',
    value: function addCollection(gc) {
      for (var i = 0; i < gc.getNumGeometries(); i++) {
        var g = gc.getGeometryN(i);
        this.add(g);
      }
    }
  }, {
    key: 'locate',
    value: function locate(pt) {
      if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
        if (this._areaPtLocator === null) {
          this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
        }
        return this._areaPtLocator.locate(pt);
      }
      return this._ptLocator.locate(pt, this._parentGeom);
    }
  }, {
    key: 'findEdge',
    value: function findEdge() {
      if (arguments.length === 1) {
        var line = arguments[0];
        return this._lineEdgeMap.get(line);
      } else return PlanarGraph.prototype.findEdge.apply(this, arguments);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryGraph;
    }
  }], [{
    key: 'determineBoundary',
    value: function determineBoundary(boundaryNodeRule, boundaryCount) {
      return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;
    }
  }]);
  return GeometryGraph;
}(PlanarGraph);

var GeometryGraphOp = function () {
  function GeometryGraphOp() {
    classCallCheck(this, GeometryGraphOp);

    this._li = new RobustLineIntersector();
    this._resultPrecisionModel = null;
    this._arg = null;
    if (arguments.length === 1) {
      var g0 = arguments[0];
      this.setComputationPrecision(g0.getPrecisionModel());
      this._arg = new Array(1).fill(null);
      this._arg[0] = new GeometryGraph(0, g0);
    } else if (arguments.length === 2) {
      var _g = arguments[0];
      var g1 = arguments[1];
      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
      if (_g.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(_g.getPrecisionModel());else this.setComputationPrecision(g1.getPrecisionModel());
      this._arg = new Array(2).fill(null);
      this._arg[0] = new GeometryGraph(0, _g, boundaryNodeRule);
      this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);
    } else if (arguments.length === 3) {
      var _g2 = arguments[0];
      var _g3 = arguments[1];
      var _boundaryNodeRule = arguments[2];
      if (_g2.getPrecisionModel().compareTo(_g3.getPrecisionModel()) >= 0) this.setComputationPrecision(_g2.getPrecisionModel());else this.setComputationPrecision(_g3.getPrecisionModel());
      this._arg = new Array(2).fill(null);
      this._arg[0] = new GeometryGraph(0, _g2, _boundaryNodeRule);
      this._arg[1] = new GeometryGraph(1, _g3, _boundaryNodeRule);
    }
  }

  createClass(GeometryGraphOp, [{
    key: 'getArgGeometry',
    value: function getArgGeometry(i) {
      return this._arg[i].getGeometry();
    }
  }, {
    key: 'setComputationPrecision',
    value: function setComputationPrecision(pm) {
      this._resultPrecisionModel = pm;
      this._li.setPrecisionModel(this._resultPrecisionModel);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryGraphOp;
    }
  }]);
  return GeometryGraphOp;
}();

// operation.geometrygraph

var GeometryMapper = function () {
  function GeometryMapper() {
    classCallCheck(this, GeometryMapper);
  }

  createClass(GeometryMapper, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryMapper;
    }
  }], [{
    key: 'map',
    value: function map() {
      if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {
        var geom = arguments[0];
        var op = arguments[1];
        var mapped = new ArrayList();
        for (var i = 0; i < geom.getNumGeometries(); i++) {
          var g = op.map(geom.getGeometryN(i));
          if (g !== null) mapped.add(g);
        }
        return geom.getFactory().buildGeometry(mapped);
      } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {
        var geoms = arguments[0];
        var _op = arguments[1];
        var _mapped = new ArrayList();
        for (var _i = geoms.iterator(); _i.hasNext();) {
          var _g = _i.next();
          var gr = _op.map(_g);
          if (gr !== null) _mapped.add(gr);
        }
        return _mapped;
      }
    }
  }, {
    key: 'MapOp',
    value: function MapOp() {}
  }]);
  return GeometryMapper;
}();

var OverlayOp = function (_GeometryGraphOp) {
  inherits(OverlayOp, _GeometryGraphOp);

  function OverlayOp() {
    classCallCheck(this, OverlayOp);

    var g0 = arguments[0];
    var g1 = arguments[1];

    var _this = possibleConstructorReturn(this, (OverlayOp.__proto__ || Object.getPrototypeOf(OverlayOp)).call(this, g0, g1));

    _this._ptLocator = new PointLocator();
    _this._geomFact = null;
    _this._resultGeom = null;
    _this._graph = null;
    _this._edgeList = new EdgeList();
    _this._resultPolyList = new ArrayList();
    _this._resultLineList = new ArrayList();
    _this._resultPointList = new ArrayList();
    _this._graph = new PlanarGraph(new OverlayNodeFactory());
    _this._geomFact = g0.getFactory();
    return _this;
  }

  createClass(OverlayOp, [{
    key: 'insertUniqueEdge',
    value: function insertUniqueEdge(e) {
      var existingEdge = this._edgeList.findEqualEdge(e);
      if (existingEdge !== null) {
        var existingLabel = existingEdge.getLabel();
        var labelToMerge = e.getLabel();
        if (!existingEdge.isPointwiseEqual(e)) {
          labelToMerge = new Label(e.getLabel());
          labelToMerge.flip();
        }
        var depth = existingEdge.getDepth();
        if (depth.isNull()) {
          depth.add(existingLabel);
        }
        depth.add(labelToMerge);
        existingLabel.merge(labelToMerge);
      } else {
        this._edgeList.add(e);
      }
    }
  }, {
    key: 'getGraph',
    value: function getGraph() {
      return this._graph;
    }
  }, {
    key: 'cancelDuplicateResultEdges',
    value: function cancelDuplicateResultEdges() {
      for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
        var de = it.next();
        var sym = de.getSym();
        if (de.isInResult() && sym.isInResult()) {
          de.setInResult(false);
          sym.setInResult(false);
        }
      }
    }
  }, {
    key: 'isCoveredByLA',
    value: function isCoveredByLA(coord) {
      if (this.isCovered(coord, this._resultLineList)) return true;
      if (this.isCovered(coord, this._resultPolyList)) return true;
      return false;
    }
  }, {
    key: 'computeGeometry',
    value: function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {
      var geomList = new ArrayList();
      geomList.addAll(resultPointList);
      geomList.addAll(resultLineList);
      geomList.addAll(resultPolyList);
      if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
      return this._geomFact.buildGeometry(geomList);
    }
  }, {
    key: 'mergeSymLabels',
    value: function mergeSymLabels() {
      for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        node.getEdges().mergeSymLabels();
      }
    }
  }, {
    key: 'isCovered',
    value: function isCovered(coord, geomList) {
      for (var it = geomList.iterator(); it.hasNext();) {
        var geom = it.next();
        var loc = this._ptLocator.locate(coord, geom);
        if (loc !== Location.EXTERIOR) return true;
      }
      return false;
    }
  }, {
    key: 'replaceCollapsedEdges',
    value: function replaceCollapsedEdges() {
      var newEdges = new ArrayList();
      for (var it = this._edgeList.iterator(); it.hasNext();) {
        var e = it.next();
        if (e.isCollapsed()) {
          it.remove();
          newEdges.add(e.getCollapsedEdge());
        }
      }
      this._edgeList.addAll(newEdges);
    }
  }, {
    key: 'updateNodeLabelling',
    value: function updateNodeLabelling() {
      for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        var lbl = node.getEdges().getLabel();
        node.getLabel().merge(lbl);
      }
    }
  }, {
    key: 'getResultGeometry',
    value: function getResultGeometry(overlayOpCode) {
      this.computeOverlay(overlayOpCode);
      return this._resultGeom;
    }
  }, {
    key: 'insertUniqueEdges',
    value: function insertUniqueEdges(edges) {
      for (var i = edges.iterator(); i.hasNext();) {
        var e = i.next();
        this.insertUniqueEdge(e);
      }
    }
  }, {
    key: 'computeOverlay',
    value: function computeOverlay(opCode) {
      this.copyPoints(0);
      this.copyPoints(1);
      this._arg[0].computeSelfNodes(this._li, false);
      this._arg[1].computeSelfNodes(this._li, false);
      this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
      var baseSplitEdges = new ArrayList();
      this._arg[0].computeSplitEdges(baseSplitEdges);
      this._arg[1].computeSplitEdges(baseSplitEdges);
      // const splitEdges = baseSplitEdges
      this.insertUniqueEdges(baseSplitEdges);
      this.computeLabelsFromDepths();
      this.replaceCollapsedEdges();
      EdgeNodingValidator.checkValid(this._edgeList.getEdges());
      this._graph.addEdges(this._edgeList.getEdges());
      this.computeLabelling();
      this.labelIncompleteNodes();
      this.findResultAreaEdges(opCode);
      this.cancelDuplicateResultEdges();
      var polyBuilder = new PolygonBuilder(this._geomFact);
      polyBuilder.add(this._graph);
      this._resultPolyList = polyBuilder.getPolygons();
      var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
      this._resultLineList = lineBuilder.build(opCode);
      var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
      this._resultPointList = pointBuilder.build(opCode);
      this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
    }
  }, {
    key: 'labelIncompleteNode',
    value: function labelIncompleteNode(n, targetIndex) {
      var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
      n.getLabel().setLocation(targetIndex, loc);
    }
  }, {
    key: 'copyPoints',
    value: function copyPoints(argIndex) {
      for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {
        var graphNode = i.next();
        var newNode = this._graph.addNode(graphNode.getCoordinate());
        newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
      }
    }
  }, {
    key: 'findResultAreaEdges',
    value: function findResultAreaEdges(opCode) {
      for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
        var de = it.next();
        var label = de.getLabel();
        if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
          de.setInResult(true);
        }
      }
    }
  }, {
    key: 'computeLabelsFromDepths',
    value: function computeLabelsFromDepths() {
      for (var it = this._edgeList.iterator(); it.hasNext();) {
        var e = it.next();
        var lbl = e.getLabel();
        var depth = e.getDepth();
        if (!depth.isNull()) {
          depth.normalize();
          for (var i = 0; i < 2; i++) {
            if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
              if (depth.getDelta(i) === 0) {
                lbl.toLine(i);
              } else {
                Assert.isTrue(!depth.isNull(i, Position.LEFT), 'depth of LEFT side has not been initialized');
                lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));
                Assert.isTrue(!depth.isNull(i, Position.RIGHT), 'depth of RIGHT side has not been initialized');
                lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));
              }
            }
          }
        }
      }
    }
  }, {
    key: 'computeLabelling',
    value: function computeLabelling() {
      for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        node.getEdges().computeLabelling(this._arg);
      }
      this.mergeSymLabels();
      this.updateNodeLabelling();
    }
  }, {
    key: 'labelIncompleteNodes',
    value: function labelIncompleteNodes() {
      // let nodeCount = 0
      for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {
        var n = ni.next();
        var label = n.getLabel();
        if (n.isIsolated()) {
          // nodeCount++
          if (label.isNull(0)) this.labelIncompleteNode(n, 0);else this.labelIncompleteNode(n, 1);
        }
        n.getEdges().updateLabelling(label);
      }
    }
  }, {
    key: 'isCoveredByA',
    value: function isCoveredByA(coord) {
      if (this.isCovered(coord, this._resultPolyList)) return true;
      return false;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OverlayOp;
    }
  }]);
  return OverlayOp;
}(GeometryGraphOp);

OverlayOp.overlayOp = function (geom0, geom1, opCode) {
  var gov = new OverlayOp(geom0, geom1);
  var geomOv = gov.getResultGeometry(opCode);
  return geomOv;
};
OverlayOp.intersection = function (g, other) {
  if (g.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());
  if (g.isGeometryCollection()) {
    var g2 = other;
    return GeometryCollectionMapper.map(g, {
      interfaces_: function interfaces_() {
        return [GeometryMapper.MapOp];
      },
      map: function map(g) {
        return g.intersection(g2);
      }
    });
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);
};
OverlayOp.symDifference = function (g, other) {
  if (g.isEmpty() || other.isEmpty()) {
    if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());
    if (g.isEmpty()) return other.copy();
    if (other.isEmpty()) return g.copy();
  }
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);
};
OverlayOp.resultDimension = function (opCode, g0, g1) {
  var dim0 = g0.getDimension();
  var dim1 = g1.getDimension();
  var resultDimension = -1;
  switch (opCode) {
    case OverlayOp.INTERSECTION:
      resultDimension = Math.min(dim0, dim1);
      break;
    case OverlayOp.UNION:
      resultDimension = Math.max(dim0, dim1);
      break;
    case OverlayOp.DIFFERENCE:
      resultDimension = dim0;
      break;
    case OverlayOp.SYMDIFFERENCE:
      resultDimension = Math.max(dim0, dim1);
      break;
    default:
  }
  return resultDimension;
};
OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {
  var result = null;
  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
    case -1:
      result = geomFact.createGeometryCollection(new Array(0).fill(null));
      break;
    case 0:
      result = geomFact.createPoint();
      break;
    case 1:
      result = geomFact.createLineString();
      break;
    case 2:
      result = geomFact.createPolygon();
      break;
    default:
  }
  return result;
};
OverlayOp.difference = function (g, other) {
  if (g.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());
  if (other.isEmpty()) return g.copy();
  g.checkNotGeometryCollection(g);
  g.checkNotGeometryCollection(other);
  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);
};
OverlayOp.isResultOfOp = function () {
  if (arguments.length === 2) {
    var label = arguments[0];
    var opCode = arguments[1];
    var loc0 = label.getLocation(0);
    var loc1 = label.getLocation(1);
    return OverlayOp.isResultOfOp(loc0, loc1, opCode);
  } else if (arguments.length === 3) {
    var _loc = arguments[0];
    var _loc2 = arguments[1];
    var overlayOpCode = arguments[2];
    if (_loc === Location.BOUNDARY) _loc = Location.INTERIOR;
    if (_loc2 === Location.BOUNDARY) _loc2 = Location.INTERIOR;
    switch (overlayOpCode) {
      case OverlayOp.INTERSECTION:
        return _loc === Location.INTERIOR && _loc2 === Location.INTERIOR;
      case OverlayOp.UNION:
        return _loc === Location.INTERIOR || _loc2 === Location.INTERIOR;
      case OverlayOp.DIFFERENCE:
        return _loc === Location.INTERIOR && _loc2 !== Location.INTERIOR;
      case OverlayOp.SYMDIFFERENCE:
        return _loc === Location.INTERIOR && _loc2 !== Location.INTERIOR || _loc !== Location.INTERIOR && _loc2 === Location.INTERIOR;
      default:
    }
    return false;
  }
};
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;

var ConsistentPolygonRingChecker = function () {
  function ConsistentPolygonRingChecker() {
    classCallCheck(this, ConsistentPolygonRingChecker);

    this._graph = null;
    this._SCANNING_FOR_INCOMING = 1;
    this._LINKING_TO_OUTGOING = 2;
    var graph = arguments[0];
    this._graph = graph;
  }

  createClass(ConsistentPolygonRingChecker, [{
    key: 'testLinkResultDirectedEdges',
    value: function testLinkResultDirectedEdges(deStar, opCode) {
      var ringEdges = this.getPotentialResultAreaEdges(deStar, opCode);
      var firstOut = null;
      // let incoming = null
      var state = this._SCANNING_FOR_INCOMING;
      for (var i = 0; i < ringEdges.size(); i++) {
        var nextOut = ringEdges.get(i);
        var nextIn = nextOut.getSym();
        if (!nextOut.getLabel().isArea()) continue;
        if (firstOut === null && this.isPotentialResultAreaEdge(nextOut, opCode)) firstOut = nextOut;
        switch (state) {
          case this._SCANNING_FOR_INCOMING:
            if (!this.isPotentialResultAreaEdge(nextIn, opCode)) continue;
            // incoming = nextIn
            state = this._LINKING_TO_OUTGOING;
            break;
          case this._LINKING_TO_OUTGOING:
            if (!this.isPotentialResultAreaEdge(nextOut, opCode)) continue;
            state = this._SCANNING_FOR_INCOMING;
            break;
          default:
        }
      }
      if (state === this._LINKING_TO_OUTGOING) {
        if (firstOut === null) throw new TopologyException('no outgoing dirEdge found', deStar.getCoordinate());
      }
    }
  }, {
    key: 'getPotentialResultAreaEdges',
    value: function getPotentialResultAreaEdges(deStar, opCode) {
      var resultAreaEdgeList = new ArrayList();
      for (var it = deStar.iterator(); it.hasNext();) {
        var de = it.next();
        if (this.isPotentialResultAreaEdge(de, opCode) || this.isPotentialResultAreaEdge(de.getSym(), opCode)) resultAreaEdgeList.add(de);
      }
      return resultAreaEdgeList;
    }
  }, {
    key: 'checkAll',
    value: function checkAll() {
      this.check(OverlayOp.INTERSECTION);
      this.check(OverlayOp.DIFFERENCE);
      this.check(OverlayOp.UNION);
      this.check(OverlayOp.SYMDIFFERENCE);
    }
  }, {
    key: 'check',
    value: function check(opCode) {
      for (var nodeit = this._graph.getNodeIterator(); nodeit.hasNext();) {
        var node = nodeit.next();
        this.testLinkResultDirectedEdges(node.getEdges(), opCode);
      }
    }
  }, {
    key: 'isPotentialResultAreaEdge',
    value: function isPotentialResultAreaEdge(de, opCode) {
      var label = de.getLabel();
      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
        return true;
      }
      return false;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return ConsistentPolygonRingChecker;
    }
  }]);
  return ConsistentPolygonRingChecker;
}();

var EdgeSetNoder = function () {
  function EdgeSetNoder() {
    classCallCheck(this, EdgeSetNoder);

    this._li = null;
    this._inputEdges = new ArrayList();
    var li = arguments[0];
    this._li = li;
  }

  createClass(EdgeSetNoder, [{
    key: 'addEdges',
    value: function addEdges(edges) {
      this._inputEdges.addAll(edges);
    }
  }, {
    key: 'getNodedEdges',
    value: function getNodedEdges() {
      var esi = new SimpleMCSweepLineIntersector();
      var si = new SegmentIntersector$2(this._li, true, false);
      esi.computeIntersections(this._inputEdges, si, true);
      var splitEdges = new ArrayList();
      for (var i = this._inputEdges.iterator(); i.hasNext();) {
        var e = i.next();
        e.getEdgeIntersectionList().addSplitEdges(splitEdges);
      }
      return splitEdges;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return EdgeSetNoder;
    }
  }]);
  return EdgeSetNoder;
}();

var FuzzyPointLocator = function () {
  function FuzzyPointLocator() {
    classCallCheck(this, FuzzyPointLocator);

    this._g = null;
    this._boundaryDistanceTolerance = null;
    this._linework = null;
    this._ptLocator = new PointLocator();
    this._seg = new LineSegment();
    var g = arguments[0];
    var boundaryDistanceTolerance = arguments[1];
    this._g = g;
    this._boundaryDistanceTolerance = boundaryDistanceTolerance;
    this._linework = this.extractLinework(g);
  }

  createClass(FuzzyPointLocator, [{
    key: 'isWithinToleranceOfBoundary',
    value: function isWithinToleranceOfBoundary(pt) {
      for (var i = 0; i < this._linework.getNumGeometries(); i++) {
        var line = this._linework.getGeometryN(i);
        var seq = line.getCoordinateSequence();
        for (var j = 0; j < seq.size() - 1; j++) {
          seq.getCoordinate(j, this._seg.p0);
          seq.getCoordinate(j + 1, this._seg.p1);
          var dist = this._seg.distance(pt);
          if (dist <= this._boundaryDistanceTolerance) return true;
        }
      }
      return false;
    }
  }, {
    key: 'getLocation',
    value: function getLocation(pt) {
      if (this.isWithinToleranceOfBoundary(pt)) return Location.BOUNDARY;
      return this._ptLocator.locate(pt, this._g);
    }
  }, {
    key: 'extractLinework',
    value: function extractLinework(g) {
      var extracter = new PolygonalLineworkExtracter();
      g.apply(extracter);
      var linework = extracter.getLinework();
      var lines = GeometryFactory.toLineStringArray(linework);
      return g.getFactory().createMultiLineString(lines);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return FuzzyPointLocator;
    }
  }]);
  return FuzzyPointLocator;
}();

var PolygonalLineworkExtracter = function () {
  function PolygonalLineworkExtracter() {
    classCallCheck(this, PolygonalLineworkExtracter);

    this._linework = null;
    this._linework = new ArrayList();
  }

  createClass(PolygonalLineworkExtracter, [{
    key: 'getLinework',
    value: function getLinework() {
      return this._linework;
    }
  }, {
    key: 'filter',
    value: function filter(g) {
      if (g instanceof Polygon) {
        var poly = g;
        this._linework.add(poly.getExteriorRing());
        for (var i = 0; i < poly.getNumInteriorRing(); i++) {
          this._linework.add(poly.getInteriorRingN(i));
        }
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PolygonalLineworkExtracter;
    }
  }]);
  return PolygonalLineworkExtracter;
}();

var OffsetPointGenerator = function () {
  function OffsetPointGenerator() {
    classCallCheck(this, OffsetPointGenerator);

    this._g = null;
    this._doLeft = true;
    this._doRight = true;
    var g = arguments[0];
    this._g = g;
  }

  createClass(OffsetPointGenerator, [{
    key: 'extractPoints',
    value: function extractPoints(line, offsetDistance, offsetPts) {
      var pts = line.getCoordinates();
      for (var i = 0; i < pts.length - 1; i++) {
        this.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);
      }
    }
  }, {
    key: 'setSidesToGenerate',
    value: function setSidesToGenerate(doLeft, doRight) {
      this._doLeft = doLeft;
      this._doRight = doRight;
    }
  }, {
    key: 'getPoints',
    value: function getPoints(offsetDistance) {
      var offsetPts = new ArrayList();
      var lines = LinearComponentExtracter.getLines(this._g);
      for (var i = lines.iterator(); i.hasNext();) {
        var line = i.next();
        this.extractPoints(line, offsetDistance, offsetPts);
      }
      return offsetPts;
    }
  }, {
    key: 'computeOffsetPoints',
    value: function computeOffsetPoints(p0, p1, offsetDistance, offsetPts) {
      var dx = p1.x - p0.x;
      var dy = p1.y - p0.y;
      var len = Math.sqrt(dx * dx + dy * dy);
      var ux = offsetDistance * dx / len;
      var uy = offsetDistance * dy / len;
      var midX = (p1.x + p0.x) / 2;
      var midY = (p1.y + p0.y) / 2;
      if (this._doLeft) {
        var offsetLeft = new Coordinate(midX - uy, midY + ux);
        offsetPts.add(offsetLeft);
      }
      if (this._doRight) {
        var offsetRight = new Coordinate(midX + uy, midY - ux);
        offsetPts.add(offsetRight);
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OffsetPointGenerator;
    }
  }]);
  return OffsetPointGenerator;
}();

var OverlayResultValidator = function () {
  function OverlayResultValidator() {
    classCallCheck(this, OverlayResultValidator);

    this._geom = null;
    this._locFinder = null;
    this._location = new Array(3).fill(null);
    this._invalidLocation = null;
    this._boundaryDistanceTolerance = OverlayResultValidator.TOLERANCE;
    this._testCoords = new ArrayList();
    var a = arguments[0];
    var b = arguments[1];
    var result = arguments[2];
    this._boundaryDistanceTolerance = OverlayResultValidator.computeBoundaryDistanceTolerance(a, b);
    this._geom = [a, b, result];
    this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];
  }

  createClass(OverlayResultValidator, [{
    key: 'reportResult',
    value: function reportResult(overlayOp, location, expectedInterior) {
      System.out.println('Overlay result invalid - A:' + Location.toLocationSymbol(location[0]) + ' B:' + Location.toLocationSymbol(location[1]) + ' expected:' + (expectedInterior ? 'i' : 'e') + ' actual:' + Location.toLocationSymbol(location[2]));
    }
  }, {
    key: 'isValid',
    value: function isValid(overlayOp) {
      this.addTestPts(this._geom[0]);
      this.addTestPts(this._geom[1]);
      var isValid = this.checkValid(overlayOp);
      return isValid;
    }
  }, {
    key: 'checkValid',
    value: function checkValid() {
      if (arguments.length === 1) {
        var overlayOp = arguments[0];
        for (var i = 0; i < this._testCoords.size(); i++) {
          var pt = this._testCoords.get(i);
          if (!this.checkValid(overlayOp, pt)) {
            this._invalidLocation = pt;
            return false;
          }
        }
        return true;
      } else if (arguments.length === 2) {
        var _overlayOp = arguments[0];
        var _pt = arguments[1];
        this._location[0] = this._locFinder[0].getLocation(_pt);
        this._location[1] = this._locFinder[1].getLocation(_pt);
        this._location[2] = this._locFinder[2].getLocation(_pt);
        if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) return true;
        return this.isValidResult(_overlayOp, this._location);
      }
    }
  }, {
    key: 'addTestPts',
    value: function addTestPts(g) {
      var ptGen = new OffsetPointGenerator(g);
      this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));
    }
  }, {
    key: 'isValidResult',
    value: function isValidResult(overlayOp, location) {
      var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);
      var resultInInterior = location[2] === Location.INTERIOR;
      var isValid = !(expectedInterior ^ resultInInterior);
      if (!isValid) this.reportResult(overlayOp, location, expectedInterior);
      return isValid;
    }
  }, {
    key: 'getInvalidLocation',
    value: function getInvalidLocation() {
      return this._invalidLocation;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return OverlayResultValidator;
    }
  }], [{
    key: 'hasLocation',
    value: function hasLocation(location, loc) {
      for (var i = 0; i < 3; i++) {
        if (location[i] === loc) return true;
      }
      return false;
    }
  }, {
    key: 'computeBoundaryDistanceTolerance',
    value: function computeBoundaryDistanceTolerance(g0, g1) {
      return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1));
    }
  }, {
    key: 'isValid',
    value: function isValid(a, b, overlayOp, result) {
      var validator = new OverlayResultValidator(a, b, result);
      return validator.isValid(overlayOp);
    }
  }, {
    key: 'TOLERANCE',
    get: function get$$1() {
      return 0.000001;
    }
  }]);
  return OverlayResultValidator;
}();

// operation.overlay

var GeometryCombiner = function () {
  function GeometryCombiner(geoms) {
    classCallCheck(this, GeometryCombiner);

    this._geomFactory = null;
    this._skipEmpty = false;
    this._inputGeoms = null;
    this._geomFactory = GeometryCombiner.extractFactory(geoms);
    this._inputGeoms = geoms;
  }

  createClass(GeometryCombiner, [{
    key: 'extractElements',
    value: function extractElements(geom, elems) {
      if (geom === null) return null;
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var elemGeom = geom.getGeometryN(i);
        if (this._skipEmpty && elemGeom.isEmpty()) continue;
        elems.add(elemGeom);
      }
    }
  }, {
    key: 'combine',
    value: function combine() {
      var elems = new ArrayList();
      for (var i = this._inputGeoms.iterator(); i.hasNext();) {
        var g = i.next();
        this.extractElements(g, elems);
      }
      if (elems.size() === 0) {
        if (this._geomFactory !== null) {
          return this._geomFactory.createGeometryCollection(null);
        }
        return null;
      }
      return this._geomFactory.buildGeometry(elems);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryCombiner;
    }
  }], [{
    key: 'combine',
    value: function combine() {
      if (arguments.length === 1) {
        var geoms = arguments[0];
        var combiner = new GeometryCombiner(geoms);
        return combiner.combine();
      } else if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        var _combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
        return _combiner.combine();
      } else if (arguments.length === 3) {
        var _g = arguments[0];
        var _g2 = arguments[1];
        var g2 = arguments[2];
        var _combiner2 = new GeometryCombiner(GeometryCombiner.createList(_g, _g2, g2));
        return _combiner2.combine();
      }
    }
  }, {
    key: 'extractFactory',
    value: function extractFactory(geoms) {
      if (geoms.isEmpty()) return null;
      return geoms.iterator().next().getFactory();
    }
  }, {
    key: 'createList',
    value: function createList() {
      if (arguments.length === 2) {
        var obj0 = arguments[0];
        var obj1 = arguments[1];
        var list = new ArrayList();
        list.add(obj0);
        list.add(obj1);
        return list;
      } else if (arguments.length === 3) {
        var _obj = arguments[0];
        var _obj2 = arguments[1];
        var obj2 = arguments[2];
        var _list = new ArrayList();
        _list.add(_obj);
        _list.add(_obj2);
        _list.add(obj2);
        return _list;
      }
    }
  }]);
  return GeometryCombiner;
}();

var CascadedPolygonUnion = function () {
  function CascadedPolygonUnion() {
    classCallCheck(this, CascadedPolygonUnion);

    this._inputPolys = null;
    this._geomFactory = null;
    var polys = arguments[0];
    this._inputPolys = polys;
    if (this._inputPolys === null) this._inputPolys = new ArrayList();
  }

  createClass(CascadedPolygonUnion, [{
    key: 'reduceToGeometries',
    value: function reduceToGeometries(geomTree) {
      var geoms = new ArrayList();
      for (var i = geomTree.iterator(); i.hasNext();) {
        var o = i.next();
        var geom = null;
        if (hasInterface(o, List)) {
          geom = this.unionTree(o);
        } else if (o instanceof Geometry) {
          geom = o;
        }
        geoms.add(geom);
      }
      return geoms;
    }
  }, {
    key: 'extractByEnvelope',
    value: function extractByEnvelope(env, geom, disjointGeoms) {
      var intersectingGeoms = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var elem = geom.getGeometryN(i);
        if (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);else disjointGeoms.add(elem);
      }
      return this._geomFactory.buildGeometry(intersectingGeoms);
    }
  }, {
    key: 'unionOptimized',
    value: function unionOptimized(g0, g1) {
      var g0Env = g0.getEnvelopeInternal();
      var g1Env = g1.getEnvelopeInternal();
      if (!g0Env.intersects(g1Env)) {
        var combo = GeometryCombiner.combine(g0, g1);
        return combo;
      }
      if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);
      var commonEnv = g0Env.intersection(g1Env);
      return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);
    }
  }, {
    key: 'union',
    value: function union() {
      if (this._inputPolys === null) throw new Error('union() method cannot be called twice');
      if (this._inputPolys.isEmpty()) return null;
      this._geomFactory = this._inputPolys.iterator().next().getFactory();
      var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
      for (var i = this._inputPolys.iterator(); i.hasNext();) {
        var item = i.next();
        index.insert(item.getEnvelopeInternal(), item);
      }
      this._inputPolys = null;
      var itemTree = index.itemsTree();
      var unionAll = this.unionTree(itemTree);
      return unionAll;
    }
  }, {
    key: 'binaryUnion',
    value: function binaryUnion() {
      if (arguments.length === 1) {
        var geoms = arguments[0];
        return this.binaryUnion(geoms, 0, geoms.size());
      } else if (arguments.length === 3) {
        var _geoms = arguments[0];
        var start = arguments[1];
        var end = arguments[2];
        if (end - start <= 1) {
          var g0 = CascadedPolygonUnion.getGeometry(_geoms, start);
          return this.unionSafe(g0, null);
        } else if (end - start === 2) {
          return this.unionSafe(CascadedPolygonUnion.getGeometry(_geoms, start), CascadedPolygonUnion.getGeometry(_geoms, start + 1));
        } else {
          var mid = Math.trunc((end + start) / 2);
          var _g = this.binaryUnion(_geoms, start, mid);
          var g1 = this.binaryUnion(_geoms, mid, end);
          return this.unionSafe(_g, g1);
        }
      }
    }
  }, {
    key: 'repeatedUnion',
    value: function repeatedUnion(geoms) {
      var union = null;
      for (var i = geoms.iterator(); i.hasNext();) {
        var g = i.next();
        if (union === null) union = g.copy();else union = union.union(g);
      }
      return union;
    }
  }, {
    key: 'unionSafe',
    value: function unionSafe(g0, g1) {
      if (g0 === null && g1 === null) return null;
      if (g0 === null) return g1.copy();
      if (g1 === null) return g0.copy();
      return this.unionOptimized(g0, g1);
    }
  }, {
    key: 'unionActual',
    value: function unionActual(g0, g1) {
      return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));
    }
  }, {
    key: 'unionTree',
    value: function unionTree(geomTree) {
      var geoms = this.reduceToGeometries(geomTree);
      var union = this.binaryUnion(geoms);
      return union;
    }
  }, {
    key: 'unionUsingEnvelopeIntersection',
    value: function unionUsingEnvelopeIntersection(g0, g1, common) {
      var disjointPolys = new ArrayList();
      var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
      var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
      var union = this.unionActual(g0Int, g1Int);
      disjointPolys.add(union);
      var overallUnion = GeometryCombiner.combine(disjointPolys);
      return overallUnion;
    }
  }, {
    key: 'bufferUnion',
    value: function bufferUnion() {
      if (arguments.length === 1) {
        var geoms = arguments[0];
        var factory = geoms.get(0).getFactory();
        var gColl = factory.buildGeometry(geoms);
        var unionAll = gColl.buffer(0.0);
        return unionAll;
      } else if (arguments.length === 2) {
        var g0 = arguments[0];
        var g1 = arguments[1];
        var _factory = g0.getFactory();
        var _gColl = _factory.createGeometryCollection([g0, g1]);
        var _unionAll = _gColl.buffer(0.0);
        return _unionAll;
      }
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return CascadedPolygonUnion;
    }
  }], [{
    key: 'restrictToPolygons',
    value: function restrictToPolygons(g) {
      if (hasInterface(g, Polygonal)) {
        return g;
      }
      var polygons = PolygonExtracter.getPolygons(g);
      if (polygons.size() === 1) return polygons.get(0);
      return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));
    }
  }, {
    key: 'getGeometry',
    value: function getGeometry(list, index) {
      if (index >= list.size()) return null;
      return list.get(index);
    }
  }, {
    key: 'union',
    value: function union(polys) {
      var op = new CascadedPolygonUnion(polys);
      return op.union();
    }
  }, {
    key: 'STRTREE_NODE_CAPACITY',
    get: function get$$1() {
      return 4;
    }
  }]);
  return CascadedPolygonUnion;
}();

var PointGeometryUnion = function () {
  function PointGeometryUnion() {
    classCallCheck(this, PointGeometryUnion);

    this._pointGeom = null;
    this._otherGeom = null;
    this._geomFact = null;
    var pointGeom = arguments[0];
    var otherGeom = arguments[1];
    this._pointGeom = pointGeom;
    this._otherGeom = otherGeom;
    this._geomFact = otherGeom.getFactory();
  }

  createClass(PointGeometryUnion, [{
    key: 'union',
    value: function union() {
      var locater = new PointLocator();
      var exteriorCoords = new TreeSet();
      for (var i = 0; i < this._pointGeom.getNumGeometries(); i++) {
        var point = this._pointGeom.getGeometryN(i);
        var coord = point.getCoordinate();
        var loc = locater.locate(coord, this._otherGeom);
        if (loc === Location.EXTERIOR) exteriorCoords.add(coord);
      }
      if (exteriorCoords.size() === 0) return this._otherGeom;
      var ptComp = null;
      var coords = CoordinateArrays.toCoordinateArray(exteriorCoords);
      if (coords.length === 1) {
        ptComp = this._geomFact.createPoint(coords[0]);
      } else {
        ptComp = this._geomFact.createMultiPointFromCoords(coords);
      }
      return GeometryCombiner.combine(ptComp, this._otherGeom);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return PointGeometryUnion;
    }
  }], [{
    key: 'union',
    value: function union(pointGeom, otherGeom) {
      var unioner = new PointGeometryUnion(pointGeom, otherGeom);
      return unioner.union();
    }
  }]);
  return PointGeometryUnion;
}();

var GeometryExtracter = function () {
  function GeometryExtracter(sortIndex, comps) {
    classCallCheck(this, GeometryExtracter);

    this._sortIndex = sortIndex !== undefined ? sortIndex : -1;
    this._comps = comps || null;
  }

  createClass(GeometryExtracter, [{
    key: 'filter',
    value: function filter(geom) {
      if (this._sortIndex === -1 || geom.getSortIndex() === this._sortIndex) this._comps.add(geom);
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [GeometryFilter];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return GeometryExtracter;
    }
  }], [{
    key: 'extract',
    value: function extract() {
      if (arguments.length === 2) {
        var geom = arguments[0];
        var sortIndex = arguments[1];
        return GeometryExtracter.extract(geom, sortIndex, new ArrayList());
      } else if (arguments.length === 3) {
        var _geom = arguments[0];
        var _sortIndex = arguments[1];
        var list = arguments[2];
        if (_geom.getSortIndex() === _sortIndex) {
          list.add(_geom);
        } else if (_geom instanceof GeometryCollection) {
          _geom.apply(new GeometryExtracter(_sortIndex, list));
        }
        return list;
      }
    }
  }]);
  return GeometryExtracter;
}();

var UnaryUnionOp = function () {
  function UnaryUnionOp() {
    classCallCheck(this, UnaryUnionOp);

    this._polygons = new ArrayList();
    this._lines = new ArrayList();
    this._points = new ArrayList();
    this._geomFact = null;
    if (arguments.length === 1) {
      if (hasInterface(arguments[0], Collection)) {
        var geoms = arguments[0];
        this.extract(geoms);
      } else if (arguments[0] instanceof Geometry) {
        var geom = arguments[0];
        this.extract(geom);
      }
    } else if (arguments.length === 2) {
      var _geoms = arguments[0];
      var geomFact = arguments[1];
      this._geomFact = geomFact;
      this.extract(_geoms);
    }
  }

  createClass(UnaryUnionOp, [{
    key: 'unionNoOpt',
    value: function unionNoOpt(g0) {
      var empty = this._geomFact.createPoint();
      return SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);
    }
  }, {
    key: 'unionWithNull',
    value: function unionWithNull(g0, g1) {
      if (g0 === null && g1 === null) return null;
      if (g1 === null) return g0;
      if (g0 === null) return g1;
      return g0.union(g1);
    }
  }, {
    key: 'extract',
    value: function extract() {
      if (hasInterface(arguments[0], Collection)) {
        var geoms = arguments[0];
        for (var i = geoms.iterator(); i.hasNext();) {
          var geom = i.next();
          this.extract(geom);
        }
      } else if (arguments[0] instanceof Geometry) {
        var _geom = arguments[0];
        if (this._geomFact === null) this._geomFact = _geom.getFactory();
        GeometryExtracter.extract(_geom, Geometry.SORTINDEX_POLYGON, this._polygons);
        GeometryExtracter.extract(_geom, Geometry.SORTINDEX_LINESTRING, this._lines);
        GeometryExtracter.extract(_geom, Geometry.SORTINDEX_POINT, this._points);
      }
    }
  }, {
    key: 'union',
    value: function union() {
      if (this._geomFact === null) {
        return null;
      }
      var unionPoints = null;
      if (this._points.size() > 0) {
        var ptGeom = this._geomFact.buildGeometry(this._points);
        unionPoints = this.unionNoOpt(ptGeom);
      }
      var unionLines = null;
      if (this._lines.size() > 0) {
        var lineGeom = this._geomFact.buildGeometry(this._lines);
        unionLines = this.unionNoOpt(lineGeom);
      }
      var unionPolygons = null;
      if (this._polygons.size() > 0) {
        unionPolygons = CascadedPolygonUnion.union(this._polygons);
      }
      var unionLA = this.unionWithNull(unionLines, unionPolygons);
      var union = null;
      if (unionPoints === null) union = unionLA;else if (unionLA === null) union = unionPoints;else union = PointGeometryUnion.union(unionPoints, unionLA);
      if (union === null) return this._geomFact.createGeometryCollection();
      return union;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return UnaryUnionOp;
    }
  }], [{
    key: 'union',
    value: function union() {
      if (arguments.length === 1) {
        if (hasInterface(arguments[0], Collection)) {
          var geoms = arguments[0];
          var op = new UnaryUnionOp(geoms);
          return op.union();
        } else if (arguments[0] instanceof Geometry) {
          var geom = arguments[0];
          var _op = new UnaryUnionOp(geom);
          return _op.union();
        }
      } else if (arguments.length === 2) {
        var _geoms2 = arguments[0];
        var geomFact = arguments[1];
        var _op2 = new UnaryUnionOp(_geoms2, geomFact);
        return _op2.union();
      }
    }
  }]);
  return UnaryUnionOp;
}();

var UnionInteracting = function () {
  function UnionInteracting() {
    classCallCheck(this, UnionInteracting);

    this._geomFactory = null;
    this._g0 = null;
    this._g1 = null;
    this._interacts0 = null;
    this._interacts1 = null;
    var g0 = arguments[0];
    var g1 = arguments[1];
    this._g0 = g0;
    this._g1 = g1;
    this._geomFactory = g0.getFactory();
    this._interacts0 = new Array(g0.getNumGeometries()).fill(null);
    this._interacts1 = new Array(g1.getNumGeometries()).fill(null);
  }

  createClass(UnionInteracting, [{
    key: 'extractElements',
    value: function extractElements(geom, interacts, isInteracting) {
      var extractedGeoms = new ArrayList();
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        var elem = geom.getGeometryN(i);
        if (interacts[i] === isInteracting) extractedGeoms.add(elem);
      }
      return this._geomFactory.buildGeometry(extractedGeoms);
    }
  }, {
    key: 'computeInteracting',
    value: function computeInteracting() {
      if (arguments.length === 0) {
        for (var i = 0; i < this._g0.getNumGeometries(); i++) {
          var elem = this._g0.getGeometryN(i);
          this._interacts0[i] = this.computeInteracting(elem);
        }
      } else if (arguments.length === 1) {
        var elem0 = arguments[0];
        var interactsWithAny = false;
        for (var _i = 0; _i < this._g1.getNumGeometries(); _i++) {
          var elem1 = this._g1.getGeometryN(_i);
          var interacts = elem1.getEnvelopeInternal().intersects(elem0.getEnvelopeInternal());
          if (interacts) this._interacts1[_i] = true;
          if (interacts) interactsWithAny = true;
        }
        return interactsWithAny;
      }
    }
  }, {
    key: 'union',
    value: function union() {
      this.computeInteracting();
      var int0 = this.extractElements(this._g0, this._interacts0, true);
      var int1 = this.extractElements(this._g1, this._interacts1, true);
      if (int0.isEmpty() || int1.isEmpty()) {
        System.out.println('found empty!');
      }
      var union = int0.union(int1);
      var disjoint0 = this.extractElements(this._g0, this._interacts0, false);
      var disjoint1 = this.extractElements(this._g1, this._interacts1, false);
      var overallUnion = GeometryCombiner.combine(union, disjoint0, disjoint1);
      return overallUnion;
    }
  }, {
    key: 'bufferUnion',
    value: function bufferUnion(g0, g1) {
      var factory = g0.getFactory();
      var gColl = factory.createGeometryCollection([g0, g1]);
      var unionAll = gColl.buffer(0.0);
      return unionAll;
    }
  }, {
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return UnionInteracting;
    }
  }], [{
    key: 'union',
    value: function union(g0, g1) {
      var uue = new UnionInteracting(g0, g1);
      return uue.union();
    }
  }]);
  return UnionInteracting;
}();

var UnionOp = function () {
  function UnionOp() {
    classCallCheck(this, UnionOp);
  }

  createClass(UnionOp, [{
    key: 'interfaces_',
    value: function interfaces_() {
      return [];
    }
  }, {
    key: 'getClass',
    value: function getClass() {
      return UnionOp;
    }
  }], [{
    key: 'union',
    value: function union(g, other) {
      if (g.isEmpty() || other.isEmpty()) {
        if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());
        if (g.isEmpty()) return other.copy();
        if (other.isEmpty()) return g.copy();
      }
      g.checkNotGeometryCollection(g);
      g.checkNotGeometryCollection(other);
      return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);
    }
  }]);
  return UnionOp;
}();

// operation.union

// operation

/**
 * Polyfill for IE support
 */

exports.GeoJSONReader = GeoJSONReader;
exports.GeoJSONWriter = GeoJSONWriter;
exports.OverlayOp = OverlayOp;
exports.UnionOp = UnionOp;
exports.BufferOp = BufferOp;
